<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gtsam: gtsam::GaussianBayesNet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gtsam
   &#160;<span id="projectnumber">4.0.0</span>
   </div>
   <div id="projectbrief">gtsam</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a03087.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="a03084.html">List of all members</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">gtsam::GaussianBayesNet Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A Bayes net made from linear-Gaussian densities. </p>
</div><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for gtsam::GaussianBayesNet:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="a03087.png" usemap="#gtsam::GaussianBayesNet_map" alt=""/>
  <map id="gtsam::GaussianBayesNet_map" name="gtsam::GaussianBayesNet_map">
<area href="a02887.html" alt="gtsam::FactorGraph&lt; GaussianConditional &gt;" shape="rect" coords="0,0,261,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Standard Constructors</div></td></tr>
<tr class="memitem:adecacf9eadcbced34a26cd234e34d197"><td class="memItemLeft" align="right" valign="top"><a id="adecacf9eadcbced34a26cd234e34d197"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03087.html#adecacf9eadcbced34a26cd234e34d197">GaussianBayesNet</a> ()</td></tr>
<tr class="memdesc:adecacf9eadcbced34a26cd234e34d197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct empty factor graph. <br /></td></tr>
<tr class="separator:adecacf9eadcbced34a26cd234e34d197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f5f693d7582da70a64ea80024fdf12"><td class="memTemplParams" colspan="2"><a id="ae4f5f693d7582da70a64ea80024fdf12"></a>
template&lt;typename ITERATOR &gt; </td></tr>
<tr class="memitem:ae4f5f693d7582da70a64ea80024fdf12"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a03087.html#ae4f5f693d7582da70a64ea80024fdf12">GaussianBayesNet</a> (ITERATOR firstConditional, ITERATOR lastConditional)</td></tr>
<tr class="memdesc:ae4f5f693d7582da70a64ea80024fdf12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from iterator over conditionals. <br /></td></tr>
<tr class="separator:ae4f5f693d7582da70a64ea80024fdf12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac863c8c8203f4cb9d099d6d1adf8fb3b"><td class="memTemplParams" colspan="2"><a id="ac863c8c8203f4cb9d099d6d1adf8fb3b"></a>
template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:ac863c8c8203f4cb9d099d6d1adf8fb3b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a03087.html#ac863c8c8203f4cb9d099d6d1adf8fb3b">GaussianBayesNet</a> (const CONTAINER &amp;conditionals)</td></tr>
<tr class="memdesc:ac863c8c8203f4cb9d099d6d1adf8fb3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from container of factors (shared_ptr or plain objects) <br /></td></tr>
<tr class="separator:ac863c8c8203f4cb9d099d6d1adf8fb3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b6b8d6390efc036e690dbaf5493ff4"><td class="memTemplParams" colspan="2"><a id="a91b6b8d6390efc036e690dbaf5493ff4"></a>
template&lt;class DERIVEDCONDITIONAL &gt; </td></tr>
<tr class="memitem:a91b6b8d6390efc036e690dbaf5493ff4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a03087.html#a91b6b8d6390efc036e690dbaf5493ff4">GaussianBayesNet</a> (const <a class="el" href="a02887.html">FactorGraph</a>&lt; DERIVEDCONDITIONAL &gt; &amp;graph)</td></tr>
<tr class="memdesc:a91b6b8d6390efc036e690dbaf5493ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit copy/downcast constructor to override explicit template container constructor. <br /></td></tr>
<tr class="separator:a91b6b8d6390efc036e690dbaf5493ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Testable</div></td></tr>
<tr class="memitem:a0dfaa4e6414429241119976691640017"><td class="memItemLeft" align="right" valign="top"><a id="a0dfaa4e6414429241119976691640017"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03087.html#a0dfaa4e6414429241119976691640017">equals</a> (const <a class="el" href="a03087.html">This</a> &amp;bn, double tol=1e-9) const</td></tr>
<tr class="memdesc:a0dfaa4e6414429241119976691640017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check equality. <br /></td></tr>
<tr class="separator:a0dfaa4e6414429241119976691640017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Standard Interface</div></td></tr>
<tr class="memitem:a01ccfdc104912f80933a0814dd469f40"><td class="memItemLeft" align="right" valign="top"><a id="a01ccfdc104912f80933a0814dd469f40"></a>
<a class="el" href="a03399.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03087.html#a01ccfdc104912f80933a0814dd469f40">optimize</a> () const</td></tr>
<tr class="memdesc:a01ccfdc104912f80933a0814dd469f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the <a class="el" href="a03087.html" title="A Bayes net made from linear-Gaussian densities.">GaussianBayesNet</a>, i.e. return \( x = R^{-1}*d \), by back-substitution. <br /></td></tr>
<tr class="separator:a01ccfdc104912f80933a0814dd469f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b987183cf89eef5973b7c3352e9662"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a03399.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03087.html#ab5b987183cf89eef5973b7c3352e9662">optimize</a> (const <a class="el" href="a03399.html">VectorValues</a> &amp;solutionForMissing) const</td></tr>
<tr class="memdesc:ab5b987183cf89eef5973b7c3352e9662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of optimize for incomplete <a class="el" href="a02879.html" title="A BayesNet is a tree of conditionals, stored in elimination order.">BayesNet</a>, needs solution for missing variables.  <a href="#ab5b987183cf89eef5973b7c3352e9662">More...</a><br /></td></tr>
<tr class="separator:ab5b987183cf89eef5973b7c3352e9662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4bf7623222114b8929266f89e96aeb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a03031.html">Ordering</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03087.html#aa4bf7623222114b8929266f89e96aeb5">ordering</a> () const</td></tr>
<tr class="memdesc:aa4bf7623222114b8929266f89e96aeb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return ordering corresponding to a topological sort.  <a href="#aa4bf7623222114b8929266f89e96aeb5">More...</a><br /></td></tr>
<tr class="separator:aa4bf7623222114b8929266f89e96aeb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Linear Algebra</div></td></tr>
<tr class="memitem:ab457a514b691290a40eb4ef1d264975f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; Matrix, Vector &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03087.html#ab457a514b691290a40eb4ef1d264975f">matrix</a> (boost::optional&lt; const <a class="el" href="a03031.html">Ordering</a> &amp; &gt; <a class="el" href="a03087.html#aa4bf7623222114b8929266f89e96aeb5">ordering</a>=boost::none) const</td></tr>
<tr class="memdesc:ab457a514b691290a40eb4ef1d264975f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return (dense) upper-triangular matrix representation Will return upper-triangular matrix only when using 'ordering' above.  <a href="#ab457a514b691290a40eb4ef1d264975f">More...</a><br /></td></tr>
<tr class="separator:ab457a514b691290a40eb4ef1d264975f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73cf84092ee57fa01609ae699b9282a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a03399.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03087.html#ac73cf84092ee57fa01609ae699b9282a">optimizeGradientSearch</a> () const</td></tr>
<tr class="memdesc:ac73cf84092ee57fa01609ae699b9282a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize along the gradient direction, with a closed-form computation to perform the line search.  <a href="#ac73cf84092ee57fa01609ae699b9282a">More...</a><br /></td></tr>
<tr class="separator:ac73cf84092ee57fa01609ae699b9282a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb5efde40fe64df5844ba1154933128"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a03399.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03087.html#afeb5efde40fe64df5844ba1154933128">gradient</a> (const <a class="el" href="a03399.html">VectorValues</a> &amp;x0) const</td></tr>
<tr class="memdesc:afeb5efde40fe64df5844ba1154933128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient of the energy function, \( \nabla_{x=x_0} \left\Vert \Sigma^{-1} R x - d \right\Vert^2 \), centered around \( x = x_0 \).  <a href="#afeb5efde40fe64df5844ba1154933128">More...</a><br /></td></tr>
<tr class="separator:afeb5efde40fe64df5844ba1154933128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882e37f9122d59c5f9f7ab927398cb24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a03399.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03087.html#a882e37f9122d59c5f9f7ab927398cb24">gradientAtZero</a> () const</td></tr>
<tr class="memdesc:a882e37f9122d59c5f9f7ab927398cb24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient of the energy function, \( \nabla_{x=0} \left\Vert \Sigma^{-1} R x - d \right\Vert^2 \), centered around zero.  <a href="#a882e37f9122d59c5f9f7ab927398cb24">More...</a><br /></td></tr>
<tr class="separator:a882e37f9122d59c5f9f7ab927398cb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db1291c789e604f170c756df896d80c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03087.html#a3db1291c789e604f170c756df896d80c">error</a> (const <a class="el" href="a03399.html">VectorValues</a> &amp;x) const</td></tr>
<tr class="memdesc:a3db1291c789e604f170c756df896d80c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mahalanobis norm error.  <a href="#a3db1291c789e604f170c756df896d80c">More...</a><br /></td></tr>
<tr class="separator:a3db1291c789e604f170c756df896d80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1f3b8337a4768252aaa17337749e2d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03087.html#aff1f3b8337a4768252aaa17337749e2d">determinant</a> () const</td></tr>
<tr class="memdesc:aff1f3b8337a4768252aaa17337749e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the determinant of a GassianBayesNet.  <a href="#aff1f3b8337a4768252aaa17337749e2d">More...</a><br /></td></tr>
<tr class="separator:aff1f3b8337a4768252aaa17337749e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab658420b5501d66d8df2d3fd5e78133b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03087.html#ab658420b5501d66d8df2d3fd5e78133b">logDeterminant</a> () const</td></tr>
<tr class="memdesc:ab658420b5501d66d8df2d3fd5e78133b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the log of the determinant of a GassianBayesNet.  <a href="#ab658420b5501d66d8df2d3fd5e78133b">More...</a><br /></td></tr>
<tr class="separator:ab658420b5501d66d8df2d3fd5e78133b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94dd75d08bf33718cfc2fd05abbdd17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a03399.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03087.html#ae94dd75d08bf33718cfc2fd05abbdd17">backSubstitute</a> (const <a class="el" href="a03399.html">VectorValues</a> &amp;gx) const</td></tr>
<tr class="memdesc:ae94dd75d08bf33718cfc2fd05abbdd17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backsubstitute with a different RHS vector than the one stored in this <a class="el" href="a02879.html" title="A BayesNet is a tree of conditionals, stored in elimination order.">BayesNet</a>.  <a href="#ae94dd75d08bf33718cfc2fd05abbdd17">More...</a><br /></td></tr>
<tr class="separator:ae94dd75d08bf33718cfc2fd05abbdd17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa082daa02b066634ea1b624263ce1819"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a03399.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03087.html#aa082daa02b066634ea1b624263ce1819">backSubstituteTranspose</a> (const <a class="el" href="a03399.html">VectorValues</a> &amp;gx) const</td></tr>
<tr class="memdesc:aa082daa02b066634ea1b624263ce1819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose backsubstitute with a different RHS vector than the one stored in this <a class="el" href="a02879.html" title="A BayesNet is a tree of conditionals, stored in elimination order.">BayesNet</a>.  <a href="#aa082daa02b066634ea1b624263ce1819">More...</a><br /></td></tr>
<tr class="separator:aa082daa02b066634ea1b624263ce1819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_a02887"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_a02887')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="a02887.html">gtsam::FactorGraph&lt; GaussianConditional &gt;</a></td></tr>
<tr class="memitem:afea8c7bf4fd19ccc1547be3a5d1834f6 inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="afea8c7bf4fd19ccc1547be3a5d1834f6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#afea8c7bf4fd19ccc1547be3a5d1834f6">reserve</a> (size_t <a class="el" href="a02887.html#a76fb453800c9ac164bef864782733403">size</a>)</td></tr>
<tr class="memdesc:afea8c7bf4fd19ccc1547be3a5d1834f6 inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve space for the specified number of factors if you know in advance how many there will be (works like FastVector::reserve). <br /></td></tr>
<tr class="separator:afea8c7bf4fd19ccc1547be3a5d1834f6 inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28fcfc8fcc5ac3068af271a821e31621 inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="a28fcfc8fcc5ac3068af271a821e31621"></a>
std::enable_if&lt; std::is_base_of&lt; <a class="el" href="a02887.html#aa54fb0b66fd8fee9f3c1f2844cf3edef">FactorType</a>, DERIVEDFACTOR &gt;::value &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#a28fcfc8fcc5ac3068af271a821e31621">push_back</a> (boost::shared_ptr&lt; DERIVEDFACTOR &gt; factor)</td></tr>
<tr class="memdesc:a28fcfc8fcc5ac3068af271a821e31621 inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a factor directly using a shared_ptr. <br /></td></tr>
<tr class="separator:a28fcfc8fcc5ac3068af271a821e31621 inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa4b43fb9b7111b478d3a96a3aa0e20 inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="aeaa4b43fb9b7111b478d3a96a3aa0e20"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#aeaa4b43fb9b7111b478d3a96a3aa0e20">push_back</a> (const <a class="el" href="a02887.html#ac9bfc88025d21ff01b7e9dc609ba0b0e">sharedFactor</a> &amp;factor)</td></tr>
<tr class="memdesc:aeaa4b43fb9b7111b478d3a96a3aa0e20 inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a factor directly using a shared_ptr. <br /></td></tr>
<tr class="separator:aeaa4b43fb9b7111b478d3a96a3aa0e20 inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1158e556a9a5efa64a05667bfcf038b inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="af1158e556a9a5efa64a05667bfcf038b"></a>
std::enable_if&lt; std::is_base_of&lt; <a class="el" href="a02887.html#aa54fb0b66fd8fee9f3c1f2844cf3edef">FactorType</a>, typename ITERATOR::value_type::element_type &gt;::value &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#af1158e556a9a5efa64a05667bfcf038b">push_back</a> (ITERATOR firstFactor, ITERATOR lastFactor)</td></tr>
<tr class="memdesc:af1158e556a9a5efa64a05667bfcf038b inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">push back many factors with an iterator over shared_ptr (factors are not copied) <br /></td></tr>
<tr class="separator:af1158e556a9a5efa64a05667bfcf038b inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b539f79df46e9f5a07b179fc632fd67 inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="a2b539f79df46e9f5a07b179fc632fd67"></a>
std::enable_if&lt; std::is_base_of&lt; <a class="el" href="a02887.html#aa54fb0b66fd8fee9f3c1f2844cf3edef">FactorType</a>, typename CONTAINER::value_type::element_type &gt;::value &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#a2b539f79df46e9f5a07b179fc632fd67">push_back</a> (const CONTAINER &amp;container)</td></tr>
<tr class="memdesc:a2b539f79df46e9f5a07b179fc632fd67 inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">push back many factors as shared_ptr's in a container (factors are not copied) <br /></td></tr>
<tr class="separator:a2b539f79df46e9f5a07b179fc632fd67 inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b06bb023c4e23edc3cff4a3fc6a2906 inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="a02887.html">This</a>, typename CLIQUE::FactorGraphType &gt;::value &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#a7b06bb023c4e23edc3cff4a3fc6a2906">push_back</a> (const <a class="el" href="a02903.html">BayesTree</a>&lt; CLIQUE &gt; &amp;bayesTree)</td></tr>
<tr class="memdesc:a7b06bb023c4e23edc3cff4a3fc6a2906 inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">push back a BayesTree as a collection of factors.  <a href="a02887.html#a7b06bb023c4e23edc3cff4a3fc6a2906">More...</a><br /></td></tr>
<tr class="separator:a7b06bb023c4e23edc3cff4a3fc6a2906 inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c15ab7a1b0e1a05a80f6ec527eee84 inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="a02887.html#aa54fb0b66fd8fee9f3c1f2844cf3edef">FactorType</a>, DERIVEDFACTOR &gt;::value &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#af2c15ab7a1b0e1a05a80f6ec527eee84">push_back</a> (const DERIVEDFACTOR &amp;factor)</td></tr>
<tr class="memdesc:af2c15ab7a1b0e1a05a80f6ec527eee84 inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a factor by value, will be copy-constructed (use push_back with a shared_ptr to avoid the copy).  <a href="a02887.html#af2c15ab7a1b0e1a05a80f6ec527eee84">More...</a><br /></td></tr>
<tr class="separator:af2c15ab7a1b0e1a05a80f6ec527eee84 inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0873f24893a29e260ef5199df3cbd7 inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="a7b0873f24893a29e260ef5199df3cbd7"></a>
std::enable_if&lt; std::is_base_of&lt; <a class="el" href="a02887.html#aa54fb0b66fd8fee9f3c1f2844cf3edef">FactorType</a>, typename ITERATOR::value_type &gt;::value &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#a7b0873f24893a29e260ef5199df3cbd7">push_back</a> (ITERATOR firstFactor, ITERATOR lastFactor)</td></tr>
<tr class="memdesc:a7b0873f24893a29e260ef5199df3cbd7 inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">push back many factors with an iterator over plain factors (factors are copied) <br /></td></tr>
<tr class="separator:a7b0873f24893a29e260ef5199df3cbd7 inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171b2e48cdc4c59479c6c5311118e454 inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="a171b2e48cdc4c59479c6c5311118e454"></a>
std::enable_if&lt; std::is_base_of&lt; <a class="el" href="a02887.html#aa54fb0b66fd8fee9f3c1f2844cf3edef">FactorType</a>, typename CONTAINER::value_type &gt;::value &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#a171b2e48cdc4c59479c6c5311118e454">push_back</a> (const CONTAINER &amp;container)</td></tr>
<tr class="memdesc:a171b2e48cdc4c59479c6c5311118e454 inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">push back many factors as non-pointer objects in a container (factors are copied) <br /></td></tr>
<tr class="separator:a171b2e48cdc4c59479c6c5311118e454 inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e64fe7be32c2602bb509d18d2bfd491 inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="a8e64fe7be32c2602bb509d18d2bfd491"></a>
std::enable_if&lt; std::is_base_of&lt; <a class="el" href="a02887.html#aa54fb0b66fd8fee9f3c1f2844cf3edef">FactorType</a>, DERIVEDFACTOR &gt;::value &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#a8e64fe7be32c2602bb509d18d2bfd491">emplace_shared</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a8e64fe7be32c2602bb509d18d2bfd491 inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplace a factor. <br /></td></tr>
<tr class="separator:a8e64fe7be32c2602bb509d18d2bfd491 inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff46073025c2e79624602d7a0a5a3183 inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="aff46073025c2e79624602d7a0a5a3183"></a>
std::enable_if&lt; std::is_base_of&lt; <a class="el" href="a02887.html#aa54fb0b66fd8fee9f3c1f2844cf3edef">FactorType</a>, DERIVEDFACTOR &gt;::value, boost::assign::list_inserter&lt; <a class="el" href="a02959.html">RefCallPushBack</a>&lt; <a class="el" href="a02887.html">This</a> &gt; &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#aff46073025c2e79624602d7a0a5a3183">operator+=</a> (boost::shared_ptr&lt; DERIVEDFACTOR &gt; factor)</td></tr>
<tr class="memdesc:aff46073025c2e79624602d7a0a5a3183 inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a factor directly using a shared_ptr. <br /></td></tr>
<tr class="separator:aff46073025c2e79624602d7a0a5a3183 inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0584d686cc8431728029c920a2ab08b2 inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="a0584d686cc8431728029c920a2ab08b2"></a>
boost::assign::list_inserter&lt; <a class="el" href="a02955.html">CRefCallPushBack</a>&lt; <a class="el" href="a02887.html">This</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#a0584d686cc8431728029c920a2ab08b2">operator+=</a> (const <a class="el" href="a02887.html#ac9bfc88025d21ff01b7e9dc609ba0b0e">sharedFactor</a> &amp;factor)</td></tr>
<tr class="memdesc:a0584d686cc8431728029c920a2ab08b2 inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a factor directly using a shared_ptr. <br /></td></tr>
<tr class="separator:a0584d686cc8431728029c920a2ab08b2 inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97f5c19a7ae3f09a60ecb7a05ad2ff3 inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top">boost::assign::list_inserter&lt; <a class="el" href="a02955.html">CRefCallPushBack</a>&lt; <a class="el" href="a02887.html">This</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#af97f5c19a7ae3f09a60ecb7a05ad2ff3">operator+=</a> (const FACTOR_OR_CONTAINER &amp;factorOrContainer)</td></tr>
<tr class="memdesc:af97f5c19a7ae3f09a60ecb7a05ad2ff3 inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a factor or container of factors, including STL collections, BayesTrees, etc.  <a href="a02887.html#af97f5c19a7ae3f09a60ecb7a05ad2ff3">More...</a><br /></td></tr>
<tr class="separator:af97f5c19a7ae3f09a60ecb7a05ad2ff3 inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7cc4c74b62998b22c95cb525bda0547 inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="af7cc4c74b62998b22c95cb525bda0547"></a>
std::enable_if&lt; std::is_base_of&lt; <a class="el" href="a02887.html#aa54fb0b66fd8fee9f3c1f2844cf3edef">FactorType</a>, DERIVEDFACTOR &gt;::value &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#af7cc4c74b62998b22c95cb525bda0547">add</a> (boost::shared_ptr&lt; DERIVEDFACTOR &gt; factor)</td></tr>
<tr class="memdesc:af7cc4c74b62998b22c95cb525bda0547 inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a factor directly using a shared_ptr. <br /></td></tr>
<tr class="separator:af7cc4c74b62998b22c95cb525bda0547 inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc0c118e19c269d8e2951183d1c493e inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="a9bc0c118e19c269d8e2951183d1c493e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#a9bc0c118e19c269d8e2951183d1c493e">add</a> (const <a class="el" href="a02887.html#ac9bfc88025d21ff01b7e9dc609ba0b0e">sharedFactor</a> &amp;factor)</td></tr>
<tr class="memdesc:a9bc0c118e19c269d8e2951183d1c493e inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a factor directly using a shared_ptr. <br /></td></tr>
<tr class="separator:a9bc0c118e19c269d8e2951183d1c493e inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243182115ecfb081a1605fea939f86f4 inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#a243182115ecfb081a1605fea939f86f4">add</a> (const FACTOR_OR_CONTAINER &amp;factorOrContainer)</td></tr>
<tr class="memdesc:a243182115ecfb081a1605fea939f86f4 inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a factor or container of factors, including STL collections, BayesTrees, etc.  <a href="a02887.html#a243182115ecfb081a1605fea939f86f4">More...</a><br /></td></tr>
<tr class="separator:a243182115ecfb081a1605fea939f86f4 inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c9c6d855c390743bd4a4472c730687 inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="a06c9c6d855c390743bd4a4472c730687"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#a06c9c6d855c390743bd4a4472c730687">print</a> (const std::string &amp;s=&quot;FactorGraph&quot;, const <a class="el" href="a01405.html#a29dee574fe60f586d71b2c0d957dc8bb">KeyFormatter</a> &amp;formatter=DefaultKeyFormatter) const</td></tr>
<tr class="memdesc:a06c9c6d855c390743bd4a4472c730687 inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">print out graph <br /></td></tr>
<tr class="separator:a06c9c6d855c390743bd4a4472c730687 inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdf24691d25e1e93ca6b924465b7a35 inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#aacdf24691d25e1e93ca6b924465b7a35">equals</a> (const <a class="el" href="a02887.html">This</a> &amp;fg, double tol=1e-9) const</td></tr>
<tr class="memdesc:aacdf24691d25e1e93ca6b924465b7a35 inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check equality.  <a href="a02887.html#aacdf24691d25e1e93ca6b924465b7a35">More...</a><br /></td></tr>
<tr class="separator:aacdf24691d25e1e93ca6b924465b7a35 inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fb453800c9ac164bef864782733403 inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#a76fb453800c9ac164bef864782733403">size</a> () const</td></tr>
<tr class="memdesc:a76fb453800c9ac164bef864782733403 inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of factors (including any null factors set by <a class="el" href="a02887.html#a38468469269d7b6530cf4d32b4e462d1" title="delete factor without re-arranging indexes by inserting a NULL pointer">remove()</a> ).  <a href="a02887.html#a76fb453800c9ac164bef864782733403">More...</a><br /></td></tr>
<tr class="separator:a76fb453800c9ac164bef864782733403 inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed8834089b31ef96888643af4731a8a inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#a0ed8834089b31ef96888643af4731a8a">empty</a> () const</td></tr>
<tr class="memdesc:a0ed8834089b31ef96888643af4731a8a inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the graph is empty (null factors set by <a class="el" href="a02887.html#a38468469269d7b6530cf4d32b4e462d1" title="delete factor without re-arranging indexes by inserting a NULL pointer">remove()</a> will cause this to return false).  <a href="a02887.html#a0ed8834089b31ef96888643af4731a8a">More...</a><br /></td></tr>
<tr class="separator:a0ed8834089b31ef96888643af4731a8a inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec104a9847783a29065fd4d24f072b7a inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="aec104a9847783a29065fd4d24f072b7a"></a>
const <a class="el" href="a02887.html#ac9bfc88025d21ff01b7e9dc609ba0b0e">sharedFactor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#aec104a9847783a29065fd4d24f072b7a">at</a> (size_t i) const</td></tr>
<tr class="memdesc:aec104a9847783a29065fd4d24f072b7a inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific factor by index (this checks array bounds and may throw an exception, as opposed to operator[] which does not). <br /></td></tr>
<tr class="separator:aec104a9847783a29065fd4d24f072b7a inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643fa29b7e95aab4c80169729492efd1 inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="a643fa29b7e95aab4c80169729492efd1"></a>
<a class="el" href="a02887.html#ac9bfc88025d21ff01b7e9dc609ba0b0e">sharedFactor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#a643fa29b7e95aab4c80169729492efd1">at</a> (size_t i)</td></tr>
<tr class="memdesc:a643fa29b7e95aab4c80169729492efd1 inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific factor by index (this checks array bounds and may throw an exception, as opposed to operator[] which does not). <br /></td></tr>
<tr class="separator:a643fa29b7e95aab4c80169729492efd1 inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00637b3f124aec8b4047faea5b5647b inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="ad00637b3f124aec8b4047faea5b5647b"></a>
const <a class="el" href="a02887.html#ac9bfc88025d21ff01b7e9dc609ba0b0e">sharedFactor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#ad00637b3f124aec8b4047faea5b5647b">operator[]</a> (size_t i) const</td></tr>
<tr class="memdesc:ad00637b3f124aec8b4047faea5b5647b inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific factor by index (this does not check array bounds, as opposed to <a class="el" href="a02887.html#aec104a9847783a29065fd4d24f072b7a" title="Get a specific factor by index (this checks array bounds and may throw an exception,...">at()</a> which does). <br /></td></tr>
<tr class="separator:ad00637b3f124aec8b4047faea5b5647b inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc88a56126d4715cc8a7de9ff3c34af inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="abcc88a56126d4715cc8a7de9ff3c34af"></a>
<a class="el" href="a02887.html#ac9bfc88025d21ff01b7e9dc609ba0b0e">sharedFactor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#abcc88a56126d4715cc8a7de9ff3c34af">operator[]</a> (size_t i)</td></tr>
<tr class="memdesc:abcc88a56126d4715cc8a7de9ff3c34af inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific factor by index (this does not check array bounds, as opposed to <a class="el" href="a02887.html#aec104a9847783a29065fd4d24f072b7a" title="Get a specific factor by index (this checks array bounds and may throw an exception,...">at()</a> which does). <br /></td></tr>
<tr class="separator:abcc88a56126d4715cc8a7de9ff3c34af inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcaeffeae20930806f064f8413689c22 inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#abcaeffeae20930806f064f8413689c22">begin</a> () const</td></tr>
<tr class="memdesc:abcaeffeae20930806f064f8413689c22 inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to beginning of factors.  <a href="a02887.html#abcaeffeae20930806f064f8413689c22">More...</a><br /></td></tr>
<tr class="separator:abcaeffeae20930806f064f8413689c22 inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a257708f3530799e24d21f3125e181 inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#a94a257708f3530799e24d21f3125e181">end</a> () const</td></tr>
<tr class="memdesc:a94a257708f3530799e24d21f3125e181 inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to end of factors.  <a href="a02887.html#a94a257708f3530799e24d21f3125e181">More...</a><br /></td></tr>
<tr class="separator:a94a257708f3530799e24d21f3125e181 inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aad182ded37c5add184e0113ec9ede9 inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="a8aad182ded37c5add184e0113ec9ede9"></a>
<a class="el" href="a02887.html#ac9bfc88025d21ff01b7e9dc609ba0b0e">sharedFactor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#a8aad182ded37c5add184e0113ec9ede9">front</a> () const</td></tr>
<tr class="memdesc:a8aad182ded37c5add184e0113ec9ede9 inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first factor. <br /></td></tr>
<tr class="separator:a8aad182ded37c5add184e0113ec9ede9 inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37859ce7d210d593be80f625eceba620 inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="a37859ce7d210d593be80f625eceba620"></a>
<a class="el" href="a02887.html#ac9bfc88025d21ff01b7e9dc609ba0b0e">sharedFactor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#a37859ce7d210d593be80f625eceba620">back</a> () const</td></tr>
<tr class="memdesc:a37859ce7d210d593be80f625eceba620 inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last factor. <br /></td></tr>
<tr class="separator:a37859ce7d210d593be80f625eceba620 inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf0875f55936063d96c507de9e9255a inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="abaf0875f55936063d96c507de9e9255a"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#abaf0875f55936063d96c507de9e9255a">begin</a> ()</td></tr>
<tr class="memdesc:abaf0875f55936063d96c507de9e9255a inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">non-const STL-style <a class="el" href="a02887.html#abaf0875f55936063d96c507de9e9255a" title="non-const STL-style begin()">begin()</a> <br /></td></tr>
<tr class="separator:abaf0875f55936063d96c507de9e9255a inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e1c6a2b56c2158afb28a58ab560e44 inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="ad6e1c6a2b56c2158afb28a58ab560e44"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#ad6e1c6a2b56c2158afb28a58ab560e44">end</a> ()</td></tr>
<tr class="memdesc:ad6e1c6a2b56c2158afb28a58ab560e44 inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">non-const STL-style <a class="el" href="a02887.html#ad6e1c6a2b56c2158afb28a58ab560e44" title="non-const STL-style end()">end()</a> <br /></td></tr>
<tr class="separator:ad6e1c6a2b56c2158afb28a58ab560e44 inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231dd81b4751a9bccc3c89f35f76961e inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#a231dd81b4751a9bccc3c89f35f76961e">resize</a> (size_t <a class="el" href="a02887.html#a76fb453800c9ac164bef864782733403">size</a>)</td></tr>
<tr class="memdesc:a231dd81b4751a9bccc3c89f35f76961e inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly resize the number of factors in the graph.  <a href="a02887.html#a231dd81b4751a9bccc3c89f35f76961e">More...</a><br /></td></tr>
<tr class="separator:a231dd81b4751a9bccc3c89f35f76961e inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38468469269d7b6530cf4d32b4e462d1 inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="a38468469269d7b6530cf4d32b4e462d1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#a38468469269d7b6530cf4d32b4e462d1">remove</a> (size_t i)</td></tr>
<tr class="memdesc:a38468469269d7b6530cf4d32b4e462d1 inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">delete factor without re-arranging indexes by inserting a NULL pointer <br /></td></tr>
<tr class="separator:a38468469269d7b6530cf4d32b4e462d1 inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa706ee0e285f6c1a38e6a4446fe9ea4e inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="aa706ee0e285f6c1a38e6a4446fe9ea4e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#aa706ee0e285f6c1a38e6a4446fe9ea4e">replace</a> (size_t index, <a class="el" href="a02887.html#ac9bfc88025d21ff01b7e9dc609ba0b0e">sharedFactor</a> factor)</td></tr>
<tr class="memdesc:aa706ee0e285f6c1a38e6a4446fe9ea4e inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">replace a factor by index <br /></td></tr>
<tr class="separator:aa706ee0e285f6c1a38e6a4446fe9ea4e inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f324974f6e3380c54d1d69c71bc7fb inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="a22f324974f6e3380c54d1d69c71bc7fb"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#a22f324974f6e3380c54d1d69c71bc7fb">erase</a> (iterator item)</td></tr>
<tr class="memdesc:a22f324974f6e3380c54d1d69c71bc7fb inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase factor and rearrange other factors to take up the empty space. <br /></td></tr>
<tr class="separator:a22f324974f6e3380c54d1d69c71bc7fb inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2825a68630a0547e1bfd5ba0cdf1de61 inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="a2825a68630a0547e1bfd5ba0cdf1de61"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#a2825a68630a0547e1bfd5ba0cdf1de61">erase</a> (iterator first, iterator last)</td></tr>
<tr class="memdesc:a2825a68630a0547e1bfd5ba0cdf1de61 inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase factors and rearrange other factors to take up the empty space. <br /></td></tr>
<tr class="separator:a2825a68630a0547e1bfd5ba0cdf1de61 inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761f1022dadf60e2cacca304ab0533b4 inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="a761f1022dadf60e2cacca304ab0533b4"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#a761f1022dadf60e2cacca304ab0533b4">nrFactors</a> () const</td></tr>
<tr class="memdesc:a761f1022dadf60e2cacca304ab0533b4 inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of non-null factors <br /></td></tr>
<tr class="separator:a761f1022dadf60e2cacca304ab0533b4 inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4667de76265a06cc6f74b1f3b25051 inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="a0c4667de76265a06cc6f74b1f3b25051"></a>
<a class="el" href="a02031.html">KeySet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#a0c4667de76265a06cc6f74b1f3b25051">keys</a> () const</td></tr>
<tr class="memdesc:a0c4667de76265a06cc6f74b1f3b25051 inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Potentially slow function to return all keys involved, sorted, as a set. <br /></td></tr>
<tr class="separator:a0c4667de76265a06cc6f74b1f3b25051 inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4d9bbaceeb9043ab7c20d4778b69c5 inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="a3b4d9bbaceeb9043ab7c20d4778b69c5"></a>
<a class="el" href="a01405.html#a18932dfd5dba41c0574e6db16cdb5932">KeyVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#a3b4d9bbaceeb9043ab7c20d4778b69c5">keyVector</a> () const</td></tr>
<tr class="memdesc:a3b4d9bbaceeb9043ab7c20d4778b69c5 inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Potentially slow function to return all keys involved, sorted, as a vector. <br /></td></tr>
<tr class="separator:a3b4d9bbaceeb9043ab7c20d4778b69c5 inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf8cdf50816d4a0571f6b9b6254f9ce inherit pub_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="acbf8cdf50816d4a0571f6b9b6254f9ce"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#acbf8cdf50816d4a0571f6b9b6254f9ce">exists</a> (size_t idx) const</td></tr>
<tr class="memdesc:acbf8cdf50816d4a0571f6b9b6254f9ce inherit pub_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">MATLAB interface utility: Checks whether a factor index idx exists in the graph and is a live pointer. <br /></td></tr>
<tr class="separator:acbf8cdf50816d4a0571f6b9b6254f9ce inherit pub_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afe5ce29ad821fa0bc7578d8421101760"><td class="memItemLeft" align="right" valign="top"><a id="afe5ce29ad821fa0bc7578d8421101760"></a>
typedef <a class="el" href="a02887.html">FactorGraph</a>&lt; <a class="el" href="a03107.html">GaussianConditional</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Base</b></td></tr>
<tr class="separator:afe5ce29ad821fa0bc7578d8421101760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ebb8e84fb248945912cf330d0189d0f"><td class="memItemLeft" align="right" valign="top"><a id="a6ebb8e84fb248945912cf330d0189d0f"></a>
typedef <a class="el" href="a03087.html">GaussianBayesNet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>This</b></td></tr>
<tr class="separator:a6ebb8e84fb248945912cf330d0189d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90db281f8f507f635a79042fb72402f"><td class="memItemLeft" align="right" valign="top"><a id="ab90db281f8f507f635a79042fb72402f"></a>
typedef <a class="el" href="a03107.html">GaussianConditional</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ConditionalType</b></td></tr>
<tr class="separator:ab90db281f8f507f635a79042fb72402f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20add1fbc445bdad679ded6e9cccbf60"><td class="memItemLeft" align="right" valign="top"><a id="a20add1fbc445bdad679ded6e9cccbf60"></a>
typedef boost::shared_ptr&lt; <a class="el" href="a03087.html">This</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>shared_ptr</b></td></tr>
<tr class="separator:a20add1fbc445bdad679ded6e9cccbf60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afedc9c3ac42cc1462b6f025e4a363563"><td class="memItemLeft" align="right" valign="top"><a id="afedc9c3ac42cc1462b6f025e4a363563"></a>
typedef boost::shared_ptr&lt; <a class="el" href="a03107.html">ConditionalType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>sharedConditional</b></td></tr>
<tr class="separator:afedc9c3ac42cc1462b6f025e4a363563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_a02887"><td colspan="2" onclick="javascript:toggleInherit('pub_types_a02887')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="a02887.html">gtsam::FactorGraph&lt; GaussianConditional &gt;</a></td></tr>
<tr class="memitem:aa54fb0b66fd8fee9f3c1f2844cf3edef inherit pub_types_a02887"><td class="memItemLeft" align="right" valign="top"><a id="aa54fb0b66fd8fee9f3c1f2844cf3edef"></a>
typedef <a class="el" href="a03107.html">GaussianConditional</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#aa54fb0b66fd8fee9f3c1f2844cf3edef">FactorType</a></td></tr>
<tr class="memdesc:aa54fb0b66fd8fee9f3c1f2844cf3edef inherit pub_types_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">factor type <br /></td></tr>
<tr class="separator:aa54fb0b66fd8fee9f3c1f2844cf3edef inherit pub_types_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9bfc88025d21ff01b7e9dc609ba0b0e inherit pub_types_a02887"><td class="memItemLeft" align="right" valign="top"><a id="ac9bfc88025d21ff01b7e9dc609ba0b0e"></a>
typedef boost::shared_ptr&lt; <a class="el" href="a03107.html">GaussianConditional</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#ac9bfc88025d21ff01b7e9dc609ba0b0e">sharedFactor</a></td></tr>
<tr class="memdesc:ac9bfc88025d21ff01b7e9dc609ba0b0e inherit pub_types_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer to a factor. <br /></td></tr>
<tr class="separator:ac9bfc88025d21ff01b7e9dc609ba0b0e inherit pub_types_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8705eefb16a49d12dbba659499bc82 inherit pub_types_a02887"><td class="memItemLeft" align="right" valign="top"><a id="a9e8705eefb16a49d12dbba659499bc82"></a>
typedef <a class="el" href="a02887.html#ac9bfc88025d21ff01b7e9dc609ba0b0e">sharedFactor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:a9e8705eefb16a49d12dbba659499bc82 inherit pub_types_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71ec41fd2c991605eb54954976a6939 inherit pub_types_a02887"><td class="memItemLeft" align="right" valign="top"><a id="af71ec41fd2c991605eb54954976a6939"></a>
typedef FastVector&lt; <a class="el" href="a02887.html#ac9bfc88025d21ff01b7e9dc609ba0b0e">sharedFactor</a> &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:af71ec41fd2c991605eb54954976a6939 inherit pub_types_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec93913bd747baea0c7316598ac3e8e9 inherit pub_types_a02887"><td class="memItemLeft" align="right" valign="top"><a id="aec93913bd747baea0c7316598ac3e8e9"></a>
typedef FastVector&lt; <a class="el" href="a02887.html#ac9bfc88025d21ff01b7e9dc609ba0b0e">sharedFactor</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:aec93913bd747baea0c7316598ac3e8e9 inherit pub_types_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac98d07dd8f7b70e16ccb9a01abf56b9c"><td class="memItemLeft" align="right" valign="top"><a id="ac98d07dd8f7b70e16ccb9a01abf56b9c"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03087.html#ac98d07dd8f7b70e16ccb9a01abf56b9c">boost::serialization::access</a></td></tr>
<tr class="memdesc:ac98d07dd8f7b70e16ccb9a01abf56b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization function. <br /></td></tr>
<tr class="separator:ac98d07dd8f7b70e16ccb9a01abf56b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_a02887"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_a02887')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="a02887.html">gtsam::FactorGraph&lt; GaussianConditional &gt;</a></td></tr>
<tr class="memitem:a42db0a1062eb6c223b0a186a9d34cb4b inherit pro_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="a42db0a1062eb6c223b0a186a9d34cb4b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#a42db0a1062eb6c223b0a186a9d34cb4b">FactorGraph</a> ()</td></tr>
<tr class="memdesc:a42db0a1062eb6c223b0a186a9d34cb4b inherit pro_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a42db0a1062eb6c223b0a186a9d34cb4b inherit pro_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a80ba5a22fee5725d0efa75080cdfb inherit pro_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="a63a80ba5a22fee5725d0efa75080cdfb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#a63a80ba5a22fee5725d0efa75080cdfb">FactorGraph</a> (ITERATOR firstFactor, ITERATOR lastFactor)</td></tr>
<tr class="memdesc:a63a80ba5a22fee5725d0efa75080cdfb inherit pro_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from iterator over factors (shared_ptr or plain objects) <br /></td></tr>
<tr class="separator:a63a80ba5a22fee5725d0efa75080cdfb inherit pro_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b5e74d2c3711906f57982b4512351f inherit pro_methods_a02887"><td class="memItemLeft" align="right" valign="top"><a id="a37b5e74d2c3711906f57982b4512351f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#a37b5e74d2c3711906f57982b4512351f">FactorGraph</a> (const CONTAINER &amp;factors)</td></tr>
<tr class="memdesc:a37b5e74d2c3711906f57982b4512351f inherit pro_methods_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from container of factors (shared_ptr or plain objects) <br /></td></tr>
<tr class="separator:a37b5e74d2c3711906f57982b4512351f inherit pro_methods_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_a02887"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_a02887')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="a02887.html">gtsam::FactorGraph&lt; GaussianConditional &gt;</a></td></tr>
<tr class="memitem:ae0c75f68e3ebc37cc4511285b12c33fc inherit pro_attribs_a02887"><td class="memItemLeft" align="right" valign="top">FastVector&lt; <a class="el" href="a02887.html#ac9bfc88025d21ff01b7e9dc609ba0b0e">sharedFactor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html#ae0c75f68e3ebc37cc4511285b12c33fc">factors_</a></td></tr>
<tr class="memdesc:ae0c75f68e3ebc37cc4511285b12c33fc inherit pro_attribs_a02887"><td class="mdescLeft">&#160;</td><td class="mdescRight">concept check, makes sure FACTOR defines print and equals  <a href="a02887.html#ae0c75f68e3ebc37cc4511285b12c33fc">More...</a><br /></td></tr>
<tr class="separator:ae0c75f68e3ebc37cc4511285b12c33fc inherit pro_attribs_a02887"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae94dd75d08bf33718cfc2fd05abbdd17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94dd75d08bf33718cfc2fd05abbdd17">&#9670;&nbsp;</a></span>backSubstitute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a03399.html">VectorValues</a> gtsam::GaussianBayesNet::backSubstitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a03399.html">VectorValues</a> &amp;&#160;</td>
          <td class="paramname"><em>gx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Backsubstitute with a different RHS vector than the one stored in this <a class="el" href="a02879.html" title="A BayesNet is a tree of conditionals, stored in elimination order.">BayesNet</a>. </p>
<p>gy=inv(R*inv(Sigma))*gx </p>

</div>
</div>
<a id="aa082daa02b066634ea1b624263ce1819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa082daa02b066634ea1b624263ce1819">&#9670;&nbsp;</a></span>backSubstituteTranspose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a03399.html">VectorValues</a> gtsam::GaussianBayesNet::backSubstituteTranspose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a03399.html">VectorValues</a> &amp;&#160;</td>
          <td class="paramname"><em>gx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transpose backsubstitute with a different RHS vector than the one stored in this <a class="el" href="a02879.html" title="A BayesNet is a tree of conditionals, stored in elimination order.">BayesNet</a>. </p>
<p>gy=inv(L)*gx by solving L*gy=gx. gy=inv(R'*inv(Sigma))*gx gz'*R'=gx', gy = gz.*sigmas </p>

</div>
</div>
<a id="aff1f3b8337a4768252aaa17337749e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff1f3b8337a4768252aaa17337749e2d">&#9670;&nbsp;</a></span>determinant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double gtsam::GaussianBayesNet::determinant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the determinant of a GassianBayesNet. </p>
<p>A <a class="el" href="a03087.html" title="A Bayes net made from linear-Gaussian densities.">GaussianBayesNet</a> is an upper triangular matrix and for an upper triangular matrix determinant is the product of the diagonal elements. Instead of actually multiplying we add the logarithms of the diagonal elements and take the exponent at the end because this is more numerically stable. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bayesNet</td><td>The input <a class="el" href="a03087.html" title="A Bayes net made from linear-Gaussian densities.">GaussianBayesNet</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The determinant</dd></dl>
<ul>
<li>************************************************************************* */* ************************************************************************* */ </li>
</ul>

</div>
</div>
<a id="a3db1291c789e604f170c756df896d80c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db1291c789e604f170c756df896d80c">&#9670;&nbsp;</a></span>error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double gtsam::GaussianBayesNet::error </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a03399.html">VectorValues</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mahalanobis norm error. </p>

</div>
</div>
<a id="afeb5efde40fe64df5844ba1154933128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeb5efde40fe64df5844ba1154933128">&#9670;&nbsp;</a></span>gradient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a03399.html">VectorValues</a> gtsam::GaussianBayesNet::gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a03399.html">VectorValues</a> &amp;&#160;</td>
          <td class="paramname"><em>x0</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the gradient of the energy function, \( \nabla_{x=x_0} \left\Vert \Sigma^{-1} R x - d \right\Vert^2 \), centered around \( x = x_0 \). </p>
<p>The gradient is \( R^T(Rx-d) \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x0</td><td>The center about which to compute the gradient </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The gradient as a <a class="el" href="a03399.html" title="This class represents a collection of vector-valued variables associated each with a unique integer i...">VectorValues</a> </dd></dl>

</div>
</div>
<a id="a882e37f9122d59c5f9f7ab927398cb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a882e37f9122d59c5f9f7ab927398cb24">&#9670;&nbsp;</a></span>gradientAtZero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a03399.html">VectorValues</a> gtsam::GaussianBayesNet::gradientAtZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the gradient of the energy function, \( \nabla_{x=0} \left\Vert \Sigma^{-1} R x - d \right\Vert^2 \), centered around zero. </p>
<p>The gradient about zero is \( -R^T d \). See also gradient(const GaussianBayesNet&amp;, const VectorValues&amp;).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">[output]</td><td>g A <a class="el" href="a03399.html" title="This class represents a collection of vector-valued variables associated each with a unique integer i...">VectorValues</a> to store the gradient, which must be preallocated, see allocateVectorValues </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab658420b5501d66d8df2d3fd5e78133b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab658420b5501d66d8df2d3fd5e78133b">&#9670;&nbsp;</a></span>logDeterminant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double gtsam::GaussianBayesNet::logDeterminant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the log of the determinant of a GassianBayesNet. </p>
<p>A <a class="el" href="a03087.html" title="A Bayes net made from linear-Gaussian densities.">GaussianBayesNet</a> is an upper triangular matrix and for an upper triangular matrix determinant is the product of the diagonal elements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bayesNet</td><td>The input <a class="el" href="a03087.html" title="A Bayes net made from linear-Gaussian densities.">GaussianBayesNet</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The determinant </dd></dl>

</div>
</div>
<a id="ab457a514b691290a40eb4ef1d264975f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab457a514b691290a40eb4ef1d264975f">&#9670;&nbsp;</a></span>matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; Matrix, Vector &gt; gtsam::GaussianBayesNet::matrix </td>
          <td>(</td>
          <td class="paramtype">boost::optional&lt; const <a class="el" href="a03031.html">Ordering</a> &amp; &gt;&#160;</td>
          <td class="paramname"><em>ordering</em> = <code>boost::none</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return (dense) upper-triangular matrix representation Will return upper-triangular matrix only when using 'ordering' above. </p>
<p>In case Bayes net is incomplete zero columns are added to the end. </p>

</div>
</div>
<a id="ab5b987183cf89eef5973b7c3352e9662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b987183cf89eef5973b7c3352e9662">&#9670;&nbsp;</a></span>optimize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a03399.html">VectorValues</a> gtsam::GaussianBayesNet::optimize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a03399.html">VectorValues</a> &amp;&#160;</td>
          <td class="paramname"><em>solutionForMissing</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Version of optimize for incomplete <a class="el" href="a02879.html" title="A BayesNet is a tree of conditionals, stored in elimination order.">BayesNet</a>, needs solution for missing variables. </p>
<p>solve each node in turn in topological sort order (parents first) </p>

</div>
</div>
<a id="ac73cf84092ee57fa01609ae699b9282a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac73cf84092ee57fa01609ae699b9282a">&#9670;&nbsp;</a></span>optimizeGradientSearch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a03399.html">VectorValues</a> gtsam::GaussianBayesNet::optimizeGradientSearch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimize along the gradient direction, with a closed-form computation to perform the line search. </p>
<p>The gradient is computed about \( \delta x=0 \).</p>
<p>This function returns \( \delta x \) that minimizes a reparametrized problem. The error function of a <a class="el" href="a03087.html" title="A Bayes net made from linear-Gaussian densities.">GaussianBayesNet</a> is</p>
<p class="formulaDsp">
\[ f(\delta x) = \frac{1}{2} |R \delta x - d|^2 = \frac{1}{2}d^T d - d^T R \delta x + \frac{1}{2} \delta x^T R^T R \delta x \]
</p>
<p>with gradient and Hessian</p>
<p class="formulaDsp">
\[ g(\delta x) = R^T(R\delta x - d), \qquad G(\delta x) = R^T R. \]
</p>
<p>This function performs the line search in the direction of the gradient evaluated at \( g = g(\delta x = 0) \) with step size \( \alpha \) that minimizes \( f(\delta x = \alpha g) \):</p>
<p class="formulaDsp">
\[ f(\alpha) = \frac{1}{2} d^T d + g^T \delta x + \frac{1}{2} \alpha^2 g^T G g \]
</p>
<p>Optimizing by setting the derivative to zero yields \( \hat \alpha = (-g^T g) / (g^T G g) \). For efficiency, this function evaluates the denominator without computing the Hessian \( G \), returning</p>
<p class="formulaDsp">
\[ \delta x = \hat\alpha g = \frac{-g^T g}{(R g)^T(R g)} \]
</p>
 
</div>
</div>
<a id="aa4bf7623222114b8929266f89e96aeb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4bf7623222114b8929266f89e96aeb5">&#9670;&nbsp;</a></span>ordering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a03031.html">Ordering</a> gtsam::GaussianBayesNet::ordering </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return ordering corresponding to a topological sort. </p>
<p>There are many topological sorts of a Bayes net. This one corresponds to the one that makes 'matrix' below upper-triangular. In case Bayes net is incomplete any non-frontal are added to the end.</p>
<ul>
<li>************************************************************************* */ </li>
</ul>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/dellaert/git/gtsam/gtsam/linear/<a class="el" href="a00521_source.html">GaussianBayesNet.h</a></li>
<li>/Users/dellaert/git/gtsam/gtsam/linear/<a class="el" href="a00518.html">GaussianBayesNet.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a01405.html">gtsam</a></li><li class="navelem"><a class="el" href="a03087.html">GaussianBayesNet</a></li>
    <li class="footer">Generated on Sun May 19 2019 01:04:46 for gtsam by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
