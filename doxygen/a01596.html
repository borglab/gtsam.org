<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gtsam: gtsam Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">gtsam<span id="projectnumber">&#160;4.1.1</span>
   </div>
   <div id="projectbrief">gtsam</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('a01596.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">gtsam Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Global functions in a separate testing namespace.  
<a href="a01596.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:a01619"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01619.html">imuBias</a></td></tr>
<tr class="memdesc:a01619"><td class="mdescLeft">&#160;</td><td class="mdescRight">All bias models live in the <a class="el" href="a01619.html" title="All bias models live in the imuBias namespace.">imuBias</a> namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01616"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01616.html">noiseModel</a></td></tr>
<tr class="memdesc:a01616"><td class="mdescLeft">&#160;</td><td class="mdescRight">All noise models live in the <a class="el" href="a01616.html" title="All noise models live in the noiseModel namespace.">noiseModel</a> namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01602"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01602.html">treeTraversal</a></td></tr>
<tr class="memdesc:a01602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal functions used for traversing trees. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04512.html">_ValuesConstKeyValuePair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04508.html">_ValuesKeyValuePair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03668.html">AcceleratedPowerMethod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute maximum Eigenpair with accelerated power method.  <a href="a03668.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04180.html">AcceleratingScenario</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accelerating from an arbitrary initial state, with optional rotation.  <a href="a04180.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05032.html">ActiveSetSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the active set algorithm for solving convex Programming problems.  <a href="a05032.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04192.html">AdaptAutoDiff</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="a04192.html" title="The AdaptAutoDiff class uses ceres-style autodiff to adapt a ceres-style Function evaluation,...">AdaptAutoDiff</a> class uses ceres-style autodiff to adapt a ceres-style Function evaluation, i.e., a function FUNCTOR that defines an operator template&lt;typename T&gt; bool operator()(const T* const, const T* const, T*
predicted) const; For now only binary operators are supported.  <a href="a04192.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02508.html">additive_group_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05232.html">AHRS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04028.html">AHRSFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02904.html">AlgebraicDecisionTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Algebraic Decision Trees fix the range to double Just has some nice constructors and some syntactic sugar TODO: consider eliminating this class altogether?  <a href="a02904.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05000.html">AllDiff</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General <a class="el" href="a05000.html" title="General AllDiff constraint Returns 1 if values for all keys are different, 0 otherwise DiscreteFactor...">AllDiff</a> constraint Returns 1 if values for all keys are different, 0 otherwise DiscreteFactors are all awkward in that they have to store two types of keys: for each variable we have a Key and an Key.  <a href="a05000.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04680.html">AntiFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02912.html">Assignment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An assignment from labels to value index (size_t).  <a href="a02912.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04032.html">AttitudeFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02812.html">Basis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRTP Base class for function bases.  <a href="a02812.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05132.html">BatchFixedLagSmoother</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03472.html">BayesNet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="a03472.html" title="A BayesNet is a tree of conditionals, stored in elimination order.">BayesNet</a> is a tree of conditionals, stored in elimination order.  <a href="a03472.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03496.html">BayesTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03508.html">BayesTreeCliqueBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class for <a class="el" href="a03496.html">BayesTree</a> cliques.  <a href="a03508.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03492.html">BayesTreeCliqueData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">store all the sizes <br  />
  <a href="a03492.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03488.html">BayesTreeCliqueStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">clique statistics  <a href="a03488.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03500.html">BayesTreeOrphanWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03024.html">Bearing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03280.html">Bearing&lt; Pose2, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03304.html">Bearing&lt; Pose3, Point3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03308.html">Bearing&lt; Pose3, Pose3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04600.html">BearingFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03032.html">BearingRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bearing-Range product for a particular A1,A2 combination will use the functors above to create a similar functor of type A1*A2 -&gt; pair&lt;Bearing::return_type,Range::return_type&gt; For example BearingRange&lt;Pose2,Point2&gt;(pose,point) will return pair&lt;Rot2,double&gt; and BearingRange&lt;Pose3,Point3&gt;(pose,point) will return pair&lt;Unit3,double&gt;  <a href="a03032.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04608.html">BearingRangeFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04692.html">BetweenConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary between constraint - forces between to a given value This constraint requires the underlying type to a Lie type.  <a href="a04692.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04684.html">BetweenFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05236.html">BetweenFactorEM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05240.html">BiasedGPSFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05004.html">BinaryAllDiff</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary <a class="el" href="a05000.html" title="General AllDiff constraint Returns 1 if values for all keys are different, 0 otherwise DiscreteFactor...">AllDiff</a> constraint Returns 1 if values for two keys are different, 0 otherwise DiscreteFactors are all awkward in that they have to store two types of keys: for each variable we have a Index and an Index.  <a href="a05004.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03672.html">BinaryJacobianFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A binary <a class="el" href="a03796.html" title="A Gaussian factor in the squared-error form.">JacobianFactor</a> specialization that uses fixed matrix math for speed.  <a href="a03672.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04632.html">BinaryMeasurement</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04260.html">BinarySumExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="a04260.html" title="A BinarySumExpression is a specialization of Expression that adds two expressions together It optimiz...">BinarySumExpression</a> is a specialization of <a class="el" href="a04240.html" title="Expression class that supports automatic differentiation.">Expression</a> that adds two expressions together It optimizes the Jacobian calculation for this specific case.  <a href="a04260.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03956.html">BlockJacobiPreconditioner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03952.html">BlockJacobiPreconditionerParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04700.html">BoundingConstraint1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04704.html">BoundingConstraint2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary scalar inequality constraint, with a similar <a class="el" href="a04704.html#ad1415ee808cefd215e6410c6dd9f4f51" title="function producing a scalar value to compare to the threshold Must have optional argument for derivat...">value()</a> function to implement for specific systems.  <a href="a04704.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04976.html">BTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03048.html">Cal3</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03052.html">Cal3_S2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03064.html">Cal3_S2Stereo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03076.html">Cal3Bundler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03088.html">Cal3DS2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03100.html">Cal3DS2_Base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03104.html">Cal3Fisheye</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03116.html">Cal3Unified</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03136.html">CalibratedCamera</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03448.html">CameraProjectionMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 3*4 camera projection matrix from calibration and pose.  <a href="a03448.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03152.html">CameraSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of cameras, all with their own calibration.  <a href="a03152.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03772.html">CGState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02876.html">Chebyshev1Basis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a02812.html" title="CRTP Base class for function bases.">Basis</a> of Chebyshev polynomials of the first kind <a href="https://en.wikipedia.org/wiki/Chebyshev_polynomials#First_kind">https://en.wikipedia.org/wiki/Chebyshev_polynomials#First_kind</a> These are typically denoted with the symbol T_n, where n is the degree.  <a href="a02876.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02884.html">Chebyshev2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chebyshev Interpolation on Chebyshev points of the second kind Note that N here, the number of points, is one less than N from 'Approximation Theory and Approximation Practice by L.  <a href="a02884.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02880.html">Chebyshev2Basis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a02812.html" title="CRTP Base class for function bases.">Basis</a> of Chebyshev polynomials of the second kind.  <a href="a02880.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03128.html">CheiralityException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02680.html">CholeskyFailed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate Cholesky factorization failure.  <a href="a02680.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03520.html">ClusterTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cluster-tree is associated with a factor graph and is defined as in Koller-Friedman: each node k represents a subset \( C_k \sub X \), and the tree is family preserving, in that each factor \( f_i \) is associated with a single cluster and \( scope(f_i) \sub C_k \).  <a href="a03520.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04060.html">CombinedImuFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02872.html">ComponentDerivativeFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unary factor which enforces the evaluation of the derivative of a BASIS polynomial is equal to the scalar value at a specific index <code>i</code> of a vector-valued measurement <code>z</code>.  <a href="a02872.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03564.html">compose_key_visitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05136.html">ConcurrentBatchFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Levenberg-Marquardt Batch Filter that implements the Concurrent Filtering and Smoother interface.  <a href="a05136.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05148.html">ConcurrentBatchSmoother</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Levenberg-Marquardt Batch Smoother that implements the Concurrent Filtering and Smoother interface.  <a href="a05148.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05160.html">ConcurrentFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The interface for the 'Filter' portion of the Concurrent Filtering and Smoother architecture.  <a href="a05160.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05168.html">ConcurrentIncrementalFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iSAM2-based Batch Filter that implements the Concurrent Filtering and Smoother interface.  <a href="a05168.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05180.html">ConcurrentIncrementalSmoother</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Levenberg-Marquardt Batch Smoother that implements the Concurrent Filtering and Smoother interface.  <a href="a05180.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02448.html">ConcurrentMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05164.html">ConcurrentSmoother</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The interface for the 'Smoother' portion of the Concurrent Filtering and Smoother architecture.  <a href="a05164.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03528.html">Conditional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: Update comments.  <a href="a03528.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03680.html">ConjugateGradientParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">parameters for the conjugate gradient method  <a href="a03680.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02704.html">const_selector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that uses templates to select between two types based on whether TEST_TYPE is const or not.  <a href="a02704.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02708.html">const_selector&lt; BASIC_TYPE, BASIC_TYPE, AS_NON_CONST, AS_CONST &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the non-const version.  <a href="a02708.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02712.html">const_selector&lt; const BASIC_TYPE, BASIC_TYPE, AS_NON_CONST, AS_CONST &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the const version.  <a href="a02712.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04176.html">ConstantTwistScenario</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a04172.html" title="Simple trajectory simulator.">Scenario</a> with constant twist 3D trajectory.  <a href="a04176.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04076.html">ConstantVelocityFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary factor for applying a constant velocity model to a moving body represented as a <a class="el" href="a04144.html" title="Navigation state: Pose (rotation, translation) + velocity NOTE(frank): it does not make sense to make...">NavState</a>.  <a href="a04076.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05008.html">Constraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for discrete probabilistic factors The most general one is the derived <a class="el" href="a02932.html" title="A discrete probabilistic factor.">DecisionTreeFactor</a>.  <a href="a05008.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03596.html">ConstructorTraversalData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03556.html">CRefCallAddCopy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper.  <a href="a03556.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03548.html">CRefCallPushBack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper.  <a href="a03548.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05012.html">CSP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a05008.html" title="Base class for discrete probabilistic factors The most general one is the derived DecisionTreeFactor.">Constraint</a> Satisfaction Problem class A specialization of a <a class="el" href="a02984.html" title="A Discrete Factor Graph is a factor graph where all factors are Discrete, i.e.">DiscreteFactorGraph</a>.  <a href="a05012.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04196.html">CustomFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03168.html">Cyclic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a03168.html" title="Cyclic group of order N.">Cyclic</a> group of order N.  <a href="a03168.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02924.html">DecisionTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decision Tree L = label for variables Y = function range (any algebra), e.g., bool, int, double.  <a href="a02924.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02932.html">DecisionTreeFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A discrete probabilistic factor.  <a href="a02932.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05408.html">DeltaFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a05408.html" title="DeltaFactor: relative 2D measurement between Pose2 and Point2.">DeltaFactor</a>: relative 2D measurement between <a class="el" href="a03264.html">Pose2</a> and Point2.  <a href="a05408.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05412.html">DeltaFactorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a05412.html" title="DeltaFactorBase: relative 2D measurement between Pose2 and Point2, with Basenodes.">DeltaFactorBase</a>: relative 2D measurement between <a class="el" href="a03264.html">Pose2</a> and Point2, with Basenodes.  <a href="a05412.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04324.html">DeltaImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02864.html">DerivativeFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unary factor which enforces the evaluation of the derivative of a BASIS polynomial at a specified point<code>x</code> is equal to the scalar measurement <code>z</code>.  <a href="a02864.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05432.html">DGroundConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ground constraint: forces the robot to be upright (no roll, pitch), a fixed height, and no velocity in z direction Dim: 4.  <a href="a05432.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05420.html">DHeightPrior</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the value of the height (z) in a <a class="el" href="a05460.html" title="Robot state for use with IMU measurements.">PoseRTV</a> to a specific value.  <a href="a05420.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02516.html">DirectProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02524.html">DirectSum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template to construct the direct sum of two additive groups Assumes existence of three additive operators for both groups.  <a href="a02524.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02940.html">DiscreteBayesNet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Bayes net made from linear-Discrete densities.  <a href="a02940.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02952.html">DiscreteBayesTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Bayes tree representing a Discrete density.  <a href="a02952.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02948.html">DiscreteBayesTreeClique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A clique in a <a class="el" href="a02952.html" title="A Bayes tree representing a Discrete density.">DiscreteBayesTree</a>.  <a href="a02948.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02956.html">DiscreteConditional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discrete <a class="el" href="a03528.html" title="TODO: Update comments.">Conditional</a> Density Derives from <a class="el" href="a02932.html" title="A discrete probabilistic factor.">DecisionTreeFactor</a>.  <a href="a02956.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02964.html">DiscreteEliminationTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05476.html">DiscreteEulerPoincareHelicopter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement the Discrete Euler-Poincare' equation:  <a href="a05476.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02968.html">DiscreteFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for discrete probabilistic factors The most general one is the derived <a class="el" href="a02932.html" title="A discrete probabilistic factor.">DecisionTreeFactor</a>.  <a href="a02968.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02984.html">DiscreteFactorGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Discrete <a class="el" href="a03544.html" title="This is the base class for all factor types.">Factor</a> Graph is a factor graph where all factors are Discrete, i.e.  <a href="a02984.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02992.html">DiscreteJunctionTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02996.html">DiscreteKeys</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a02996.html" title="DiscreteKeys is a set of keys that can be assembled using the &amp; operator.">DiscreteKeys</a> is a set of keys that can be assembled using the &amp; operator.  <a href="a02996.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03000.html">DiscreteMarginals</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for computing marginals of variables in a <a class="el" href="a02984.html" title="A Discrete Factor Graph is a factor graph where all factors are Discrete, i.e.">DiscreteFactorGraph</a>.  <a href="a03000.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04208.html">DoglegOptimizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class performs Dogleg nonlinear optimization.  <a href="a04208.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04212.html">DoglegOptimizerImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains the implementation of the Dogleg algorithm.  <a href="a04212.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04204.html">DoglegParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for Levenberg-Marquardt optimization.  <a href="a04204.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05016.html">Domain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a05016.html" title="Domain restriction constraint.">Domain</a> restriction constraint.  <a href="a05016.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05424.html">DRollPrior</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the roll to a particular value - useful for flying robots Implied value is zero Dim: 1.  <a href="a05424.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04988.html">DSF</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02464.html">DSFBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02452.html">DSFMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02468.html">DSFVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04992.html">Dummy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05244.html">DummyFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03948.html">DummyPreconditioner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03944.html">DummyPreconditionerParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04584.html">DynamicValuesMismatched</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03484.html">EliminatableClusterTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cluster-tree that eliminates to a Bayes tree.  <a href="a03484.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03532.html">EliminateableFactorGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a03532.html" title="EliminateableFactorGraph is a base class for factor graphs that contains elimination algorithms.">EliminateableFactorGraph</a> is a base class for factor graphs that contains elimination algorithms.  <a href="a03532.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03512.html">EliminationData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03504.html">EliminationTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class for eliminateable factor graphs, specifies the types that result from elimination, etc.  <a href="a03504.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02980.html">EliminationTraits&lt; DiscreteFactorGraph &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03740.html">EliminationTraits&lt; GaussianFactorGraph &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04956.html">EliminationTraits&lt; SymbolicFactorGraph &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03536.html">EliminationTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An elimination tree is a data structure used intermediately during elimination.  <a href="a03536.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05040.html">EqualityFactorGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of all Linear Equality constraints Ax=b of a Programming problem as a <a class="el" href="a03544.html" title="This is the base class for all factor types.">Factor</a> Graph.  <a href="a05040.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02648.html">equals</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template to create a binary predicate.  <a href="a02648.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02652.html">equals_star</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary predicate on shared pointers.  <a href="a02652.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05248.html">EquivInertialNavFactor_GlobalVel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05252.html">EquivInertialNavFactor_GlobalVel_NoBias</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03688.html">Errors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of errors  <a href="a03688.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03176.html">EssentialMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An essential matrix is like a <a class="el" href="a03288.html">Pose3</a>, except with translation up to scale It is named after the 3*3 matrix aEb = [aTb]x aRb from computer vision, but here we choose instead to parameterize it as a (<a class="el" href="a03336.html">Rot3</a>,<a class="el" href="a03460.html" title="Represents a 3D point on a unit sphere.">Unit3</a>) pair.  <a href="a03176.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04744.html">EssentialMatrixConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04748.html">EssentialMatrixFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a03544.html" title="This is the base class for all factor types.">Factor</a> that evaluates epipolar error p'Ep for given essential matrix.  <a href="a04748.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04752.html">EssentialMatrixFactor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary factor that optimizes for E and inverse depth d: assumes measurement in image 2 is perfect, and returns re-projection error in image 1.  <a href="a04752.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04756.html">EssentialMatrixFactor3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary factor that optimizes for E and inverse depth d: assumes measurement in image 2 is perfect, and returns re-projection error in image 1 This version takes an extrinsic rotation to allow for omni-directional rigs.  <a href="a04756.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04760.html">EssentialMatrixFactor4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary factor that optimizes for E and calibration K using the algebraic epipolar error (K^-1 pA)'E (K^-1 pB).  <a href="a04760.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02848.html">EvaluationFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a03544.html" title="This is the base class for all factor types.">Factor</a> for enforcing the scalar value of the polynomial BASIS representation at <code>x</code> is the same as the measurement <code>z</code> when using a pseudo-spectral parameterization.  <a href="a02848.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04240.html">Expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a04240.html" title="Expression class that supports automatic differentiation.">Expression</a> class that supports automatic differentiation.  <a href="a04240.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04228.html">ExpressionFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a03544.html" title="This is the base class for all factor types.">Factor</a> that supports arbitrary expressions via AD.  <a href="a04228.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04276.html">ExpressionFactorGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a03544.html" title="This is the base class for all factor types.">Factor</a> graph that supports adding ExpressionFactors directly.  <a href="a04276.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04268.html">ExpressionFactorN</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">N-ary variadic template for <a class="el" href="a04228.html" title="Factor that supports arbitrary expressions via AD.">ExpressionFactor</a> meant as a base class for N-ary factors.  <a href="a04268.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04280.html">ExtendedKalmanFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a generic Extended Kalman Filter class implemented using nonlinear factors.  <a href="a04280.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03544.html">Factor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class for all factor types.  <a href="a03544.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03480.html">FactorGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factor graph is a bipartite graph with factor nodes connected to variable nodes.  <a href="a03480.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02480.html">FastList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02484.html">FastMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02488.html">FastSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02888.html">FitBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that does regression via least squares Example usage: size_t N = 3; auto fit = FitBasis&lt;Chebyshev2&gt;(data_points, noise_model, N); Vector coefficients = fit.parameters();.  <a href="a02888.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02580.html">FixedDimension</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give fixed size dimension of a type, fails at compile time if dynamic.  <a href="a02580.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05192.html">FixedLagSmoother</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04996.html">FixedVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed size vectors - compatible with boost vectors, but with compile-type size checking.  <a href="a04996.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02892.html">FourierBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fourier basis.  <a href="a02892.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04772.html">FrobeniusBetweenFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a04772.html" title="FrobeniusBetweenFactor is a BetweenFactor that evaluates the Frobenius norm of the rotation error bet...">FrobeniusBetweenFactor</a> is a <a class="el" href="a04684.html">BetweenFactor</a> that evaluates the Frobenius norm of the rotation error between measured and predicted (rather than the Logmap of the error).  <a href="a04772.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04768.html">FrobeniusFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a04768.html" title="FrobeniusFactor calculates the Frobenius norm between rotation matrices.">FrobeniusFactor</a> calculates the Frobenius norm between rotation matrices.  <a href="a04768.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04764.html">FrobeniusPrior</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a04764.html" title="FrobeniusPrior calculates the Frobenius norm between a given matrix and an element of SO(3) or SO(4).">FrobeniusPrior</a> calculates the Frobenius norm between a given matrix and an element of SO(3) or SO(4).  <a href="a04764.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05436.html">FullIMUFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that represents integrating IMU measurements over time for dynamic systems This factor has dimension 9, with a built-in constraint for velocity modeling.  <a href="a05436.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04284.html">FunctorizedFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a03544.html" title="This is the base class for all factor types.">Factor</a> which evaluates provided unary functor and uses the result to compute error with respect to the provided measurement.  <a href="a04284.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04292.html">FunctorizedFactor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a03544.html" title="This is the base class for all factor types.">Factor</a> which evaluates provided binary functor and uses the result to compute error with respect to the provided measurement.  <a href="a04292.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02612.html">G_x1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that computes the derivative of f w.r.t.  <a href="a02612.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03696.html">GaussianBayesNet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Bayes net made from linear-Gaussian densities.  <a href="a03696.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03708.html">GaussianBayesTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Bayes tree representing a Gaussian density.  <a href="a03708.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03704.html">GaussianBayesTreeClique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A clique in a <a class="el" href="a03708.html" title="A Bayes tree representing a Gaussian density.">GaussianBayesTree</a>.  <a href="a03704.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03716.html">GaussianConditional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A conditional Gaussian functions as the node in a Bayes network It has a set of parents y,z, etc.  <a href="a03716.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03724.html">GaussianDensity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Gaussian density.  <a href="a03724.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03728.html">GaussianEliminationTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03732.html">GaussianFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract virtual base class for <a class="el" href="a03796.html" title="A Gaussian factor in the squared-error form.">JacobianFactor</a> and <a class="el" href="a03764.html" title="A Gaussian factor using the canonical parameters (information form)">HessianFactor</a>.  <a href="a03732.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03744.html">GaussianFactorGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Linear <a class="el" href="a03544.html" title="This is the base class for all factor types.">Factor</a> Graph is a factor graph where all factors are Gaussian, i.e.  <a href="a03744.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03928.html">GaussianFactorGraphSystem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a03776.html" title="Helper class encapsulating the combined system |Ax-b_|^2 Needed to run Conjugate Gradients on matrice...">System</a> class needed for calling preconditionedConjugateGradient.  <a href="a03928.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03752.html">GaussianISAM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03760.html">GaussianJunctionTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05256.html">GaussMarkov1stOrderFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04304.html">GaussNewtonOptimizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class performs Gauss-Newton nonlinear optimization.  <a href="a04304.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04300.html">GaussNewtonParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for Gauss-Newton optimization, inherits from NonlinearOptimizationParams.  <a href="a04300.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04776.html">GeneralSFMFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04784.html">GeneralSFMFactor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-linear factor for a constraint derived from a 2D measurement.  <a href="a04784.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04832.html">GenericProjectionFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04896.html">GenericStereoFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02492.html">GenericValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps any type T so it can play as a <a class="el" href="a02740.html" title="This is the base class for any type to be stored in Values.">Value</a>.  <a href="a02492.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04308.html">GncOptimizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04312.html">GncParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04080.html">GPSFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04084.html">GPSFactor2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04476.html">GraphvizFormatting</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formatting options when saving in GraphViz format using <a class="el" href="a04480.html#a6d45c7c50ce30af0c9ab4b6158ff1c58" title="Write the graph in GraphViz format for visualization.">NonlinearFactorGraph::saveGraph</a>.  <a href="a04476.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02500.html">group_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">tag to assert a type is a group  <a href="a02500.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03040.html">HasBearing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03044.html">HasRange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02656.html">HasTestablePrereqs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requirements on type to pass it to <a class="el" href="a02660.html" title="A helper that implements the traits interface for GTSAM types.">Testable</a> template below.  <a href="a02656.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03764.html">HessianFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Gaussian factor using the canonical parameters (information form)  <a href="a03764.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05440.html">IMUFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that represents integrating IMU measurements over time for dynamic systems Templated to allow for different key types, but variables all assumed to be <a class="el" href="a05460.html" title="Robot state for use with IMU measurements.">PoseRTV</a>.  <a href="a05440.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04100.html">ImuFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04104.html">ImuFactor2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03588.html">InconsistentEliminationRequested</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An inference algorithm was called with inconsistent arguments.  <a href="a03588.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05200.html">IncrementalFixedLagSmoother</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a base class for the various HMF2 implementations.  <a href="a05200.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03816.html">IndeterminantLinearSystemException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown when a linear system is ill-posed.  <a href="a03816.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02460.html">IndexPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Small utility class for representing a wrappable pairs of ints.  <a href="a02460.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05048.html">InequalityFactorGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of all Linear Inequality constraints Ax-b &lt;= 0 of a Programming problem as a <a class="el" href="a03544.html" title="This is the base class for all factor types.">Factor</a> Graph.  <a href="a05048.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05264.html">InertialNavFactor_GlobalVelocity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05056.html">InfeasibleInitialValues</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception indicating that the provided initial value is infeasible Also used to inzdicatethat the noise model dimension passed into a <a class="el" href="a03796.html" title="A Gaussian factor in the squared-error form.">JacobianFactor</a> has a different dimensionality than the factor.  <a href="a05056.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05060.html">InfeasibleOrUnboundedProblem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04792.html">InitializePose3</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02676.html">InvalidArgumentThreadsafe</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread-safe invalid argument exception.  <a href="a02676.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03828.html">InvalidDenseElimination</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03824.html">InvalidMatrixBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception indicating that a matrix block passed into a <a class="el" href="a03796.html" title="A Gaussian factor in the squared-error form.">JacobianFactor</a> has a different dimensionality than the factor.  <a href="a03824.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03820.html">InvalidNoiseModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception indicating that the noise model dimension passed into a <a class="el" href="a03796.html" title="A Gaussian factor in the squared-error form.">JacobianFactor</a> has a different dimensionality than the factor.  <a href="a03820.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05272.html">InvDepthFactor3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ternary factor representing a visual measurement that includes inverse depth.  <a href="a05272.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05276.html">InvDepthFactorVariant1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary factor representing a visual measurement using an inverse-depth parameterization.  <a href="a05276.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05280.html">InvDepthFactorVariant2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary factor representing a visual measurement using an inverse-depth parameterization.  <a href="a05280.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05284.html">InvDepthFactorVariant3a</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary factor representing the first visual measurement using an inverse-depth parameterization.  <a href="a05284.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05288.html">InvDepthFactorVariant3b</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ternary factor representing a visual measurement using an inverse-depth parameterization.  <a href="a05288.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03592.html">ISAM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Bayes tree with an update methods that implements the iSAM algorithm.  <a href="a03592.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04340.html">ISAM2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04316.html">ISAM2BayesTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04348.html">ISAM2Clique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized Clique structure for <a class="el" href="a04340.html">ISAM2</a>, incorporating caching and gradient contribution TODO: more documentation.  <a href="a04348.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04356.html">ISAM2DoglegParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04352.html">ISAM2GaussNewtonParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04320.html">ISAM2JunctionTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04360.html">ISAM2Params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04364.html">ISAM2Result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04376.html">ISAM2UpdateParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02512.html">IsGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group Concept.  <a href="a02512.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02548.html">IsLieGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lie Group Concept.  <a href="a02548.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02644.html">IsTestable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02800.html">IsVectorSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Space concept.  <a href="a02800.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03780.html">IterativeOptimizationParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">parameters for iterative linear solvers  <a href="a03780.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03784.html">IterativeSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for Iterative Solvers like <a class="el" href="a04012.html" title="This class implements the linear SPCG solver presented in Dellaert et al in IROS&#39;10.">SubgraphSolver</a>.  <a href="a03784.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03796.html">JacobianFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Gaussian factor in the squared-error form.  <a href="a03796.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04796.html">JacobianFactorQ</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a03796.html" title="A Gaussian factor in the squared-error form.">JacobianFactor</a> for Schur complement that uses Q noise model.  <a href="a04796.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04804.html">JacobianFactorQR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a03796.html" title="A Gaussian factor in the squared-error form.">JacobianFactor</a> for Schur complement that uses Q noise model.  <a href="a04804.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04808.html">JacobianFactorSVD</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a03796.html" title="A Gaussian factor in the squared-error form.">JacobianFactor</a> for Schur complement that uses the "Nullspace Trick" by Mourikis et al.  <a href="a04808.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04400.html">JointMarginal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to store and access a joint marginal, returned from <a class="el" href="a04396.html#a79299e7bb9a34e93be69d07882d95133" title="Compute the joint marginal covariance of several variables.">Marginals::jointMarginalCovariance</a> and <a class="el" href="a04396.html#a18949767da9858fbcc63268b4e28c24e" title="Compute the joint marginal information of several variables.">Marginals::jointMarginalInformation</a>.  <a href="a04400.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03604.html">JunctionTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03804.html">KalmanFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kalman Filter class.  <a href="a03804.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04812.html">KarcherMeanFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="a04812.html" title="The KarcherMeanFactor creates a constraint on all SO(n) variables with given keys that the Karcher me...">KarcherMeanFactor</a> creates a constraint on all SO(n) variables with given keys that the Karcher mean (see above) will stay the same.  <a href="a04812.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03612.html">key_formatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output stream manipulator that will format gtsam::Keys according to the given KeyFormatter, as long as Key values are wrapped in a <a class="el" href="a03608.html" title="To use the key_formatter on Keys, they must be wrapped in a StreamedKey.">gtsam::StreamedKey</a>.  <a href="a03612.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03792.html">KeyInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handy data structure for iterative solvers.  <a href="a03792.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03788.html">KeyInfoEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handy data structure for iterative solvers key to (index, dimension, start)  <a href="a03788.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03620.html">LabeledSymbol</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customized version of <a class="el" href="a03640.html" title="Character and index key used to refer to variables.">gtsam::Symbol</a> for multi-robot use.  <a href="a03620.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04380.html">LevenbergMarquardtOptimizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class performs Levenberg-Marquardt nonlinear optimization.  <a href="a04380.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04384.html">LevenbergMarquardtParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for Levenberg-Marquardt optimization.  <a href="a04384.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02536.html">lie_group_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">tag to assert a type is a Lie group  <a href="a02536.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02532.html">LieGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A CRTP helper class that implements Lie group methods Prerequisites: methods operator*, inverse, and AdjointMap, as well as a ChartAtOrigin struct that will be used to define the manifold Chart To use, simply derive, but also say "using LieGroup&lt;Class,N&gt;::inverse" For derivative math, see doc/math.pdf.  <a href="a02532.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03188.html">Line3</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04388.html">LinearContainerFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a04992.html">Dummy</a> version of a generic linear factor to be injected into a nonlinear factor graph.  <a href="a04388.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05064.html">LinearCost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class defines a linear cost function c'x which is a <a class="el" href="a03796.html" title="A Gaussian factor in the squared-error form.">JacobianFactor</a> with only one row.  <a href="a05064.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05072.html">LinearEquality</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class defines a linear equality constraints, inheriting <a class="el" href="a03796.html" title="A Gaussian factor in the squared-error form.">JacobianFactor</a> with the special Constrained noise model.  <a href="a05072.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05080.html">LinearInequality</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class defines a linear inequality constraint Ax-b &lt;= 0, inheriting <a class="el" href="a03796.html" title="A Gaussian factor in the squared-error form.">JacobianFactor</a> with the special Constrained noise model.  <a href="a05080.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05204.html">LinearizedGaussianFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base factor class for the Jacobian and Hessian linearized factors.  <a href="a05204.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05216.html">LinearizedHessianFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factor that takes a linear, Hessian factor and inserts it into a nonlinear graph.  <a href="a05216.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05208.html">LinearizedJacobianFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factor that takes a linear, Jacobian factor and inserts it into a nonlinear graph.  <a href="a05208.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02720.html">ListOfOneContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class that behaves as a container with one element, and works with boost::range.  <a href="a02720.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05292.html">LocalOrientedPlane3Factor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a03544.html" title="This is the base class for all factor types.">Factor</a> to measure a planar landmark from a given pose, with a given local linearization point.  <a href="a05292.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05088.html">LP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure of a Linear Program.  <a href="a05088.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05096.html">LPInitSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="a05096.html" title="This LPInitSolver implements the strategy in Matlab: http://www.mathworks.com/help/optim/ug/linear-pr...">LPInitSolver</a> implements the strategy in Matlab: <a href="http://www.mathworks.com/help/optim/ug/linear-programming-algorithms.html#brozyzb-9">http://www.mathworks.com/help/optim/ug/linear-programming-algorithms.html#brozyzb-9</a> Solve for x and y: min y st Ax = b Cx - y &lt;= d where y \in R, x \in R^n, and Ax = b and Cx &lt;= d is the constraints of the original problem.  <a href="a05096.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05100.html">LPPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy for ActivetSetSolver to solve Linear Programming.  <a href="a05100.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04120.html">MagFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a03544.html" title="This is the base class for all factor types.">Factor</a> to estimate rotation given magnetometer reading This version uses model measured bM = scale * bRn * direction + bias and assumes scale, direction, and the bias are given.  <a href="a04120.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04124.html">MagFactor1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a03544.html" title="This is the base class for all factor types.">Factor</a> to estimate rotation given magnetometer reading This version uses model measured bM = scale * bRn * direction + bias and assumes scale, direction, and the bias are given.  <a href="a04124.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04128.html">MagFactor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a03544.html" title="This is the base class for all factor types.">Factor</a> to calibrate local Earth magnetic field as well as magnetometer bias This version uses model measured bM = bRn * nM + bias and optimizes for both nM and the bias, where nM is in units defined by magnetometer.  <a href="a04128.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04132.html">MagFactor3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a03544.html" title="This is the base class for all factor types.">Factor</a> to calibrate local Earth magnetic field as well as magnetometer bias This version uses model measured bM = scale * bRn * direction + bias and optimizes for both scale, direction, and the bias.  <a href="a04132.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04136.html">MagPoseFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a03544.html" title="This is the base class for all factor types.">Factor</a> to estimate rotation of a <a class="el" href="a03264.html">Pose2</a> or <a class="el" href="a03288.html">Pose3</a> given a magnetometer reading.  <a href="a04136.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02624.html">MakeJacobian</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">: meta-function to generate Jacobian  <a href="a02624.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02628.html">MakeOptionalJacobian</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">: meta-function to generate JacobianTA optional reference Used mainly by Expressions  <a href="a02628.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02556.html">manifold_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">tag to assert a type is a manifold  <a href="a02556.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02860.html">ManifoldEvaluationFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a measurement value of type T i.e.  <a href="a02860.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04140.html">ManifoldPreintegration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IMU pre-integration on NavSatet manifold.  <a href="a04140.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04436.html">MarginalizeNonleafException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown when requesting to marginalize out variables from <a class="el" href="a04340.html">ISAM2</a> that are not leaves.  <a href="a04436.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04396.html">Marginals</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for computing Gaussian marginals of variables in a <a class="el" href="a04480.html" title="A non-linear factor graph is a graph of non-Gaussian, i.e.">NonlinearFactorGraph</a>.  <a href="a04396.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05296.html">Mechanization_bRn2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03628.html">MetisIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="a03628.html" title="The MetisIndex class converts a factor graph into the Compressed Sparse Row format for use in METIS a...">MetisIndex</a> class converts a factor graph into the Compressed Sparse Row format for use in METIS algorithms.  <a href="a03628.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04640.html">MFAS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02504.html">multiplicative_group_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group operator syntax flavors.  <a href="a02504.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02600.html">MultiplyWithInverse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor that implements multiplication of a vector b with the inverse of a matrix A.  <a href="a02600.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02604.html">MultiplyWithInverseFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor that implements multiplication with the inverse of a matrix, itself the result of a function f.  <a href="a02604.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05300.html">MultiProjectionFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04144.html">NavState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Navigation state: Pose (rotation, translation) + velocity NOTE(frank): it does not make sense to make this a Lie group, but it is a 9D manifold.  <a href="a04144.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02728.html">needs_eigen_aligned_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A SFINAE trait to mark classes that need special alignment.  <a href="a02728.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02732.html">needs_eigen_aligned_allocator&lt; T, void_t&lt; typename T::_eigen_aligned_allocator_trait &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04448.html">NoiseModelFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A nonlinear sum-of-squares factor with a zero-mean noise model implementing the density \( P(z|x) \propto exp -0.5*|z-h(x)|^2_C \) Templated on the parameter type X and the values structure <a class="el" href="a04560.html" title="A non-templated config holding any types of Manifold-group elements.">Values</a> There is no return type specified for h(x).  <a href="a04448.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04452.html">NoiseModelFactor1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient base class for creating your own <a class="el" href="a04448.html" title="A nonlinear sum-of-squares factor with a zero-mean noise model implementing the density  Templated on...">NoiseModelFactor</a> with 1 variable.  <a href="a04452.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04456.html">NoiseModelFactor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient base class for creating your own <a class="el" href="a04448.html" title="A nonlinear sum-of-squares factor with a zero-mean noise model implementing the density  Templated on...">NoiseModelFactor</a> with 2 variables.  <a href="a04456.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04460.html">NoiseModelFactor3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient base class for creating your own <a class="el" href="a04448.html" title="A nonlinear sum-of-squares factor with a zero-mean noise model implementing the density  Templated on...">NoiseModelFactor</a> with 3 variables.  <a href="a04460.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04464.html">NoiseModelFactor4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient base class for creating your own <a class="el" href="a04448.html" title="A nonlinear sum-of-squares factor with a zero-mean noise model implementing the density  Templated on...">NoiseModelFactor</a> with 4 variables.  <a href="a04464.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04468.html">NoiseModelFactor5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient base class for creating your own <a class="el" href="a04448.html" title="A nonlinear sum-of-squares factor with a zero-mean noise model implementing the density  Templated on...">NoiseModelFactor</a> with 5 variables.  <a href="a04468.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04472.html">NoiseModelFactor6</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient base class for creating your own <a class="el" href="a04448.html" title="A nonlinear sum-of-squares factor with a zero-mean noise model implementing the density  Templated on...">NoiseModelFactor</a> with 6 variables.  <a href="a04472.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04588.html">NoMatchFoundForFixed</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05224.html">NonlinearClusterTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04404.html">NonlinearConjugateGradientOptimizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of the nonlinear CG method using the template below.  <a href="a04404.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04412.html">NonlinearEquality</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An equality factor that forces either one variable to a constant, or a set of variables to be equal to each other.  <a href="a04412.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04420.html">NonlinearEquality1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple unary equality constraint - fixes a value for a variable.  <a href="a04420.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04428.html">NonlinearEquality2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple binary equality constraint - this constraint forces two variables to be the same.  <a href="a04428.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04440.html">NonlinearFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nonlinear factor base class.  <a href="a04440.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04480.html">NonlinearFactorGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-linear factor graph is a graph of non-Gaussian, i.e.  <a href="a04480.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04488.html">NonlinearISAM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class to manage <a class="el" href="a03592.html" title="A Bayes tree with an update methods that implements the iSAM algorithm.">ISAM</a> in a nonlinear context.  <a href="a04488.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04492.html">NonlinearOptimizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the abstract interface for classes that can optimize for the maximum-likelihood estimate of a <a class="el" href="a04480.html" title="A non-linear factor graph is a graph of non-Gaussian, i.e.">NonlinearFactorGraph</a>.  <a href="a04492.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04496.html">NonlinearOptimizerParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The common parameters for Nonlinear optimizers.  <a href="a04496.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05416.html">OdometryFactorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a05416.html" title="OdometryFactorBase: Pose2 odometry, with Basenodes.">OdometryFactorBase</a>: <a class="el" href="a03264.html">Pose2</a> odometry, with Basenodes.  <a href="a05416.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02616.html">OptionalJacobian</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a02616.html" title="OptionalJacobian is an Eigen::Ref like class that can take be constructed using either a fixed size o...">OptionalJacobian</a> is an Eigen::Ref like class that can take be constructed using either a fixed size or dynamic Eigen matrix.  <a href="a02616.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02620.html">OptionalJacobian&lt; Eigen::Dynamic, Eigen::Dynamic &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03632.html">Ordering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03560.html">ordering_key_visitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03200.html">OrientedPlane3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an infinite plane in 3D, which is composed of a planar normal and its perpendicular distance to the origin.  <a href="a03200.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04820.html">OrientedPlane3DirectionPrior</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04816.html">OrientedPlane3Factor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a03544.html" title="This is the base class for all factor types.">Factor</a> to measure a planar landmark from a given pose.  <a href="a04816.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02672.html">OutOfRangeThreadsafe</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread-safe out of range exception.  <a href="a02672.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02896.html">ParameterMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix abstraction of MxN values at the <a class="el" href="a02812.html" title="CRTP Base class for function bases.">Basis</a> points.  <a href="a02896.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05304.html">PartialPriorFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for a soft partial prior on any Lie type, with a mask over Expmap parameters.  <a href="a05304.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03924.html">PCGSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A virtual base class for the preconditioned conjugate gradient solver.  <a href="a03924.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03920.html">PCGSolverParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for PCG.  <a href="a03920.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05444.html">PendulumFactor1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the first constraint.  <a href="a05444.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05448.html">PendulumFactor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the second constraint the.  <a href="a05448.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05452.html">PendulumFactorPk</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the first position-momentum update rule p_k = -D_1 L_d(q_k,q_{k+1},h) = \frac{1}{h}mr^{2}\left(q_{k+1}-q_{k}\right)+mgrh(1-\alpha)\,\sin\left((1-\alpha)q_{k}+\alpha q_{k+1}\right) = (1/h)mr^2 (q_{k+1}-q_k) + mgrh(1-alpha) sin ((1-alpha)q_k+\alpha q_{k+1})  <a href="a05452.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05456.html">PendulumFactorPk1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the second position-momentum update rule p_k1 = D_2 L_d(q_k,q_{k+1},h) = \frac{1}{h}mr^{2}\left(q_{k+1}-q_{k}\right)-mgrh\alpha\sin\left((1-\alpha)q_{k}+\alpha q_{k+1}\right) = (1/h)mr^2 (q_{k+1}-q_k) - mgrh alpha sin ((1-alpha)q_k+\alpha q_{k+1})  <a href="a05456.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03132.html">PinholeBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03228.html">PinholeBaseK</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03212.html">PinholeCamera</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03232.html">PinholePose</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03244.html">PinholeSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a03244.html" title="PinholeSet: triangulates point and keeps an estimate of it around.">PinholeSet</a>: triangulates point and keeps an estimate of it around.  <a href="a03244.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03264.html">Pose2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03288.html">Pose3</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04044.html">Pose3AttitudeFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05308.html">PoseBetweenFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03164.html">PoseConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pose Concept A must contain a translation and a rotation, with each structure accessable directly and a type provided for each.  <a href="a03164.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05312.html">PosePriorFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04824.html">PoseRotationPrior</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05460.html">PoseRTV</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Robot state for use with IMU measurements.  <a href="a05460.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05316.html">PoseToPointFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04828.html">PoseTranslationPrior</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A prior on the translation part of a pose.  <a href="a04828.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03004.html">Potentials</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for both <a class="el" href="a02968.html" title="Base class for discrete probabilistic factors The most general one is the derived DecisionTreeFactor.">DiscreteFactor</a> and <a class="el" href="a02956.html" title="Discrete Conditional Density Derives from DecisionTreeFactor.">DiscreteConditional</a>.  <a href="a03004.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03932.html">PowerMethod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute maximum Eigenpair with power method.  <a href="a03932.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03940.html">Preconditioner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03936.html">PreconditionerParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03576.html">PredecessorMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map from variable key to parent key.  <a href="a03576.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04024.html">PreintegratedAhrsMeasurements</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PreintegratedAHRSMeasurements accumulates (integrates) the Gyroscope measurements (rotation rates) and the corresponding covariance matrix.  <a href="a04024.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04056.html">PreintegratedCombinedMeasurements</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04096.html">PreintegratedImuMeasurements</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04156.html">PreintegratedRotation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a04156.html" title="PreintegratedRotation is the base class for all PreintegratedMeasurements classes (in AHRSFactor,...">PreintegratedRotation</a> is the base class for all PreintegratedMeasurements classes (in <a class="el" href="a04028.html">AHRSFactor</a>, <a class="el" href="a04100.html">ImuFactor</a>, and <a class="el" href="a04060.html">CombinedImuFactor</a>).  <a href="a04156.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04152.html">PreintegratedRotationParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for pre-integration: Usage: Create just a single Params and pass a shared pointer to the constructor.  <a href="a04152.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04164.html">PreintegrationBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a04164.html" title="PreintegrationBase is the base class for PreintegratedMeasurements (in ImuFactor) and CombinedPreinte...">PreintegrationBase</a> is the base class for PreintegratedMeasurements (in <a class="el" href="a04100.html">ImuFactor</a>) and CombinedPreintegratedMeasurements (in <a class="el" href="a04060.html">CombinedImuFactor</a>).  <a href="a04164.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04052.html">PreintegrationCombinedParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for pre-integration using <a class="el" href="a04056.html">PreintegratedCombinedMeasurements</a>: Usage: Create just a single Params and pass a shared pointer to the constructor.  <a href="a04052.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04168.html">PreintegrationParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for pre-integration: Usage: Create just a single Params and pass a shared pointer to the constructor.  <a href="a04168.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04500.html">PriorFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02632.html">ProductLieGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template to construct the product Lie group of two other Lie groups Assumes Lie group structure for G and H.  <a href="a02632.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05320.html">ProjectionFactorPPP</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05328.html">ProjectionFactorPPPC</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05336.html">ProjectionFactorRollingShutter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05104.html">QP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct contains factor graphs of a Quadratic Programming problem.  <a href="a05104.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05108.html">QPInitSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class finds a feasible solution for a <a class="el" href="a05104.html" title="Struct contains factor graphs of a Quadratic Programming problem.">QP</a> problem.  <a href="a05108.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05112.html">QPPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy for ActivetSetSolver to solve Linear Programming.  <a href="a05112.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05124.html">QPSParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05128.html">QPSParserException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03028.html">Range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03148.html">Range&lt; CalibratedCamera, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03224.html">Range&lt; PinholeCamera&lt; Calibration &gt;, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03256.html">Range&lt; Point2, Point2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03260.html">Range&lt; Point3, Point3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03284.html">Range&lt; Pose2, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03312.html">Range&lt; Pose3, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05468.html">Range&lt; PoseRTV, PoseRTV &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04616.html">RangeFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04624.html">RangeFactorWithTransform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05472.html">Reconstruction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement the <a class="el" href="a05472.html" title="Implement the Reconstruction equation: , where : timestep (parameter) : poses at the current and the ...">Reconstruction</a> equation: \( g_{k+1} = g_k \exp (h\xi_k) \), where \( h \): timestep (parameter) \( g_{k+1}, g_{k} \): poses at the current and the next timestep \( \xi_k \): the body-fixed velocity (Lie algebra) It is somewhat similar to <a class="el" href="a04684.html">BetweenFactor</a>, but treats the body-fixed velocity \( \xi_k \) as a variable.  <a href="a05472.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02736.html">RedirectCout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For Python <b>str</b>().  <a href="a02736.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03552.html">RefCallPushBack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper.  <a href="a03552.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04840.html">ReferenceFrameFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constraint between two landmarks in separate maps Templated on: Point : Type of landmark Transform : Transform variable class.  <a href="a04840.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03960.html">RegularHessianFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04848.html">RegularImplicitSchurFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a04848.html" title="RegularImplicitSchurFactor.">RegularImplicitSchurFactor</a>.  <a href="a04848.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03968.html">RegularJacobianFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a03796.html" title="A Gaussian factor in the squared-error form.">JacobianFactor</a> with constant sized blocks Provides raw memory access versions of linear operator.  <a href="a03968.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05344.html">RelativeElevationFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary factor for a relative elevation.  <a href="a05344.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02584.html">Reshape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a02584.html" title="Reshape functor.">Reshape</a> functor.  <a href="a02584.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02588.html">Reshape&lt; M, M, InOptions, M, M, InOptions &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a02584.html" title="Reshape functor.">Reshape</a> specialization that does nothing as shape stays the same (needed to not be ambiguous for square input equals square output)  <a href="a02588.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02592.html">Reshape&lt; M, N, InOptions, M, N, InOptions &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a02584.html" title="Reshape functor.">Reshape</a> specialization that does nothing as shape stays the same.  <a href="a02592.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02596.html">Reshape&lt; N, M, InOptions, M, N, InOptions &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a02584.html" title="Reshape functor.">Reshape</a> specialization that does transpose.  <a href="a02596.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03320.html">Rot2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03336.html">Rot3</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04036.html">Rot3AttitudeFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04860.html">RotateDirectionsFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a03544.html" title="This is the base class for all factor types.">Factor</a> on unknown rotation iRc that relates two directions c Directions provide less constraints than a full rotation.  <a href="a04860.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04856.html">RotateFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a03544.html" title="This is the base class for all factor types.">Factor</a> on unknown rotation iRC that relates two incremental rotations c1Rc2 = iRc' * i1Ri2 * iRc Which we can write (see doc/math.lyx) e^[z] = iRc' * e^[p] * iRc = e^([iRc'*p]) with z and p measured and predicted angular velocities, and hence p = iRc * z.  <a href="a04856.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02668.html">RuntimeErrorThreadsafe</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread-safe runtime error exception.  <a href="a02668.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03972.html">Sampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sampling structure that keeps internal random number generators for diagonal distributions specified by NoiseModel.  <a href="a03972.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04256.html">ScalarMultiplyExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="a04256.html" title="A ScalarMultiplyExpression is a specialization of Expression that multiplies with a scalar It optimiz...">ScalarMultiplyExpression</a> is a specialization of <a class="el" href="a04240.html" title="Expression class that supports automatic differentiation.">Expression</a> that multiplies with a scalar It optimizes the Jacobian calculation for this specific case.  <a href="a04256.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03980.html">Scatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a03980.html" title="Scatter is an intermediate data structure used when building a HessianFactor incrementally,...">Scatter</a> is an intermediate data structure used when building a <a class="el" href="a03764.html" title="A Gaussian factor using the canonical parameters (information form)">HessianFactor</a> incrementally, to get the keys in the right order.  <a href="a03980.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04172.html">Scenario</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple trajectory simulator.  <a href="a04172.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04184.html">ScenarioRunner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05020.html">Scheduler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a05020.html" title="Scheduler class Creates one variable for each student, and three variables for each of the student&#39;s ...">Scheduler</a> class Creates one variable for each student, and three variables for each of the student's areas, for a total of 4*nrStudents variables.  <a href="a05020.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03568.html">SDGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a03568.html" title="SDGraph is undirected graph with variable keys and double edge weights.">SDGraph</a> is undirected graph with variable keys and double edge weights.  <a href="a03568.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04736.html">SfmData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the structure for SfM data.  <a href="a04736.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04728.html">SfmTrack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the structure for the 3D points.  <a href="a04728.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03572.html">SGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04652.html">ShonanAveraging</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that implements Shonan Averaging from our ECCV'20 paper.  <a href="a04652.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04656.html">ShonanAveraging2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04660.html">ShonanAveraging3</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04648.html">ShonanAveragingParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters governing optimization etc.  <a href="a04648.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04664.html">ShonanFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a04664.html" title="ShonanFactor is a BetweenFactor that moves in SO(p), but will land on the SO(d) sub-manifold of SO(p)...">ShonanFactor</a> is a <a class="el" href="a04684.html">BetweenFactor</a> that moves in SO(p), but will land on the SO(d) sub-manifold of SO(p) at the global minimum.  <a href="a04664.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04668.html">ShonanGaugeFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="a04668.html" title="The ShonanGaugeFactor creates a constraint on a single SO(n) to avoid moving in the stabilizer.">ShonanGaugeFactor</a> creates a constraint on a single SO(n) to avoid moving in the stabilizer.  <a href="a04668.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03020.html">Signature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a03020.html" title="Signature for a discrete conditional density, used to construct conditionals.">Signature</a> for a discrete conditional density, used to construct conditionals.  <a href="a03020.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03356.html">Similarity3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D similarity transform  <a href="a03356.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05028.html">SingleValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a05028.html" title="SingleValue constraint.">SingleValue</a> constraint.  <a href="a05028.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03976.html">SlotEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">One <a class="el" href="a03976.html" title="One SlotEntry stores the slot index for a variable, as well its dim.">SlotEntry</a> stores the slot index for a variable, as well its dim.  <a href="a03976.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04864.html">SmartFactorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for smart factors.  <a href="a04864.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04872.html">SmartProjectionFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a04872.html" title="SmartProjectionFactor: triangulates point and keeps an estimate of it around.">SmartProjectionFactor</a>: triangulates point and keeps an estimate of it around.  <a href="a04872.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04868.html">SmartProjectionParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04880.html">SmartProjectionPoseFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05348.html">SmartProjectionPoseFactorRollingShutter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04888.html">SmartProjectionRigFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05356.html">SmartRangeFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05364.html">SmartStereoProjectionFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a05364.html" title="SmartStereoProjectionFactor: triangulates point and keeps an estimate of it around.">SmartStereoProjectionFactor</a>: triangulates point and keeps an estimate of it around.  <a href="a05364.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05372.html">SmartStereoProjectionFactorPP</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05380.html">SmartStereoProjectionPoseFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03396.html">SO</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manifold of special orthogonal rotation matrices SO&lt;N&gt;.  <a href="a03396.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03416.html">StereoCamera</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03412.html">StereoCheiralityException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03428.html">StereoPoint2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03608.html">StreamedKey</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">To use the <a class="el" href="a03612.html" title="Output stream manipulator that will format gtsam::Keys according to the given KeyFormatter,...">key_formatter</a> on Keys, they must be wrapped in a <a class="el" href="a03608.html" title="To use the key_formatter on Keys, they must be wrapped in a StreamedKey.">StreamedKey</a>.  <a href="a03608.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03984.html">Subgraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03996.html">SubgraphBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03992.html">SubgraphBuilderParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04004.html">SubgraphPreconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a03984.html">Subgraph</a> conditioner class, as explained in the RSS 2010 submission.  <a href="a04004.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04000.html">SubgraphPreconditionerParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04012.html">SubgraphSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the linear SPCG solver presented in Dellaert et al in IROS'10.  <a href="a04012.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04008.html">SubgraphSolverParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03640.html">Symbol</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Character and index key used to refer to variables.  <a href="a03640.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03644.html">SymbolGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates symbol shorthands with alternative names different than the one-letter predefined ones.  <a href="a03644.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04908.html">SymbolicBayesNet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic Bayes Net.  <a href="a04908.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04920.html">SymbolicBayesTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Bayes tree that represents the connectivity between variables but is not associated with any probability functions.  <a href="a04920.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04916.html">SymbolicBayesTreeClique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A clique in a <a class="el" href="a04920.html" title="A Bayes tree that represents the connectivity between variables but is not associated with any probab...">SymbolicBayesTree</a>.  <a href="a04916.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04932.html">SymbolicConditional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a04932.html" title="SymbolicConditional is a conditional with keys but no probability data, produced by symbolic eliminat...">SymbolicConditional</a> is a conditional with keys but no probability data, produced by symbolic elimination of <a class="el" href="a04948.html" title="SymbolicFactor represents a symbolic factor that specifies graph topology but is not associated with ...">SymbolicFactor</a>.  <a href="a04932.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04940.html">SymbolicEliminationTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04948.html">SymbolicFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a04948.html" title="SymbolicFactor represents a symbolic factor that specifies graph topology but is not associated with ...">SymbolicFactor</a> represents a symbolic factor that specifies graph topology but is not associated with any numerical function.  <a href="a04948.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04960.html">SymbolicFactorGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic <a class="el" href="a03544.html" title="This is the base class for all factor types.">Factor</a> Graph.  <a href="a04960.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04968.html">SymbolicISAM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04972.html">SymbolicJunctionTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02640.html">SymmetricBlockMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03776.html">System</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class encapsulating the combined system |Ax-b_|^2 Needed to run Conjugate Gradients on matrices.  <a href="a03776.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04188.html">TangentPreintegration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate on the 9D tangent space of the <a class="el" href="a04144.html" title="Navigation state: Pose (rotation, translation) + velocity NOTE(frank): it does not make sense to make...">NavState</a> manifold.  <a href="a04188.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02724.html">TbbOpenMPMixedScope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object whose scope defines a block where TBB and OpenMP parallelism are mixed.  <a href="a02724.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02660.html">Testable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper that implements the traits interface for GTSAM types.  <a href="a02660.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02664.html">ThreadsafeException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base exception type that uses tbb_allocator if GTSAM is compiled with TBB.  <a href="a02664.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05388.html">TOAFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A "Time of Arrival" factor - so little code seems hardly worth it :-)  <a href="a05388.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02444.html">traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A manifold defines a space in which there is a notion of a linear tangent space that can be centered around a given point on the manifold.  <a href="a02444.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04604.html">traits&lt; BearingFactor&lt; A1, A2, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04604.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03036.html">traits&lt; BearingRange&lt; A1, A2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04612.html">traits&lt; BearingRangeFactor&lt; A1, A2, B, R &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04612.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04696.html">traits&lt; BetweenConstraint&lt; VALUE &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04696.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04688.html">traits&lt; BetweenFactor&lt; VALUE &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04688.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03676.html">traits&lt; BinaryJacobianFactor&lt; M, N1, N2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03056.html">traits&lt; Cal3_S2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03068.html">traits&lt; Cal3_S2Stereo &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03080.html">traits&lt; Cal3Bundler &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03092.html">traits&lt; Cal3DS2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03108.html">traits&lt; Cal3Fisheye &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03120.html">traits&lt; Cal3Unified &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03140.html">traits&lt; CalibratedCamera &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03156.html">traits&lt; CameraSet&lt; CAMERA &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04072.html">traits&lt; CombinedImuFactor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05144.html">traits&lt; ConcurrentBatchFilter &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a05144.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05156.html">traits&lt; ConcurrentBatchSmoother &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a05156.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05176.html">traits&lt; ConcurrentIncrementalFilter &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a05176.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05188.html">traits&lt; ConcurrentIncrementalSmoother &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a05188.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03060.html">traits&lt; const Cal3_S2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03072.html">traits&lt; const Cal3_S2Stereo &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03084.html">traits&lt; const Cal3Bundler &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03096.html">traits&lt; const Cal3DS2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03112.html">traits&lt; const Cal3Fisheye &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03124.html">traits&lt; const Cal3Unified &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03144.html">traits&lt; const CalibratedCamera &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03160.html">traits&lt; const CameraSet&lt; CAMERA &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03184.html">traits&lt; const EssentialMatrix &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03196.html">traits&lt; const Line3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03208.html">traits&lt; const OrientedPlane3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03220.html">traits&lt; const PinholeCamera&lt; Calibration &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03240.html">traits&lt; const PinholePose&lt; CALIBRATION &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03252.html">traits&lt; const PinholeSet&lt; CAMERA &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03276.html">traits&lt; const Pose2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03300.html">traits&lt; const Pose3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03332.html">traits&lt; const Rot2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03352.html">traits&lt; const Rot3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03368.html">traits&lt; const Similarity3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03384.html">traits&lt; const SO3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03392.html">traits&lt; const SO4 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03408.html">traits&lt; const SO&lt; N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03424.html">traits&lt; const StereoCamera &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03436.html">traits&lt; const StereoPoint2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03468.html">traits&lt; const Unit3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03172.html">traits&lt; Cyclic&lt; N &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define cyclic group to be a model of the Additive Group concept.  <a href="a03172.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02936.html">traits&lt; DecisionTreeFactor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02520.html">traits&lt; DirectProduct&lt; G, H &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02528.html">traits&lt; DirectSum&lt; G, H &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02944.html">traits&lt; DiscreteBayesNet &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02960.html">traits&lt; DiscreteConditional &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02972.html">traits&lt; DiscreteFactor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02976.html">traits&lt; DiscreteFactor::Values &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02988.html">traits&lt; DiscreteFactorGraph &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a02988.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02772.html">traits&lt; double &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">double  <a href="a02772.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02788.html">traits&lt; Eigen::Matrix&lt; double, -1, -1, Options, MaxRows, MaxCols &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02792.html">traits&lt; Eigen::Matrix&lt; double, -1, 1, Options, MaxRows, MaxCols &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02796.html">traits&lt; Eigen::Matrix&lt; double, 1, -1, Options, MaxRows, MaxCols &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02780.html">traits&lt; Eigen::Matrix&lt; double, M, N, Options, MaxRows, MaxCols &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05044.html">traits&lt; EqualityFactorGraph &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a05044.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03692.html">traits&lt; Errors &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a03692.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03180.html">traits&lt; EssentialMatrix &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04264.html">traits&lt; ExpressionFactor&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04264.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04272.html">traits&lt; ExpressionFactorN&lt; T, Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04272.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02776.html">traits&lt; float &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">float  <a href="a02776.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04296.html">traits&lt; FunctorizedFactor2&lt; R, T1, T2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04296.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04288.html">traits&lt; FunctorizedFactor&lt; R, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04288.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03700.html">traits&lt; GaussianBayesNet &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a03700.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03712.html">traits&lt; GaussianBayesTree &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a03712.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03720.html">traits&lt; GaussianConditional &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a03720.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03736.html">traits&lt; GaussianFactor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a03736.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03748.html">traits&lt; GaussianFactorGraph &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a03748.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03756.html">traits&lt; GaussianISAM &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a03756.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05260.html">traits&lt; GaussMarkov1stOrderFactor&lt; VALUE &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a05260.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04788.html">traits&lt; GeneralSFMFactor2&lt; CALIBRATION &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04780.html">traits&lt; GeneralSFMFactor&lt; CAMERA, LANDMARK &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04836.html">traits&lt; GenericProjectionFactor&lt; POSE, LANDMARK, CALIBRATION &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04836.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04900.html">traits&lt; GenericStereoFactor&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04900.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02496.html">traits&lt; GenericValue&lt; ValueType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03768.html">traits&lt; HessianFactor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a03768.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04092.html">traits&lt; imuBias::ConstantBias &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04112.html">traits&lt; ImuFactor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04116.html">traits&lt; ImuFactor2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05052.html">traits&lt; InequalityFactorGraph &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a05052.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05268.html">traits&lt; InertialNavFactor_GlobalVelocity&lt; POSE, VELOCITY, IMUBIAS &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a05268.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04344.html">traits&lt; ISAM2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04344.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03800.html">traits&lt; JacobianFactor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a03800.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04800.html">traits&lt; JacobianFactorQ&lt; D, ZDim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03616.html">traits&lt; Key &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03624.html">traits&lt; LabeledSymbol &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a03624.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03192.html">traits&lt; Line3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04392.html">traits&lt; LinearContainerFactor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05068.html">traits&lt; LinearCost &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a05068.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05076.html">traits&lt; LinearEquality &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a05076.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05084.html">traits&lt; LinearInequality &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a05084.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05220.html">traits&lt; LinearizedHessianFactor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a05220.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05212.html">traits&lt; LinearizedJacobianFactor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a05212.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05092.html">traits&lt; LP &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a05092.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04148.html">traits&lt; NavState &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03908.html">traits&lt; noiseModel::Constrained &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03904.html">traits&lt; noiseModel::Diagonal &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03900.html">traits&lt; noiseModel::Gaussian &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a03900.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03912.html">traits&lt; noiseModel::Isotropic &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03916.html">traits&lt; noiseModel::Unit &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04424.html">traits&lt; NonlinearEquality1&lt; VALUE &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04432.html">traits&lt; NonlinearEquality2&lt; VALUE &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04416.html">traits&lt; NonlinearEquality&lt; VALUE &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04444.html">traits&lt; NonlinearFactor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04444.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04484.html">traits&lt; NonlinearFactorGraph &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04484.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03636.html">traits&lt; Ordering &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a03636.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03204.html">traits&lt; OrientedPlane3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02900.html">traits&lt; ParameterMatrix&lt; M &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03216.html">traits&lt; PinholeCamera&lt; Calibration &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03236.html">traits&lt; PinholePose&lt; CALIBRATION &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03248.html">traits&lt; PinholeSet&lt; CAMERA &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03272.html">traits&lt; Pose2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03296.html">traits&lt; Pose3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04048.html">traits&lt; Pose3AttitudeFactor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04048.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05464.html">traits&lt; PoseRTV &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03008.html">traits&lt; Potentials &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03012.html">traits&lt; Potentials::ADT &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04068.html">traits&lt; PreintegratedCombinedMeasurements &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04108.html">traits&lt; PreintegratedImuMeasurements &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04160.html">traits&lt; PreintegratedRotation &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04064.html">traits&lt; PreintegrationCombinedParams &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04504.html">traits&lt; PriorFactor&lt; VALUE &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04504.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02636.html">traits&lt; ProductLieGroup&lt; G, H &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05324.html">traits&lt; ProjectionFactorPPP&lt; POSE, LANDMARK, CALIBRATION &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a05324.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05332.html">traits&lt; ProjectionFactorPPPC&lt; POSE, LANDMARK, CALIBRATION &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a05332.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05340.html">traits&lt; ProjectionFactorRollingShutter &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a05340.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03316.html">traits&lt; QUATERNION_TYPE &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04620.html">traits&lt; RangeFactor&lt; A1, A2, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04620.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04628.html">traits&lt; RangeFactorWithTransform&lt; A1, A2, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04628.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04844.html">traits&lt; ReferenceFrameFactor&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04844.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03964.html">traits&lt; RegularHessianFactor&lt; D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04852.html">traits&lt; RegularImplicitSchurFactor&lt; CAMERA &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03328.html">traits&lt; Rot2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03348.html">traits&lt; Rot3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04040.html">traits&lt; Rot3AttitudeFactor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04040.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04740.html">traits&lt; SfmData &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04740.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04732.html">traits&lt; SfmTrack &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04732.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03364.html">traits&lt; Similarity3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04876.html">traits&lt; SmartProjectionFactor&lt; CAMERA &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04876.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04884.html">traits&lt; SmartProjectionPoseFactor&lt; CALIBRATION &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04884.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05352.html">traits&lt; SmartProjectionPoseFactorRollingShutter&lt; CAMERA &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a05352.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04892.html">traits&lt; SmartProjectionRigFactor&lt; CAMERA &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04892.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05368.html">traits&lt; SmartStereoProjectionFactor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a05368.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05376.html">traits&lt; SmartStereoProjectionFactorPP &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a05376.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05384.html">traits&lt; SmartStereoProjectionPoseFactor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a05384.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03380.html">traits&lt; SO3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03388.html">traits&lt; SO4 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03404.html">traits&lt; SO&lt; N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03420.html">traits&lt; StereoCamera &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03432.html">traits&lt; StereoPoint2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03648.html">traits&lt; Symbol &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a03648.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04912.html">traits&lt; SymbolicBayesNet &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04912.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04928.html">traits&lt; SymbolicBayesTree &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04924.html">traits&lt; SymbolicBayesTreeClique &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04924.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04936.html">traits&lt; SymbolicConditional &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04936.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04944.html">traits&lt; SymbolicEliminationTree &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04944.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04952.html">traits&lt; SymbolicFactor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04952.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04964.html">traits&lt; SymbolicFactorGraph &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04964.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05396.html">traits&lt; TransformBtwRobotsUnaryFactor&lt; VALUE &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a05396.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05404.html">traits&lt; TransformBtwRobotsUnaryFactorEM&lt; VALUE &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a05404.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03464.html">traits&lt; Unit3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04592.html">traits&lt; Values &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04592.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03656.html">traits&lt; VariableIndex &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a03656.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03664.html">traits&lt; VariableSlots &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a03664.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04020.html">traits&lt; VectorValues &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="a04020.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05392.html">TransformBtwRobotsUnaryFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05400.html">TransformBtwRobotsUnaryFactorEM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02552.html">TransformCovariance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for transforming covariance of T.  <a href="a02552.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04672.html">TranslationFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04676.html">TranslationRecovery</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03444.html">TriangulationCheiralityException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown by triangulateDLT when landmark is behind one or more of the cameras.  <a href="a03444.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04904.html">TriangulationFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03452.html">TriangulationParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03456.html">TriangulationResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a03456.html" title="TriangulationResult is an optional point, along with the reasons why it is invalid.">TriangulationResult</a> is an optional point, along with the reasons why it is invalid.  <a href="a03456.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03440.html">TriangulationUnderconstrainedException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown by triangulateDLT when SVD returns rank &lt; 3.  <a href="a03440.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03460.html">Unit3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a 3D point on a unit sphere.  <a href="a03460.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04336.html">UpdateImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation functions for update method All of the methods below have clear inputs and outputs, even if not functional: iSAM2 is inherintly imperative.  <a href="a04336.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02740.html">Value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class for any type to be stored in <a class="el" href="a04560.html" title="A non-templated config holding any types of Manifold-group elements.">Values</a>.  <a href="a02740.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04556.html">ValueCloneAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04560.html">Values</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-templated config holding any types of Manifold-group elements.  <a href="a04560.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04516.html">ValuesCastHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04524.html">ValuesCastHelper&lt; const Value, CastedKeyValuePairType, KeyValuePairType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04520.html">ValuesCastHelper&lt; Value, CastedKeyValuePairType, KeyValuePairType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04580.html">ValuesIncorrectType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04572.html">ValuesKeyAlreadyExists</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04576.html">ValuesKeyDoesNotExist</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02716.html">ValueWithDefault</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct that encapsulates a value with a default, this is just used as a member object so you don't have to specify defaults in the class constructor.  <a href="a02716.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03652.html">VariableIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="a03652.html" title="The VariableIndex class computes and stores the block column structure of a factor graph.">VariableIndex</a> class computes and stores the block column structure of a factor graph.  <a href="a03652.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03660.html">VariableSlots</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A combined factor is assembled as one block of rows for each component factor.  <a href="a03660.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02744.html">vector_space_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">tag to assert a type is a vector space  <a href="a02744.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02856.html">VectorComponentFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary factor for enforcing BASIS polynomial evaluation on a <a class="el" href="a02896.html" title="A matrix abstraction of MxN values at the Basis points.">ParameterMatrix</a> of size (P, N) is equal to specified measurement at the same point, when using a pseudo-spectral parameterization.  <a href="a02856.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02868.html">VectorDerivativeFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unary factor which enforces the evaluation of the derivative of a BASIS polynomial at a specified point <code>x</code> is equal to the vector value <code>z</code>.  <a href="a02868.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02852.html">VectorEvaluationFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary factor for enforcing BASIS polynomial evaluation on a <a class="el" href="a02896.html" title="A matrix abstraction of MxN values at the Basis points.">ParameterMatrix</a> of size (M, N) is equal to a vector-valued measurement at the same point, when using a pseudo-spectral parameterization.  <a href="a02852.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04016.html">VectorValues</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a collection of vector-valued variables associated each with a unique integer index.  <a href="a04016.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05480.html">VelocityConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a05008.html" title="Base class for discrete probabilistic factors The most general one is the derived DecisionTreeFactor.">Constraint</a> to enforce dynamics between the velocities and poses, using a prediction based on a numerical integration flag.  <a href="a05480.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05484.html">VelocityConstraint3</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05428.html">VelocityPrior</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrains the full velocity of a state to a particular value Useful for enforcing a stationary state Dim: 3.  <a href="a05428.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02804.html">VerticalBlockMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02808.html">WeightedSampler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04596.html">WhiteNoiseFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary factor to estimate parameters of zero-mean Gaussian white noise.  <a href="a04596.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a092fd3b7d2dd45e74b0f86535352096e"><td class="memItemLeft" align="right" valign="top"><a id="a092fd3b7d2dd45e74b0f86535352096e" name="a092fd3b7d2dd45e74b0f86535352096e"></a>
typedef std::vector&lt; <a class="el" href="a02460.html">IndexPair</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>IndexPairVector</b></td></tr>
<tr class="separator:a092fd3b7d2dd45e74b0f86535352096e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413e2bde9b0cf18304c55dbf3298bfbe"><td class="memItemLeft" align="right" valign="top"><a id="a413e2bde9b0cf18304c55dbf3298bfbe" name="a413e2bde9b0cf18304c55dbf3298bfbe"></a>
typedef std::set&lt; <a class="el" href="a02460.html">IndexPair</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>IndexPairSet</b></td></tr>
<tr class="separator:a413e2bde9b0cf18304c55dbf3298bfbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32fbede75b498a6c324e635ca527b69e"><td class="memItemLeft" align="right" valign="top"><a id="a32fbede75b498a6c324e635ca527b69e" name="a32fbede75b498a6c324e635ca527b69e"></a>
typedef std::map&lt; <a class="el" href="a02460.html">IndexPair</a>, IndexPairSet &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>IndexPairSetMap</b></td></tr>
<tr class="separator:a32fbede75b498a6c324e635ca527b69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fc976abe80b9b909bb77d8c541e20e"><td class="memItemLeft" align="right" valign="top"><a id="ab6fc976abe80b9b909bb77d8c541e20e" name="ab6fc976abe80b9b909bb77d8c541e20e"></a>
typedef <a class="el" href="a02452.html">DSFMap</a>&lt; <a class="el" href="a02460.html">IndexPair</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>DSFMapIndexPair</b></td></tr>
<tr class="separator:ab6fc976abe80b9b909bb77d8c541e20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeaa7d82369f3ff952157586240273c8"><td class="memTemplParams" colspan="2"><a id="afeaa7d82369f3ff952157586240273c8" name="afeaa7d82369f3ff952157586240273c8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afeaa7d82369f3ff952157586240273c8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FastVector</b> = std::vector&lt; T, typename <a class="el" href="a02476.html">internal::FastDefaultVectorAllocator</a>&lt; T &gt;::type &gt;</td></tr>
<tr class="separator:afeaa7d82369f3ff952157586240273c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e06cd29f4e8a20a8a7842e4045845f"><td class="memTemplParams" colspan="2"><a id="a47e06cd29f4e8a20a8a7842e4045845f" name="a47e06cd29f4e8a20a8a7842e4045845f"></a>
template&lt;bool B, class T  = void&gt; </td></tr>
<tr class="memitem:a47e06cd29f4e8a20a8a7842e4045845f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enable_if_t</b> = typename std::enable_if&lt; B, T &gt;::type</td></tr>
<tr class="memdesc:a47e06cd29f4e8a20a8a7842e4045845f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An shorthand alias for accessing the ::type inside std::enable_if that can be used in a template directly. <br /></td></tr>
<tr class="separator:a47e06cd29f4e8a20a8a7842e4045845f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a792d93b6d3283b4c2f3fb5954190f"><td class="memItemLeft" align="right" valign="top"><a id="a03a792d93b6d3283b4c2f3fb5954190f" name="a03a792d93b6d3283b4c2f3fb5954190f"></a>
typedef Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>Matrix</b></td></tr>
<tr class="separator:a03a792d93b6d3283b4c2f3fb5954190f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14bcd25aa57e5e0477389b9a08b9098"><td class="memItemLeft" align="right" valign="top"><a id="ae14bcd25aa57e5e0477389b9a08b9098" name="ae14bcd25aa57e5e0477389b9a08b9098"></a>
typedef Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MatrixRowMajor</b></td></tr>
<tr class="separator:ae14bcd25aa57e5e0477389b9a08b9098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3218833aef585dcaf060bdef7c8ee861"><td class="memItemLeft" align="right" valign="top"><a id="a3218833aef585dcaf060bdef7c8ee861" name="a3218833aef585dcaf060bdef7c8ee861"></a>
typedef Eigen::Block&lt; Matrix &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SubMatrix</b></td></tr>
<tr class="separator:a3218833aef585dcaf060bdef7c8ee861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7197dd6ad1eee8ece9aa15edbabc3b68"><td class="memItemLeft" align="right" valign="top"><a id="a7197dd6ad1eee8ece9aa15edbabc3b68" name="a7197dd6ad1eee8ece9aa15edbabc3b68"></a>
typedef Eigen::Block&lt; const Matrix &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConstSubMatrix</b></td></tr>
<tr class="separator:a7197dd6ad1eee8ece9aa15edbabc3b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad029f5f6ffce610428b5fe768b0df2"><td class="memItemLeft" align="right" valign="top"><a id="adad029f5f6ffce610428b5fe768b0df2" name="adad029f5f6ffce610428b5fe768b0df2"></a>
typedef std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>Key</b></td></tr>
<tr class="memdesc:adad029f5f6ffce610428b5fe768b0df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer nonlinear key type. <br /></td></tr>
<tr class="separator:adad029f5f6ffce610428b5fe768b0df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c53f2faabb0f4b4b78ce2f7168cc14"><td class="memItemLeft" align="right" valign="top"><a id="a19c53f2faabb0f4b4b78ce2f7168cc14" name="a19c53f2faabb0f4b4b78ce2f7168cc14"></a>
typedef std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>FactorIndex</b></td></tr>
<tr class="memdesc:a19c53f2faabb0f4b4b78ce2f7168cc14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer nonlinear factor index type. <br /></td></tr>
<tr class="separator:a19c53f2faabb0f4b4b78ce2f7168cc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21006f326f57cdf7d3f35fec40f43e40"><td class="memItemLeft" align="right" valign="top"><a id="a21006f326f57cdf7d3f35fec40f43e40" name="a21006f326f57cdf7d3f35fec40f43e40"></a>
typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><b>DenseIndex</b></td></tr>
<tr class="memdesc:a21006f326f57cdf7d3f35fec40f43e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index type for Eigen objects. <br /></td></tr>
<tr class="separator:a21006f326f57cdf7d3f35fec40f43e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6525d741529c7a2cd91fa913431f5fb7"><td class="memTemplParams" colspan="2"><a id="a6525d741529c7a2cd91fa913431f5fb7" name="a6525d741529c7a2cd91fa913431f5fb7"></a>
template&lt;typename ... &gt; </td></tr>
<tr class="memitem:a6525d741529c7a2cd91fa913431f5fb7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>void_t</b> = void</td></tr>
<tr class="memdesc:a6525d741529c7a2cd91fa913431f5fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience void_t as we assume C++11, it will not conflict the std one in C++17 as this is in <code>gtsam::</code> <br /></td></tr>
<tr class="separator:a6525d741529c7a2cd91fa913431f5fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6a39f5eb77f4d28961cef67ebf98f3"><td class="memItemLeft" align="right" valign="top"><a id="aad6a39f5eb77f4d28961cef67ebf98f3" name="aad6a39f5eb77f4d28961cef67ebf98f3"></a>
typedef Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><b>Vector</b></td></tr>
<tr class="separator:aad6a39f5eb77f4d28961cef67ebf98f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3acc4ae7ccbb2c04ee7e024f2d7e0675"><td class="memItemLeft" align="right" valign="top"><a id="a3acc4ae7ccbb2c04ee7e024f2d7e0675" name="a3acc4ae7ccbb2c04ee7e024f2d7e0675"></a>
typedef Eigen::Matrix&lt; double, 1, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Vector1</b></td></tr>
<tr class="separator:a3acc4ae7ccbb2c04ee7e024f2d7e0675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f77c4fccbc506166116e363c1fa06e"><td class="memItemLeft" align="right" valign="top"><a id="a54f77c4fccbc506166116e363c1fa06e" name="a54f77c4fccbc506166116e363c1fa06e"></a>
typedef Eigen::Vector2d&#160;</td><td class="memItemRight" valign="bottom"><b>Vector2</b></td></tr>
<tr class="separator:a54f77c4fccbc506166116e363c1fa06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87074ffb029b86bb8c54edd2a29cb1ae"><td class="memItemLeft" align="right" valign="top"><a id="a87074ffb029b86bb8c54edd2a29cb1ae" name="a87074ffb029b86bb8c54edd2a29cb1ae"></a>
typedef Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><b>Vector3</b></td></tr>
<tr class="separator:a87074ffb029b86bb8c54edd2a29cb1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d1471ff74798e876eac3c5dddc3d53"><td class="memItemLeft" align="right" valign="top"><a id="ae8d1471ff74798e876eac3c5dddc3d53" name="ae8d1471ff74798e876eac3c5dddc3d53"></a>
typedef Eigen::VectorBlock&lt; Vector &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SubVector</b></td></tr>
<tr class="separator:ae8d1471ff74798e876eac3c5dddc3d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab75d3757735f345508c14966678e983"><td class="memItemLeft" align="right" valign="top"><a id="aab75d3757735f345508c14966678e983" name="aab75d3757735f345508c14966678e983"></a>
typedef Eigen::VectorBlock&lt; const Vector &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConstSubVector</b></td></tr>
<tr class="separator:aab75d3757735f345508c14966678e983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3caa86eb94d40f2d3decce787fa3b2"><td class="memItemLeft" align="right" valign="top"><a id="a0c3caa86eb94d40f2d3decce787fa3b2" name="a0c3caa86eb94d40f2d3decce787fa3b2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Weights</b> = Eigen::Matrix&lt; double, 1, -1 &gt;</td></tr>
<tr class="separator:a0c3caa86eb94d40f2d3decce787fa3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ec5d6ec6b211d0cbaf645c11c198de"><td class="memItemLeft" align="right" valign="top"><a id="a24ec5d6ec6b211d0cbaf645c11c198de" name="a24ec5d6ec6b211d0cbaf645c11c198de"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Sequence</b> = std::map&lt; double, double &gt;</td></tr>
<tr class="memdesc:a24ec5d6ec6b211d0cbaf645c11c198de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Our sequence representation is a map of {x: y} values where y = f(x) <br /></td></tr>
<tr class="separator:a24ec5d6ec6b211d0cbaf645c11c198de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9920fe883a2f506440aca7c1a2bd1a00"><td class="memItemLeft" align="right" valign="top"><a id="a9920fe883a2f506440aca7c1a2bd1a00" name="a9920fe883a2f506440aca7c1a2bd1a00"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Sample</b> = std::pair&lt; double, double &gt;</td></tr>
<tr class="memdesc:a9920fe883a2f506440aca7c1a2bd1a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sample is a key-value pair from a sequence. <br /></td></tr>
<tr class="separator:a9920fe883a2f506440aca7c1a2bd1a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd19e5d1e5d06c37246d4c15af38ee67"><td class="memItemLeft" align="right" valign="top"><a id="acd19e5d1e5d06c37246d4c15af38ee67" name="acd19e5d1e5d06c37246d4c15af38ee67"></a>
typedef std::pair&lt; <a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a>, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>DiscreteKey</b></td></tr>
<tr class="memdesc:acd19e5d1e5d06c37246d4c15af38ee67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key type for discrete conditionals Includes name and cardinality. <br /></td></tr>
<tr class="separator:acd19e5d1e5d06c37246d4c15af38ee67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ede8384dee0353a0ce5fb54ea50c21d"><td class="memItemLeft" align="right" valign="top"><a id="a6ede8384dee0353a0ce5fb54ea50c21d" name="a6ede8384dee0353a0ce5fb54ea50c21d"></a>
typedef Vector2&#160;</td><td class="memItemRight" valign="bottom"><b>Point2</b></td></tr>
<tr class="memdesc:a6ede8384dee0353a0ce5fb54ea50c21d"><td class="mdescLeft">&#160;</td><td class="mdescRight">As of GTSAM 4, in order to make GTSAM more lean, it is now possible to just typedef Point2 to Vector2. <br /></td></tr>
<tr class="separator:a6ede8384dee0353a0ce5fb54ea50c21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea758f150791443afe1191868963b4e1"><td class="memItemLeft" align="right" valign="top"><a id="aea758f150791443afe1191868963b4e1" name="aea758f150791443afe1191868963b4e1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Point2Pair</b> = std::pair&lt; <a class="el" href="a01596.html#a6ede8384dee0353a0ce5fb54ea50c21d">Point2</a>, <a class="el" href="a01596.html#a6ede8384dee0353a0ce5fb54ea50c21d">Point2</a> &gt;</td></tr>
<tr class="memdesc:aea758f150791443afe1191868963b4e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate pose between a vector of 2D point correspondences (p,q) where q = Pose2::transformFrom(p) = t + R*p. <br /></td></tr>
<tr class="separator:aea758f150791443afe1191868963b4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3087e0c499ac0afa9a8be9ff96cb8336"><td class="memItemLeft" align="right" valign="top"><a id="a3087e0c499ac0afa9a8be9ff96cb8336" name="a3087e0c499ac0afa9a8be9ff96cb8336"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Point2Pairs</b> = std::vector&lt; <a class="el" href="a01596.html#aea758f150791443afe1191868963b4e1">Point2Pair</a> &gt;</td></tr>
<tr class="separator:a3087e0c499ac0afa9a8be9ff96cb8336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81fc38b03aa0f34ee1ea668aa7c3ac06"><td class="memItemLeft" align="right" valign="top"><a id="a81fc38b03aa0f34ee1ea668aa7c3ac06" name="a81fc38b03aa0f34ee1ea668aa7c3ac06"></a>
typedef std::vector&lt; <a class="el" href="a01596.html#a6ede8384dee0353a0ce5fb54ea50c21d">Point2</a>, Eigen::aligned_allocator&lt; <a class="el" href="a01596.html#a6ede8384dee0353a0ce5fb54ea50c21d">Point2</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Point2Vector</b></td></tr>
<tr class="separator:a81fc38b03aa0f34ee1ea668aa7c3ac06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8ed89fd60ea4601d9de63c4811525b"><td class="memItemLeft" align="right" valign="top"><a id="aaa8ed89fd60ea4601d9de63c4811525b" name="aaa8ed89fd60ea4601d9de63c4811525b"></a>
typedef Vector3&#160;</td><td class="memItemRight" valign="bottom"><b>Point3</b></td></tr>
<tr class="memdesc:aaa8ed89fd60ea4601d9de63c4811525b"><td class="mdescLeft">&#160;</td><td class="mdescRight">As of GTSAM 4, in order to make GTSAM more lean, it is now possible to just typedef Point3 to Vector3. <br /></td></tr>
<tr class="separator:aaa8ed89fd60ea4601d9de63c4811525b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3850c37e9efe4f9ffb33f498a57aae"><td class="memItemLeft" align="right" valign="top"><a id="a1f3850c37e9efe4f9ffb33f498a57aae" name="a1f3850c37e9efe4f9ffb33f498a57aae"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Point3Pair</b> = std::pair&lt; <a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a>, <a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a> &gt;</td></tr>
<tr class="separator:a1f3850c37e9efe4f9ffb33f498a57aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc865a05c20f76ef5d58c787214b234"><td class="memItemLeft" align="right" valign="top"><a id="a5bc865a05c20f76ef5d58c787214b234" name="a5bc865a05c20f76ef5d58c787214b234"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Point3Pairs</b> = std::vector&lt; Point3Pair &gt;</td></tr>
<tr class="separator:a5bc865a05c20f76ef5d58c787214b234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c5689134f4c912b280954720c02239"><td class="memItemLeft" align="right" valign="top"><a id="a47c5689134f4c912b280954720c02239" name="a47c5689134f4c912b280954720c02239"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Pose3Pair</b> = std::pair&lt; <a class="el" href="a03288.html">Pose3</a>, <a class="el" href="a03288.html">Pose3</a> &gt;</td></tr>
<tr class="separator:a47c5689134f4c912b280954720c02239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab22786e84be27eb82edf23051f1e4e"><td class="memItemLeft" align="right" valign="top"><a id="a3ab22786e84be27eb82edf23051f1e4e" name="a3ab22786e84be27eb82edf23051f1e4e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Pose3Pairs</b> = std::vector&lt; std::pair&lt; <a class="el" href="a03288.html">Pose3</a>, <a class="el" href="a03288.html">Pose3</a> &gt; &gt;</td></tr>
<tr class="separator:a3ab22786e84be27eb82edf23051f1e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129e0259e63b71905155066a55daedcd"><td class="memItemLeft" align="right" valign="top"><a id="a129e0259e63b71905155066a55daedcd" name="a129e0259e63b71905155066a55daedcd"></a>
typedef std::vector&lt; <a class="el" href="a03288.html">Pose3</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Pose3Vector</b></td></tr>
<tr class="separator:a129e0259e63b71905155066a55daedcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e2c1120d40da6062c03ab31e869065"><td class="memItemLeft" align="right" valign="top"><a id="a59e2c1120d40da6062c03ab31e869065" name="a59e2c1120d40da6062c03ab31e869065"></a>
typedef Eigen::Quaternion&lt; double, Eigen::DontAlign &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Quaternion</b></td></tr>
<tr class="separator:a59e2c1120d40da6062c03ab31e869065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2e8c622e65623a6853c84073bdb4f2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a3a2e8c622e65623a6853c84073bdb4f2">PinholeCameraCal3_S2</a> = <a class="el" href="a03212.html">gtsam::PinholeCamera</a>&lt; <a class="el" href="a03052.html">gtsam::Cal3_S2</a> &gt;</td></tr>
<tr class="memdesc:a3a2e8c622e65623a6853c84073bdb4f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient aliases for Pinhole camera classes with different calibrations.  <a href="a01596.html#a3a2e8c622e65623a6853c84073bdb4f2">More...</a><br /></td></tr>
<tr class="separator:a3a2e8c622e65623a6853c84073bdb4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095674a7836d08a894b0c11b34f692d5"><td class="memItemLeft" align="right" valign="top"><a id="a095674a7836d08a894b0c11b34f692d5" name="a095674a7836d08a894b0c11b34f692d5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>PinholeCameraCal3Bundler</b> = <a class="el" href="a03212.html">gtsam::PinholeCamera</a>&lt; <a class="el" href="a03076.html">gtsam::Cal3Bundler</a> &gt;</td></tr>
<tr class="separator:a095674a7836d08a894b0c11b34f692d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6059015283261a6c8c12d7fb6c08e512"><td class="memItemLeft" align="right" valign="top"><a id="a6059015283261a6c8c12d7fb6c08e512" name="a6059015283261a6c8c12d7fb6c08e512"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>PinholeCameraCal3DS2</b> = <a class="el" href="a03212.html">gtsam::PinholeCamera</a>&lt; <a class="el" href="a03088.html">gtsam::Cal3DS2</a> &gt;</td></tr>
<tr class="separator:a6059015283261a6c8c12d7fb6c08e512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d1adde00815ce95596a9f9ba9e6f54"><td class="memItemLeft" align="right" valign="top"><a id="ad5d1adde00815ce95596a9f9ba9e6f54" name="ad5d1adde00815ce95596a9f9ba9e6f54"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>PinholeCameraCal3Unified</b> = <a class="el" href="a03212.html">gtsam::PinholeCamera</a>&lt; <a class="el" href="a03116.html">gtsam::Cal3Unified</a> &gt;</td></tr>
<tr class="separator:ad5d1adde00815ce95596a9f9ba9e6f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4026e65ca995e7ab10b2432af0b02b43"><td class="memItemLeft" align="right" valign="top"><a id="a4026e65ca995e7ab10b2432af0b02b43" name="a4026e65ca995e7ab10b2432af0b02b43"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>PinholeCameraCal3Fisheye</b> = <a class="el" href="a03212.html">gtsam::PinholeCamera</a>&lt; <a class="el" href="a03104.html">gtsam::Cal3Fisheye</a> &gt;</td></tr>
<tr class="separator:a4026e65ca995e7ab10b2432af0b02b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7926e92fa1aa0e0f5cb55ffab7aa9911"><td class="memItemLeft" align="right" valign="top"><a id="a7926e92fa1aa0e0f5cb55ffab7aa9911" name="a7926e92fa1aa0e0f5cb55ffab7aa9911"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SO3</b> = <a class="el" href="a03396.html">SO</a>&lt; 3 &gt;</td></tr>
<tr class="separator:a7926e92fa1aa0e0f5cb55ffab7aa9911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02ae3a1dd17d2629f5638e107461232"><td class="memItemLeft" align="right" valign="top"><a id="ac02ae3a1dd17d2629f5638e107461232" name="ac02ae3a1dd17d2629f5638e107461232"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SO4</b> = <a class="el" href="a03396.html">SO</a>&lt; 4 &gt;</td></tr>
<tr class="separator:ac02ae3a1dd17d2629f5638e107461232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e6618f28accebf603ed3c196c706c9"><td class="memItemLeft" align="right" valign="top"><a id="a62e6618f28accebf603ed3c196c706c9" name="a62e6618f28accebf603ed3c196c706c9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SOn</b> = <a class="el" href="a03396.html">SO</a>&lt; Eigen::Dynamic &gt;</td></tr>
<tr class="separator:a62e6618f28accebf603ed3c196c706c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd963b7f5d336034b2b533e3abbb581"><td class="memItemLeft" align="right" valign="top"><a id="a3bd963b7f5d336034b2b533e3abbb581" name="a3bd963b7f5d336034b2b533e3abbb581"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>DynamicJacobian</b> = <a class="el" href="a02616.html">OptionalJacobian</a>&lt; Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="separator:a3bd963b7f5d336034b2b533e3abbb581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149dc71bfd2f69964eb40ceabd92af59"><td class="memItemLeft" align="right" valign="top"><a id="a149dc71bfd2f69964eb40ceabd92af59" name="a149dc71bfd2f69964eb40ceabd92af59"></a>
typedef std::vector&lt; <a class="el" href="a03428.html">StereoPoint2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>StereoPoint2Vector</b></td></tr>
<tr class="separator:a149dc71bfd2f69964eb40ceabd92af59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e21506e10855448d8c8f3cc9246416"><td class="memItemLeft" align="right" valign="top"><a id="a71e21506e10855448d8c8f3cc9246416" name="a71e21506e10855448d8c8f3cc9246416"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CameraSetCal3Bundler</b> = <a class="el" href="a03152.html">CameraSet</a>&lt; <a class="el" href="a03212.html">PinholeCamera</a>&lt; <a class="el" href="a03076.html">Cal3Bundler</a> &gt; &gt;</td></tr>
<tr class="separator:a71e21506e10855448d8c8f3cc9246416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8907b236e97ea5d991430ee8daf07139"><td class="memItemLeft" align="right" valign="top"><a id="a8907b236e97ea5d991430ee8daf07139" name="a8907b236e97ea5d991430ee8daf07139"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CameraSetCal3_S2</b> = <a class="el" href="a03152.html">CameraSet</a>&lt; <a class="el" href="a03212.html">PinholeCamera</a>&lt; <a class="el" href="a03052.html">Cal3_S2</a> &gt; &gt;</td></tr>
<tr class="separator:a8907b236e97ea5d991430ee8daf07139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66a4f0fd9c631e4d37fe5ec3cfe3feb"><td class="memItemLeft" align="right" valign="top"><a id="ac66a4f0fd9c631e4d37fe5ec3cfe3feb" name="ac66a4f0fd9c631e4d37fe5ec3cfe3feb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CameraSetCal3Fisheye</b> = <a class="el" href="a03152.html">CameraSet</a>&lt; <a class="el" href="a03212.html">PinholeCamera</a>&lt; <a class="el" href="a03104.html">Cal3Fisheye</a> &gt; &gt;</td></tr>
<tr class="separator:ac66a4f0fd9c631e4d37fe5ec3cfe3feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac183dae138857accc613c99a8abee2b7"><td class="memItemLeft" align="right" valign="top"><a id="ac183dae138857accc613c99a8abee2b7" name="ac183dae138857accc613c99a8abee2b7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CameraSetCal3Unified</b> = <a class="el" href="a03152.html">CameraSet</a>&lt; <a class="el" href="a03212.html">PinholeCamera</a>&lt; <a class="el" href="a03116.html">Cal3Unified</a> &gt; &gt;</td></tr>
<tr class="separator:ac183dae138857accc613c99a8abee2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e63c90a8ac740d99716e73fe97e054"><td class="memItemLeft" align="right" valign="top">typedef FastVector&lt; <a class="el" href="a01596.html#a19c53f2faabb0f4b4b78ce2f7168cc14">FactorIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a99e63c90a8ac740d99716e73fe97e054">FactorIndices</a></td></tr>
<tr class="memdesc:a99e63c90a8ac740d99716e73fe97e054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define collection types:  <a href="a01596.html#a99e63c90a8ac740d99716e73fe97e054">More...</a><br /></td></tr>
<tr class="separator:a99e63c90a8ac740d99716e73fe97e054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906613fce5832b78c1300f2403cce5c3"><td class="memItemLeft" align="right" valign="top"><a id="a906613fce5832b78c1300f2403cce5c3" name="a906613fce5832b78c1300f2403cce5c3"></a>
typedef <a class="el" href="a02488.html">FastSet</a>&lt; <a class="el" href="a01596.html#a19c53f2faabb0f4b4b78ce2f7168cc14">FactorIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>FactorIndexSet</b></td></tr>
<tr class="separator:a906613fce5832b78c1300f2403cce5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b4e8e7f0d745882c6a02b507d5bffe"><td class="memItemLeft" align="right" valign="top"><a id="ae4b4e8e7f0d745882c6a02b507d5bffe" name="ae4b4e8e7f0d745882c6a02b507d5bffe"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>KeyFormatter</b> = std::function&lt; std::string(<a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a>)&gt;</td></tr>
<tr class="memdesc:ae4b4e8e7f0d745882c6a02b507d5bffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a function to format a key, i.e. to convert it to a string. <br /></td></tr>
<tr class="separator:ae4b4e8e7f0d745882c6a02b507d5bffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c320e42b033352fbbd8266e3bd5faad"><td class="memItemLeft" align="right" valign="top"><a id="a1c320e42b033352fbbd8266e3bd5faad" name="a1c320e42b033352fbbd8266e3bd5faad"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>KeyVector</b> = FastVector&lt; <a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a> &gt;</td></tr>
<tr class="memdesc:a1c320e42b033352fbbd8266e3bd5faad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define collection type once and for all - also used in wrappers. <br /></td></tr>
<tr class="separator:a1c320e42b033352fbbd8266e3bd5faad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532c9cef244b5560606900c955c196fa"><td class="memItemLeft" align="right" valign="top"><a id="a532c9cef244b5560606900c955c196fa" name="a532c9cef244b5560606900c955c196fa"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>KeyList</b> = <a class="el" href="a02480.html">FastList</a>&lt; <a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a> &gt;</td></tr>
<tr class="separator:a532c9cef244b5560606900c955c196fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314dd3c1c42d7ffc8dc09eed593a684d"><td class="memItemLeft" align="right" valign="top"><a id="a314dd3c1c42d7ffc8dc09eed593a684d" name="a314dd3c1c42d7ffc8dc09eed593a684d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>KeySet</b> = <a class="el" href="a02488.html">FastSet</a>&lt; <a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a> &gt;</td></tr>
<tr class="separator:a314dd3c1c42d7ffc8dc09eed593a684d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4159dd2f6de52b9e47fc2b3531797ff2"><td class="memItemLeft" align="right" valign="top"><a id="a4159dd2f6de52b9e47fc2b3531797ff2" name="a4159dd2f6de52b9e47fc2b3531797ff2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>KeyGroupMap</b> = <a class="el" href="a02484.html">FastMap</a>&lt; <a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a>, int &gt;</td></tr>
<tr class="separator:a4159dd2f6de52b9e47fc2b3531797ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffcaa27b7f93273f420f7ff2a4f596a"><td class="memItemLeft" align="right" valign="top"><a id="acffcaa27b7f93273f420f7ff2a4f596a" name="acffcaa27b7f93273f420f7ff2a4f596a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Sparse</b> = Eigen::SparseMatrix&lt; double &gt;</td></tr>
<tr class="separator:acffcaa27b7f93273f420f7ff2a4f596a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab826fc898d16d52c60fbe6ad58e3282e"><td class="memItemLeft" align="right" valign="top"><a id="ab826fc898d16d52c60fbe6ad58e3282e" name="ab826fc898d16d52c60fbe6ad58e3282e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SparseTriplets</b> = std::vector&lt; std::tuple&lt; int, int, double &gt; &gt;</td></tr>
<tr class="separator:ab826fc898d16d52c60fbe6ad58e3282e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e5a4884342656e0837ef07008ec03f"><td class="memItemLeft" align="right" valign="top">typedef noiseModel::Base::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#ab6e5a4884342656e0837ef07008ec03f">SharedNoiseModel</a></td></tr>
<tr class="memdesc:ab6e5a4884342656e0837ef07008ec03f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Note, deliberately not in <a class="el" href="a01616.html" title="All noise models live in the noiseModel namespace.">noiseModel</a> namespace.  <a href="a01596.html#ab6e5a4884342656e0837ef07008ec03f">More...</a><br /></td></tr>
<tr class="separator:ab6e5a4884342656e0837ef07008ec03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78bc6f977e83dce647b2c006ea3dca5f"><td class="memItemLeft" align="right" valign="top"><a id="a78bc6f977e83dce647b2c006ea3dca5f" name="a78bc6f977e83dce647b2c006ea3dca5f"></a>
typedef noiseModel::Gaussian::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>SharedGaussian</b></td></tr>
<tr class="separator:a78bc6f977e83dce647b2c006ea3dca5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413190e269d694931cd6c69fafa7985a"><td class="memItemLeft" align="right" valign="top"><a id="a413190e269d694931cd6c69fafa7985a" name="a413190e269d694931cd6c69fafa7985a"></a>
typedef noiseModel::Diagonal::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>SharedDiagonal</b></td></tr>
<tr class="separator:a413190e269d694931cd6c69fafa7985a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62861a84dc6597e73a4d01cfbb36974"><td class="memItemLeft" align="right" valign="top"><a id="ac62861a84dc6597e73a4d01cfbb36974" name="ac62861a84dc6597e73a4d01cfbb36974"></a>
typedef noiseModel::Constrained::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>SharedConstrained</b></td></tr>
<tr class="separator:ac62861a84dc6597e73a4d01cfbb36974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca200c72f4453bdc0fa3341bd9ca6f3"><td class="memItemLeft" align="right" valign="top"><a id="a6ca200c72f4453bdc0fa3341bd9ca6f3" name="a6ca200c72f4453bdc0fa3341bd9ca6f3"></a>
typedef noiseModel::Isotropic::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>SharedIsotropic</b></td></tr>
<tr class="separator:a6ca200c72f4453bdc0fa3341bd9ca6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b9b28b076a8ae17d6d3d72ee1229c3"><td class="memItemLeft" align="right" valign="top">typedef Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a52b9b28b076a8ae17d6d3d72ee1229c3">SparseEigen</a></td></tr>
<tr class="memdesc:a52b9b28b076a8ae17d6d3d72ee1229c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigen-format sparse matrix.  <a href="a01596.html#a52b9b28b076a8ae17d6d3d72ee1229c3">More...</a><br /></td></tr>
<tr class="separator:a52b9b28b076a8ae17d6d3d72ee1229c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e2f1f46479338e7b2ff5380472527f"><td class="memItemLeft" align="right" valign="top"><a id="a64e2f1f46479338e7b2ff5380472527f" name="a64e2f1f46479338e7b2ff5380472527f"></a>
typedef <a class="el" href="a04140.html">ManifoldPreintegration</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PreintegrationType</b></td></tr>
<tr class="separator:a64e2f1f46479338e7b2ff5380472527f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608bc92c1270055bb0090123b93e3020"><td class="memItemLeft" align="right" valign="top"><a id="a608bc92c1270055bb0090123b93e3020" name="a608bc92c1270055bb0090123b93e3020"></a>
typedef <a class="el" href="a04240.html">Expression</a>&lt; <a class="el" href="a04144.html">NavState</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NavState_</b></td></tr>
<tr class="separator:a608bc92c1270055bb0090123b93e3020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb75c21527ba3a2671cd0d91d987d4a"><td class="memItemLeft" align="right" valign="top"><a id="abfb75c21527ba3a2671cd0d91d987d4a" name="abfb75c21527ba3a2671cd0d91d987d4a"></a>
typedef <a class="el" href="a04240.html">Expression</a>&lt; <a class="el" href="a01596.html#ad6ba0a40d5dd8936f4ca53f7bb3ef53b">Velocity3</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Velocity3_</b></td></tr>
<tr class="separator:abfb75c21527ba3a2671cd0d91d987d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ba0a40d5dd8936f4ca53f7bb3ef53b"><td class="memItemLeft" align="right" valign="top">typedef Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#ad6ba0a40d5dd8936f4ca53f7bb3ef53b">Velocity3</a></td></tr>
<tr class="memdesc:ad6ba0a40d5dd8936f4ca53f7bb3ef53b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Velocity is currently typedef'd to Vector3.  <a href="a01596.html#ad6ba0a40d5dd8936f4ca53f7bb3ef53b">More...</a><br /></td></tr>
<tr class="separator:ad6ba0a40d5dd8936f4ca53f7bb3ef53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20be9586f89827d772081e9b904b791"><td class="memItemLeft" align="right" valign="top"><a id="ad20be9586f89827d772081e9b904b791" name="ad20be9586f89827d772081e9b904b791"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>JacobianVector</b> = std::vector&lt; Matrix &gt;</td></tr>
<tr class="separator:ad20be9586f89827d772081e9b904b791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cea906509aed5310fbcf0ddb55b22f"><td class="memItemLeft" align="right" valign="top"><a id="a76cea906509aed5310fbcf0ddb55b22f" name="a76cea906509aed5310fbcf0ddb55b22f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CustomErrorFunction</b> = std::function&lt; Vector(const <a class="el" href="a04196.html">CustomFactor</a> &amp;, const <a class="el" href="a04560.html">Values</a> &amp;, const JacobianVector *)&gt;</td></tr>
<tr class="separator:a76cea906509aed5310fbcf0ddb55b22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12a676bb0c4fbe052753ced185f91d3"><td class="memItemLeft" align="right" valign="top"><a id="ad12a676bb0c4fbe052753ced185f91d3" name="ad12a676bb0c4fbe052753ced185f91d3"></a>
typedef internal::DoglegState&#160;</td><td class="memItemRight" valign="bottom"><b>State</b></td></tr>
<tr class="separator:ad12a676bb0c4fbe052753ced185f91d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd7f5e352e3603429fe4d3ea8682a01"><td class="memItemLeft" align="right" valign="top"><a id="a1cd7f5e352e3603429fe4d3ea8682a01" name="a1cd7f5e352e3603429fe4d3ea8682a01"></a>
typedef <a class="el" href="a04240.html">Expression</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Double_</b></td></tr>
<tr class="separator:a1cd7f5e352e3603429fe4d3ea8682a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86665a15ae69550dcd43b5a90d11e96"><td class="memItemLeft" align="right" valign="top"><a id="aa86665a15ae69550dcd43b5a90d11e96" name="aa86665a15ae69550dcd43b5a90d11e96"></a>
typedef <a class="el" href="a04240.html">Expression</a>&lt; Vector1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Vector1_</b></td></tr>
<tr class="separator:aa86665a15ae69550dcd43b5a90d11e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e097d7581e6d41f8079e97598688947"><td class="memItemLeft" align="right" valign="top"><a id="a2e097d7581e6d41f8079e97598688947" name="a2e097d7581e6d41f8079e97598688947"></a>
typedef <a class="el" href="a04240.html">Expression</a>&lt; Vector2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Vector2_</b></td></tr>
<tr class="separator:a2e097d7581e6d41f8079e97598688947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86350862f15854dd666e46e8ce21837a"><td class="memItemLeft" align="right" valign="top"><a id="a86350862f15854dd666e46e8ce21837a" name="a86350862f15854dd666e46e8ce21837a"></a>
typedef <a class="el" href="a04240.html">Expression</a>&lt; Vector3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Vector3_</b></td></tr>
<tr class="separator:a86350862f15854dd666e46e8ce21837a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15ff5b2398eba3de00088fdf61e77f2"><td class="memItemLeft" align="right" valign="top"><a id="ad15ff5b2398eba3de00088fdf61e77f2" name="ad15ff5b2398eba3de00088fdf61e77f2"></a>
typedef <a class="el" href="a04240.html">Expression</a>&lt; Vector4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Vector4_</b></td></tr>
<tr class="separator:ad15ff5b2398eba3de00088fdf61e77f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb948e33ad1d2d10c43582c4cb5b2cb1"><td class="memItemLeft" align="right" valign="top"><a id="adb948e33ad1d2d10c43582c4cb5b2cb1" name="adb948e33ad1d2d10c43582c4cb5b2cb1"></a>
typedef <a class="el" href="a04240.html">Expression</a>&lt; Vector5 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Vector5_</b></td></tr>
<tr class="separator:adb948e33ad1d2d10c43582c4cb5b2cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2521ef9343fc64e14fe171c4b557ed"><td class="memItemLeft" align="right" valign="top"><a id="aac2521ef9343fc64e14fe171c4b557ed" name="aac2521ef9343fc64e14fe171c4b557ed"></a>
typedef <a class="el" href="a04240.html">Expression</a>&lt; Vector6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Vector6_</b></td></tr>
<tr class="separator:aac2521ef9343fc64e14fe171c4b557ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc66d2686b9d8d1c52093287532a1a1"><td class="memItemLeft" align="right" valign="top"><a id="afcc66d2686b9d8d1c52093287532a1a1" name="afcc66d2686b9d8d1c52093287532a1a1"></a>
typedef <a class="el" href="a04240.html">Expression</a>&lt; Vector7 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Vector7_</b></td></tr>
<tr class="separator:afcc66d2686b9d8d1c52093287532a1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b181ee9ba4a2bb58ae5fc2250a3422"><td class="memItemLeft" align="right" valign="top"><a id="a12b181ee9ba4a2bb58ae5fc2250a3422" name="a12b181ee9ba4a2bb58ae5fc2250a3422"></a>
typedef <a class="el" href="a04240.html">Expression</a>&lt; Vector8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Vector8_</b></td></tr>
<tr class="separator:a12b181ee9ba4a2bb58ae5fc2250a3422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e8b86d987ecba0daea0ba71422c64e"><td class="memItemLeft" align="right" valign="top"><a id="a92e8b86d987ecba0daea0ba71422c64e" name="a92e8b86d987ecba0daea0ba71422c64e"></a>
typedef <a class="el" href="a04240.html">Expression</a>&lt; Vector9 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Vector9_</b></td></tr>
<tr class="separator:a92e8b86d987ecba0daea0ba71422c64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238e84a1d4a91f43465b12592a8bf8e4"><td class="memItemLeft" align="right" valign="top"><a id="a238e84a1d4a91f43465b12592a8bf8e4" name="a238e84a1d4a91f43465b12592a8bf8e4"></a>
typedef <a class="el" href="a02484.html">FastMap</a>&lt; char, Vector &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ISAM2ThresholdMap</b></td></tr>
<tr class="separator:a238e84a1d4a91f43465b12592a8bf8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8707b19ab1e617a8f20c6d68b6d310"><td class="memItemLeft" align="right" valign="top"><a id="a1b8707b19ab1e617a8f20c6d68b6d310" name="a1b8707b19ab1e617a8f20c6d68b6d310"></a>
typedef ISAM2ThresholdMap::value_type&#160;</td><td class="memItemRight" valign="bottom"><b>ISAM2ThresholdMapValue</b></td></tr>
<tr class="separator:a1b8707b19ab1e617a8f20c6d68b6d310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4579016a744c3d7adf227ea58623df7f"><td class="memItemLeft" align="right" valign="top"><a id="a4579016a744c3d7adf227ea58623df7f" name="a4579016a744c3d7adf227ea58623df7f"></a>
typedef <a class="el" href="a04496.html">NonlinearOptimizerParams</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SuccessiveLinearizationParams</b></td></tr>
<tr class="separator:a4579016a744c3d7adf227ea58623df7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a3f33080fb47337f36631a1ad73841"><td class="memItemLeft" align="right" valign="top"><a id="a72a3f33080fb47337f36631a1ad73841" name="a72a3f33080fb47337f36631a1ad73841"></a>
typedef std::map&lt; std::pair&lt; <a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a>, <a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a> &gt;, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>KeyPairDoubleMap</b></td></tr>
<tr class="separator:a72a3f33080fb47337f36631a1ad73841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886fc97169daab9f4355c29bc1bbe21d"><td class="memItemLeft" align="right" valign="top"><a id="a886fc97169daab9f4355c29bc1bbe21d" name="a886fc97169daab9f4355c29bc1bbe21d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ShonanAveragingParameters2</b> = <a class="el" href="a04648.html">ShonanAveragingParameters</a>&lt; 2 &gt;</td></tr>
<tr class="separator:a886fc97169daab9f4355c29bc1bbe21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df2dbcf06c109cddd823eeb11332365"><td class="memItemLeft" align="right" valign="top"><a id="a0df2dbcf06c109cddd823eeb11332365" name="a0df2dbcf06c109cddd823eeb11332365"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ShonanAveragingParameters3</b> = <a class="el" href="a04648.html">ShonanAveragingParameters</a>&lt; 3 &gt;</td></tr>
<tr class="separator:a0df2dbcf06c109cddd823eeb11332365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b8c97a91dd0aeb2b8ee6e3a2291f1c"><td class="memItemLeft" align="right" valign="top"><a id="ab5b8c97a91dd0aeb2b8ee6e3a2291f1c" name="ab5b8c97a91dd0aeb2b8ee6e3a2291f1c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ShonanFactor2</b> = <a class="el" href="a04664.html">ShonanFactor</a>&lt; 2 &gt;</td></tr>
<tr class="separator:ab5b8c97a91dd0aeb2b8ee6e3a2291f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13fc66ae4607e7fda82c1ac35ca123d0"><td class="memItemLeft" align="right" valign="top"><a id="a13fc66ae4607e7fda82c1ac35ca123d0" name="a13fc66ae4607e7fda82c1ac35ca123d0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ShonanFactor3</b> = <a class="el" href="a04664.html">ShonanFactor</a>&lt; 3 &gt;</td></tr>
<tr class="separator:a13fc66ae4607e7fda82c1ac35ca123d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b152c5da3cfcdbf775b39a4dda5646e"><td class="memTemplParams" colspan="2"><a id="a9b152c5da3cfcdbf775b39a4dda5646e" name="a9b152c5da3cfcdbf775b39a4dda5646e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b152c5da3cfcdbf775b39a4dda5646e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parser</b> = std::function&lt; boost::optional&lt; T &gt;(istream &amp;is, const string &amp;tag)&gt;</td></tr>
<tr class="separator:a9b152c5da3cfcdbf775b39a4dda5646e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41fc78bcb55de4f3cfe9f49c08e6857"><td class="memItemLeft" align="right" valign="top"><a id="ae41fc78bcb55de4f3cfe9f49c08e6857" name="ae41fc78bcb55de4f3cfe9f49c08e6857"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>BearingRange2D</b> = <a class="el" href="a03032.html">BearingRange</a>&lt; <a class="el" href="a03264.html">Pose2</a>, <a class="el" href="a01596.html#a6ede8384dee0353a0ce5fb54ea50c21d">Point2</a> &gt;</td></tr>
<tr class="separator:ae41fc78bcb55de4f3cfe9f49c08e6857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab764d13f9aaeafc2dc60763b05ec0e"><td class="memItemLeft" align="right" valign="top"><a id="a6ab764d13f9aaeafc2dc60763b05ec0e" name="a6ab764d13f9aaeafc2dc60763b05ec0e"></a>
typedef std::pair&lt; size_t, <a class="el" href="a03264.html">Pose2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>IndexedPose</b></td></tr>
<tr class="memdesc:a6ab764d13f9aaeafc2dc60763b05ec0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for auxiliary functions. <br /></td></tr>
<tr class="separator:a6ab764d13f9aaeafc2dc60763b05ec0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0d6e60ccd5785befc6e3a064abca6b"><td class="memItemLeft" align="right" valign="top"><a id="acd0d6e60ccd5785befc6e3a064abca6b" name="acd0d6e60ccd5785befc6e3a064abca6b"></a>
typedef std::pair&lt; size_t, <a class="el" href="a01596.html#a6ede8384dee0353a0ce5fb54ea50c21d">Point2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>IndexedLandmark</b></td></tr>
<tr class="separator:acd0d6e60ccd5785befc6e3a064abca6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8942a244fa6484bae3dbd861aa7b15"><td class="memItemLeft" align="right" valign="top"><a id="abc8942a244fa6484bae3dbd861aa7b15" name="abc8942a244fa6484bae3dbd861aa7b15"></a>
typedef std::pair&lt; std::pair&lt; size_t, size_t &gt;, <a class="el" href="a03264.html">Pose2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>IndexedEdge</b></td></tr>
<tr class="separator:abc8942a244fa6484bae3dbd861aa7b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc5d1ec05ddc954d5de28929acabbdf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#abcc5d1ec05ddc954d5de28929acabbdf">GraphAndValues</a> = std::pair&lt; NonlinearFactorGraph::shared_ptr, <a class="el" href="a04560.html#a5b2f07b6054d9ea06b28876a057938d1">Values::shared_ptr</a> &gt;</td></tr>
<tr class="memdesc:abcc5d1ec05ddc954d5de28929acabbdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for load functions, which return a graph and initial values.  <a href="a01596.html#abcc5d1ec05ddc954d5de28929acabbdf">More...</a><br /></td></tr>
<tr class="separator:abcc5d1ec05ddc954d5de28929acabbdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad7940245bbbf4bf25d1dc4690b0108"><td class="memItemLeft" align="right" valign="top"><a id="a9ad7940245bbbf4bf25d1dc4690b0108" name="a9ad7940245bbbf4bf25d1dc4690b0108"></a>
typedef std::pair&lt; size_t, <a class="el" href="a01596.html#a6ede8384dee0353a0ce5fb54ea50c21d">Point2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SfmMeasurement</b></td></tr>
<tr class="memdesc:a9ad7940245bbbf4bf25d1dc4690b0108"><td class="mdescLeft">&#160;</td><td class="mdescRight">A measurement with its camera index. <br /></td></tr>
<tr class="separator:a9ad7940245bbbf4bf25d1dc4690b0108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a02e01a9608ce6cade24c1366b208c"><td class="memItemLeft" align="right" valign="top"><a id="a21a02e01a9608ce6cade24c1366b208c" name="a21a02e01a9608ce6cade24c1366b208c"></a>
typedef std::pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SiftIndex</b></td></tr>
<tr class="memdesc:a21a02e01a9608ce6cade24c1366b208c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sift index for <a class="el" href="a04728.html" title="Define the structure for the 3D points.">SfmTrack</a>. <br /></td></tr>
<tr class="separator:a21a02e01a9608ce6cade24c1366b208c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab0207730cf78822bdf274b50739d31"><td class="memItemLeft" align="right" valign="top"><a id="acab0207730cf78822bdf274b50739d31" name="acab0207730cf78822bdf274b50739d31"></a>
typedef <a class="el" href="a03212.html">PinholeCamera</a>&lt; <a class="el" href="a03076.html">Cal3Bundler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SfmCamera</b></td></tr>
<tr class="memdesc:acab0207730cf78822bdf274b50739d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the structure for the camera poses. <br /></td></tr>
<tr class="separator:acab0207730cf78822bdf274b50739d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8d9b6d81e5b15efd6b29ef8642f12a"><td class="memItemLeft" align="right" valign="top"><a id="a2d8d9b6d81e5b15efd6b29ef8642f12a" name="a2d8d9b6d81e5b15efd6b29ef8642f12a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>BetweenFactorPose2s</b> = std::vector&lt; <a class="el" href="a04684.html">BetweenFactor</a>&lt; <a class="el" href="a03264.html">Pose2</a> &gt;::shared_ptr &gt;</td></tr>
<tr class="separator:a2d8d9b6d81e5b15efd6b29ef8642f12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc513249171f8866cfa9a4b6af8a138"><td class="memItemLeft" align="right" valign="top"><a id="adcc513249171f8866cfa9a4b6af8a138" name="adcc513249171f8866cfa9a4b6af8a138"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>BetweenFactorPose3s</b> = std::vector&lt; <a class="el" href="a04684.html">BetweenFactor</a>&lt; <a class="el" href="a03288.html">Pose3</a> &gt;::shared_ptr &gt;</td></tr>
<tr class="separator:adcc513249171f8866cfa9a4b6af8a138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22616d2ac78e3f889df890db94171271"><td class="memItemLeft" align="right" valign="top"><a id="a22616d2ac78e3f889df890db94171271" name="a22616d2ac78e3f889df890db94171271"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>BinaryMeasurementsUnit3</b> = std::vector&lt; <a class="el" href="a04632.html">BinaryMeasurement</a>&lt; <a class="el" href="a03460.html">Unit3</a> &gt; &gt;</td></tr>
<tr class="separator:a22616d2ac78e3f889df890db94171271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b07e99cf56b487ec1a719a9e79e9b57"><td class="memItemLeft" align="right" valign="top"><a id="a3b07e99cf56b487ec1a719a9e79e9b57" name="a3b07e99cf56b487ec1a719a9e79e9b57"></a>
typedef <a class="el" href="a04240.html">Expression</a>&lt; <a class="el" href="a01596.html#a6ede8384dee0353a0ce5fb54ea50c21d">Point2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Point2_</b></td></tr>
<tr class="separator:a3b07e99cf56b487ec1a719a9e79e9b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ffa584448152fa8c51b03b6f66c58b"><td class="memItemLeft" align="right" valign="top"><a id="a15ffa584448152fa8c51b03b6f66c58b" name="a15ffa584448152fa8c51b03b6f66c58b"></a>
typedef <a class="el" href="a04240.html">Expression</a>&lt; <a class="el" href="a03320.html">Rot2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Rot2_</b></td></tr>
<tr class="separator:a15ffa584448152fa8c51b03b6f66c58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac792cfe7a1f796e87d6a320d23e3329a"><td class="memItemLeft" align="right" valign="top"><a id="ac792cfe7a1f796e87d6a320d23e3329a" name="ac792cfe7a1f796e87d6a320d23e3329a"></a>
typedef <a class="el" href="a04240.html">Expression</a>&lt; <a class="el" href="a03264.html">Pose2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Pose2_</b></td></tr>
<tr class="separator:ac792cfe7a1f796e87d6a320d23e3329a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef400fe2f201884abb2d792cea691970"><td class="memItemLeft" align="right" valign="top"><a id="aef400fe2f201884abb2d792cea691970" name="aef400fe2f201884abb2d792cea691970"></a>
typedef <a class="el" href="a04240.html">Expression</a>&lt; <a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Point3_</b></td></tr>
<tr class="separator:aef400fe2f201884abb2d792cea691970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f824462ff529030857e6c80df2a6244"><td class="memItemLeft" align="right" valign="top"><a id="a7f824462ff529030857e6c80df2a6244" name="a7f824462ff529030857e6c80df2a6244"></a>
typedef <a class="el" href="a04240.html">Expression</a>&lt; <a class="el" href="a03460.html">Unit3</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Unit3_</b></td></tr>
<tr class="separator:a7f824462ff529030857e6c80df2a6244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b75d018c9acc2810e92a0df412c7dc"><td class="memItemLeft" align="right" valign="top"><a id="a41b75d018c9acc2810e92a0df412c7dc" name="a41b75d018c9acc2810e92a0df412c7dc"></a>
typedef <a class="el" href="a04240.html">Expression</a>&lt; <a class="el" href="a03336.html">Rot3</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Rot3_</b></td></tr>
<tr class="separator:a41b75d018c9acc2810e92a0df412c7dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3500f02523d7b0494d76ff461156127f"><td class="memItemLeft" align="right" valign="top"><a id="a3500f02523d7b0494d76ff461156127f" name="a3500f02523d7b0494d76ff461156127f"></a>
typedef <a class="el" href="a04240.html">Expression</a>&lt; <a class="el" href="a03288.html">Pose3</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Pose3_</b></td></tr>
<tr class="separator:a3500f02523d7b0494d76ff461156127f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac892a551f52fb94a71b5bd1877d9a779"><td class="memItemLeft" align="right" valign="top"><a id="ac892a551f52fb94a71b5bd1877d9a779" name="ac892a551f52fb94a71b5bd1877d9a779"></a>
typedef <a class="el" href="a04240.html">Expression</a>&lt; <a class="el" href="a03188.html">Line3</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Line3_</b></td></tr>
<tr class="separator:ac892a551f52fb94a71b5bd1877d9a779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3bf33d0dec3c6c1410a394c74d2969"><td class="memItemLeft" align="right" valign="top"><a id="a6e3bf33d0dec3c6c1410a394c74d2969" name="a6e3bf33d0dec3c6c1410a394c74d2969"></a>
typedef <a class="el" href="a04240.html">Expression</a>&lt; <a class="el" href="a03052.html">Cal3_S2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Cal3_S2_</b></td></tr>
<tr class="separator:a6e3bf33d0dec3c6c1410a394c74d2969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd234b18b0c2ba86670537391e9ccec"><td class="memItemLeft" align="right" valign="top"><a id="aacd234b18b0c2ba86670537391e9ccec" name="aacd234b18b0c2ba86670537391e9ccec"></a>
typedef <a class="el" href="a04240.html">Expression</a>&lt; <a class="el" href="a03076.html">Cal3Bundler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Cal3Bundler_</b></td></tr>
<tr class="separator:aacd234b18b0c2ba86670537391e9ccec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba19197780021a87081d61ff4234bad1"><td class="memItemLeft" align="right" valign="top"><a id="aba19197780021a87081d61ff4234bad1" name="aba19197780021a87081d61ff4234bad1"></a>
typedef std::map&lt; <a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a>, std::vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>KeyVectorMap</b></td></tr>
<tr class="separator:aba19197780021a87081d61ff4234bad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30cc9ae4cb9a4f49912bdfa27d9dca8"><td class="memItemLeft" align="right" valign="top"><a id="ac30cc9ae4cb9a4f49912bdfa27d9dca8" name="ac30cc9ae4cb9a4f49912bdfa27d9dca8"></a>
typedef std::map&lt; <a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a>, <a class="el" href="a03336.html">Rot3</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>KeyRotMap</b></td></tr>
<tr class="separator:ac30cc9ae4cb9a4f49912bdfa27d9dca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7adadd64e2b0e372178a26cbe8c90b8"><td class="memItemLeft" align="right" valign="top"><a id="ae7adadd64e2b0e372178a26cbe8c90b8" name="ae7adadd64e2b0e372178a26cbe8c90b8"></a>
typedef <a class="el" href="a04988.html">DSF</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>DSFInt</b></td></tr>
<tr class="separator:ae7adadd64e2b0e372178a26cbe8c90b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0578f47f37687b0d22498171f320cf0"><td class="memItemLeft" align="right" valign="top"><a id="ac0578f47f37687b0d22498171f320cf0" name="ac0578f47f37687b0d22498171f320cf0"></a>
typedef Eigen::RowVectorXd&#160;</td><td class="memItemRight" valign="bottom"><b>RowVector</b></td></tr>
<tr class="separator:ac0578f47f37687b0d22498171f320cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e7423b122a2ac2a9ba1a07546516a5"><td class="memItemLeft" align="right" valign="top"><a id="a56e7423b122a2ac2a9ba1a07546516a5" name="a56e7423b122a2ac2a9ba1a07546516a5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>KeyDimMap</b> = std::map&lt; <a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a>, size_t &gt;</td></tr>
<tr class="memdesc:a56e7423b122a2ac2a9ba1a07546516a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapping between variable's key and its corresponding dimensionality. <br /></td></tr>
<tr class="separator:a56e7423b122a2ac2a9ba1a07546516a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b344bccc4c58ea2315b112488b39ac"><td class="memItemLeft" align="right" valign="top"><a id="a62b344bccc4c58ea2315b112488b39ac" name="a62b344bccc4c58ea2315b112488b39ac"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LPSolver</b> = <a class="el" href="a05032.html">ActiveSetSolver</a>&lt; <a class="el" href="a05088.html">LP</a>, <a class="el" href="a05100.html">LPPolicy</a>, <a class="el" href="a05096.html">LPInitSolver</a> &gt;</td></tr>
<tr class="separator:a62b344bccc4c58ea2315b112488b39ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476de6480f6c27e5660536b93d740610"><td class="memItemLeft" align="right" valign="top"><a id="a476de6480f6c27e5660536b93d740610" name="a476de6480f6c27e5660536b93d740610"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>QPSolver</b> = <a class="el" href="a05032.html">ActiveSetSolver</a>&lt; <a class="el" href="a05104.html">QP</a>, <a class="el" href="a05112.html">QPPolicy</a>, <a class="el" href="a05108.html">QPInitSolver</a> &gt;</td></tr>
<tr class="separator:a476de6480f6c27e5660536b93d740610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c213e1e9138b45ea5a2ecfc047803d5"><td class="memItemLeft" align="right" valign="top"><a id="a7c213e1e9138b45ea5a2ecfc047803d5" name="a7c213e1e9138b45ea5a2ecfc047803d5"></a>
typedef qi::grammar&lt; boost::spirit::basic_istream_iterator&lt; char &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>base_grammar</b></td></tr>
<tr class="separator:a7c213e1e9138b45ea5a2ecfc047803d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e3e10fd7b2e4e28d57370b8ee63c75"><td class="memItemLeft" align="right" valign="top"><a id="a48e3e10fd7b2e4e28d57370b8ee63c75" name="a48e3e10fd7b2e4e28d57370b8ee63c75"></a>
typedef <a class="el" href="a05140.html">ConcurrentBatchFilter::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ConcurrentBatchFilterResult</b></td></tr>
<tr class="memdesc:a48e3e10fd7b2e4e28d57370b8ee63c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for Matlab wrapping. <br /></td></tr>
<tr class="separator:a48e3e10fd7b2e4e28d57370b8ee63c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630a70c8307aedd4cca4556d751581ff"><td class="memItemLeft" align="right" valign="top"><a id="a630a70c8307aedd4cca4556d751581ff" name="a630a70c8307aedd4cca4556d751581ff"></a>
typedef <a class="el" href="a05152.html">ConcurrentBatchSmoother::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ConcurrentBatchSmootherResult</b></td></tr>
<tr class="memdesc:a630a70c8307aedd4cca4556d751581ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for Matlab wrapping. <br /></td></tr>
<tr class="separator:a630a70c8307aedd4cca4556d751581ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ade83ffa0c2e87948350a487bc986a"><td class="memItemLeft" align="right" valign="top"><a id="a86ade83ffa0c2e87948350a487bc986a" name="a86ade83ffa0c2e87948350a487bc986a"></a>
typedef <a class="el" href="a05172.html">ConcurrentIncrementalFilter::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ConcurrentIncrementalFilterResult</b></td></tr>
<tr class="memdesc:a86ade83ffa0c2e87948350a487bc986a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for Matlab wrapping. <br /></td></tr>
<tr class="separator:a86ade83ffa0c2e87948350a487bc986a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c68e081eba4a337a9e97a11cfb1bdc"><td class="memItemLeft" align="right" valign="top"><a id="ab1c68e081eba4a337a9e97a11cfb1bdc" name="ab1c68e081eba4a337a9e97a11cfb1bdc"></a>
typedef <a class="el" href="a05184.html">ConcurrentIncrementalSmoother::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ConcurrentIncrementalSmootherResult</b></td></tr>
<tr class="memdesc:ab1c68e081eba4a337a9e97a11cfb1bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for Matlab wrapping. <br /></td></tr>
<tr class="separator:ab1c68e081eba4a337a9e97a11cfb1bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a302ee683dae9b50409588c07669d7"><td class="memItemLeft" align="right" valign="top"><a id="aa2a302ee683dae9b50409588c07669d7" name="aa2a302ee683dae9b50409588c07669d7"></a>
typedef <a class="el" href="a05192.html#a7778c79a5998ac7c1768ebc1fba2e76f">FixedLagSmoother::KeyTimestampMap</a>&#160;</td><td class="memItemRight" valign="bottom"><b>FixedLagSmootherKeyTimestampMap</b></td></tr>
<tr class="memdesc:aa2a302ee683dae9b50409588c07669d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for matlab wrapping. <br /></td></tr>
<tr class="separator:aa2a302ee683dae9b50409588c07669d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11ead0b05c240ae6de08f3d6543282b"><td class="memItemLeft" align="right" valign="top"><a id="ae11ead0b05c240ae6de08f3d6543282b" name="ae11ead0b05c240ae6de08f3d6543282b"></a>
typedef FixedLagSmootherKeyTimestampMap::value_type&#160;</td><td class="memItemRight" valign="bottom"><b>FixedLagSmootherKeyTimestampMapValue</b></td></tr>
<tr class="separator:ae11ead0b05c240ae6de08f3d6543282b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6c89568ae310c6ccd4b5f5b43bfecc"><td class="memItemLeft" align="right" valign="top"><a id="aae6c89568ae310c6ccd4b5f5b43bfecc" name="aae6c89568ae310c6ccd4b5f5b43bfecc"></a>
typedef <a class="el" href="a05196.html">FixedLagSmoother::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><b>FixedLagSmootherResult</b></td></tr>
<tr class="separator:aae6c89568ae310c6ccd4b5f5b43bfecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a76f325ee1e8eb4fd8a0f6b769d0c6"><td class="memItemLeft" align="right" valign="top"><a id="a16a76f325ee1e8eb4fd8a0f6b769d0c6" name="a16a76f325ee1e8eb4fd8a0f6b769d0c6"></a>
typedef <a class="el" href="a04868.html">SmartProjectionParams</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SmartStereoProjectionParams</b></td></tr>
<tr class="separator:a16a76f325ee1e8eb4fd8a0f6b769d0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a7527de605f5b7c0224c97b5312d816e8"><td class="memItemLeft" align="right" valign="top"><a id="a7527de605f5b7c0224c97b5312d816e8" name="a7527de605f5b7c0224c97b5312d816e8"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a7527de605f5b7c0224c97b5312d816e8">GncLossType</a> { <b>GM</b>
, <b>TLS</b>
 }</td></tr>
<tr class="memdesc:a7527de605f5b7c0224c97b5312d816e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choice of robust loss function for GNC. <br /></td></tr>
<tr class="separator:a7527de605f5b7c0224c97b5312d816e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90552b70a2da9c74595cae4b05c2ce18"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a90552b70a2da9c74595cae4b05c2ce18">NoiseFormat</a> { <br />
&#160;&#160;<a class="el" href="a01596.html#a90552b70a2da9c74595cae4b05c2ce18ad0aaa5c51a45cb7c9151aae60a603209">NoiseFormatG2O</a>
, <a class="el" href="a01596.html#a90552b70a2da9c74595cae4b05c2ce18a3790bc2c6f11cd7da84730b33173de5a">NoiseFormatTORO</a>
, <a class="el" href="a01596.html#a90552b70a2da9c74595cae4b05c2ce18a1f8edeb25c58a249789556c686265a4c">NoiseFormatGRAPH</a>
, <a class="el" href="a01596.html#a90552b70a2da9c74595cae4b05c2ce18a5450a16f3522214ccdfa23c461e7d05a">NoiseFormatCOV</a>
, <br />
&#160;&#160;<a class="el" href="a01596.html#a90552b70a2da9c74595cae4b05c2ce18a2f9067b8f5bd2d0dd38c49326a4c070e">NoiseFormatAUTO</a>
<br />
 }</td></tr>
<tr class="memdesc:a90552b70a2da9c74595cae4b05c2ce18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates how noise parameters are stored in file.  <a href="a01596.html#a90552b70a2da9c74595cae4b05c2ce18">More...</a><br /></td></tr>
<tr class="separator:a90552b70a2da9c74595cae4b05c2ce18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be373f34edc0a9d28b1bfab5dd62ba0"><td class="memItemLeft" align="right" valign="top"><a id="a8be373f34edc0a9d28b1bfab5dd62ba0" name="a8be373f34edc0a9d28b1bfab5dd62ba0"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a8be373f34edc0a9d28b1bfab5dd62ba0">KernelFunctionType</a> { <b>KernelFunctionTypeNONE</b>
, <b>KernelFunctionTypeHUBER</b>
, <b>KernelFunctionTypeTUKEY</b>
 }</td></tr>
<tr class="memdesc:a8be373f34edc0a9d28b1bfab5dd62ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Robust kernel type to wrap around quadratic noise model. <br /></td></tr>
<tr class="separator:a8be373f34edc0a9d28b1bfab5dd62ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2020f3f6087064dde501c99794aac3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#adf2020f3f6087064dde501c99794aac3">LinearizationMode</a> { <b>HESSIAN</b>
, <b>IMPLICIT_SCHUR</b>
, <b>JACOBIAN_Q</b>
, <b>JACOBIAN_SVD</b>
 }</td></tr>
<tr class="memdesc:adf2020f3f6087064dde501c99794aac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">SmartFactorParams: parameters and (linearization/degeneracy) modes for SmartProjection and SmartStereoProjection factors.  <a href="a01596.html#adf2020f3f6087064dde501c99794aac3">More...</a><br /></td></tr>
<tr class="separator:adf2020f3f6087064dde501c99794aac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d021280c8a8b84903a8ce81f73ea0f"><td class="memItemLeft" align="right" valign="top"><a id="ac3d021280c8a8b84903a8ce81f73ea0f" name="ac3d021280c8a8b84903a8ce81f73ea0f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#ac3d021280c8a8b84903a8ce81f73ea0f">DegeneracyMode</a> { <b>IGNORE_DEGENERACY</b>
, <b>ZERO_ON_DEGENERACY</b>
, <b>HANDLE_INFINITY</b>
 }</td></tr>
<tr class="memdesc:ac3d021280c8a8b84903a8ce81f73ea0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">How to manage degeneracy. <br /></td></tr>
<tr class="separator:ac3d021280c8a8b84903a8ce81f73ea0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aee5d6a3cdab1e2c6173fa9dd0c15b9dd"><td class="memTemplParams" colspan="2"><a id="aee5d6a3cdab1e2c6173fa9dd0c15b9dd" name="aee5d6a3cdab1e2c6173fa9dd0c15b9dd"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aee5d6a3cdab1e2c6173fa9dd0c15b9dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>testDefaultChart</b> (TestResult &amp;result_, const std::string &amp;name_, const T &amp;value)</td></tr>
<tr class="separator:aee5d6a3cdab1e2c6173fa9dd0c15b9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747683f736c50bca16b3aab0e95b1b76"><td class="memItemLeft" align="right" valign="top">pair&lt; size_t, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a747683f736c50bca16b3aab0e95b1b76">choleskyCareful</a> (Matrix &amp;ATA, int order=-1)</td></tr>
<tr class="memdesc:a747683f736c50bca16b3aab0e95b1b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Careful" Cholesky computes the positive square-root of a positive symmetric semi-definite matrix (i.e.  <a href="a01596.html#a747683f736c50bca16b3aab0e95b1b76">More...</a><br /></td></tr>
<tr class="separator:a747683f736c50bca16b3aab0e95b1b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe82fa6aceccfa2360cf314ab44f39ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#abe82fa6aceccfa2360cf314ab44f39ad">choleskyPartial</a> (Matrix &amp;ABC, size_t nFrontal, size_t topleft=0)</td></tr>
<tr class="memdesc:abe82fa6aceccfa2360cf314ab44f39ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial Cholesky computes a factor [R S such that [R' 0 [R S = [A B 0 L] S' I] 0 L] B' C].  <a href="a01596.html#abe82fa6aceccfa2360cf314ab44f39ad">More...</a><br /></td></tr>
<tr class="separator:abe82fa6aceccfa2360cf314ab44f39ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad795393f0c5cabf9b56c337700b5b4ad"><td class="memItemLeft" align="right" valign="top"><a id="ad795393f0c5cabf9b56c337700b5b4ad" name="ad795393f0c5cabf9b56c337700b5b4ad"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>guardedIsDebug</b> (const std::string &amp;s)</td></tr>
<tr class="separator:ad795393f0c5cabf9b56c337700b5b4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146cbcf83a545afa692d6d84dfba68c2"><td class="memItemLeft" align="right" valign="top"><a id="a146cbcf83a545afa692d6d84dfba68c2" name="a146cbcf83a545afa692d6d84dfba68c2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>guardedSetDebug</b> (const std::string &amp;s, const bool v)</td></tr>
<tr class="separator:a146cbcf83a545afa692d6d84dfba68c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7445e057a644b5bd2b51f03f04049b70"><td class="memItemLeft" align="right" valign="top"><a id="a7445e057a644b5bd2b51f03f04049b70" name="a7445e057a644b5bd2b51f03f04049b70"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isDebugVersion</b> ()</td></tr>
<tr class="separator:a7445e057a644b5bd2b51f03f04049b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7c15222eaeb30c50aa9c485c13cd8d"><td class="memItemLeft" align="right" valign="top"><a id="afc7c15222eaeb30c50aa9c485c13cd8d" name="afc7c15222eaeb30c50aa9c485c13cd8d"></a>
IndexPairVector&#160;</td><td class="memItemRight" valign="bottom"><b>IndexPairSetAsArray</b> (IndexPairSet &amp;set)</td></tr>
<tr class="separator:afc7c15222eaeb30c50aa9c485c13cd8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7aea35c31bdd409313b52d451b18649"><td class="memTemplParams" colspan="2"><a id="ae7aea35c31bdd409313b52d451b18649" name="ae7aea35c31bdd409313b52d451b18649"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae7aea35c31bdd409313b52d451b18649"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02492.html">GenericValue</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>genericValue</b> (const T &amp;v)</td></tr>
<tr class="memdesc:ae7aea35c31bdd409313b52d451b18649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functional constructor of GenericValue&lt;T&gt; so T can be automatically deduced. <br /></td></tr>
<tr class="separator:ae7aea35c31bdd409313b52d451b18649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e95b5b5508cf3284107e979401bd1a4"><td class="memTemplParams" colspan="2"><a id="a2e95b5b5508cf3284107e979401bd1a4" name="a2e95b5b5508cf3284107e979401bd1a4"></a>
template&lt;typename G &gt; </td></tr>
<tr class="memitem:a2e95b5b5508cf3284107e979401bd1a4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BOOST_CONCEPT_REQUIRES</b> (((<a class="el" href="a02512.html">IsGroup</a>&lt; G &gt;)),(bool)) check_group_invariants(const G &amp;a</td></tr>
<tr class="memdesc:a2e95b5b5508cf3284107e979401bd1a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check invariants. <br /></td></tr>
<tr class="separator:a2e95b5b5508cf3284107e979401bd1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd92914d0822d42584d46f31fb500048"><td class="memTemplParams" colspan="2">template&lt;class Class &gt; </td></tr>
<tr class="memitem:abd92914d0822d42584d46f31fb500048"><td class="memTemplItemLeft" align="right" valign="top">Class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#abd92914d0822d42584d46f31fb500048">between_default</a> (const Class &amp;l1, const Class &amp;l2)</td></tr>
<tr class="memdesc:abd92914d0822d42584d46f31fb500048"><td class="mdescLeft">&#160;</td><td class="mdescRight">These core global functions can be specialized by new Lie types for better performance.  <a href="a01596.html#abd92914d0822d42584d46f31fb500048">More...</a><br /></td></tr>
<tr class="separator:abd92914d0822d42584d46f31fb500048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6ccec4a3ea452361c0956766bccef5"><td class="memTemplParams" colspan="2">template&lt;class Class &gt; </td></tr>
<tr class="memitem:a5c6ccec4a3ea452361c0956766bccef5"><td class="memTemplItemLeft" align="right" valign="top">Vector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a5c6ccec4a3ea452361c0956766bccef5">logmap_default</a> (const Class &amp;l0, const Class &amp;lp)</td></tr>
<tr class="memdesc:a5c6ccec4a3ea452361c0956766bccef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log map centered at l0, s.t.  <a href="a01596.html#a5c6ccec4a3ea452361c0956766bccef5">More...</a><br /></td></tr>
<tr class="separator:a5c6ccec4a3ea452361c0956766bccef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a7c0a7422c38a0baa131c073e233ac"><td class="memTemplParams" colspan="2">template&lt;class Class &gt; </td></tr>
<tr class="memitem:af5a7c0a7422c38a0baa131c073e233ac"><td class="memTemplItemLeft" align="right" valign="top">Class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#af5a7c0a7422c38a0baa131c073e233ac">expmap_default</a> (const Class &amp;t, const Vector &amp;d)</td></tr>
<tr class="memdesc:af5a7c0a7422c38a0baa131c073e233ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exponential map centered at l0, s.t.  <a href="a01596.html#af5a7c0a7422c38a0baa131c073e233ac">More...</a><br /></td></tr>
<tr class="separator:af5a7c0a7422c38a0baa131c073e233ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd55c711e6ceee791b595558eb3ec8a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adbd55c711e6ceee791b595558eb3ec8a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#adbd55c711e6ceee791b595558eb3ec8a">BCH</a> (const T &amp;X, const T &amp;Y)</td></tr>
<tr class="memdesc:adbd55c711e6ceee791b595558eb3ec8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three term approximation of the Baker-Campbell-Hausdorff formula In non-commutative Lie groups, when composing exp(Z) = exp(X)exp(Y) it is not true that Z = X+Y.  <a href="a01596.html#adbd55c711e6ceee791b595558eb3ec8a">More...</a><br /></td></tr>
<tr class="separator:adbd55c711e6ceee791b595558eb3ec8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe28b7f8e3592fb9f5cf9ebae09497ba"><td class="memTemplParams" colspan="2"><a id="afe28b7f8e3592fb9f5cf9ebae09497ba" name="afe28b7f8e3592fb9f5cf9ebae09497ba"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:afe28b7f8e3592fb9f5cf9ebae09497ba"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>wedge</b> (const Vector &amp;x)</td></tr>
<tr class="memdesc:afe28b7f8e3592fb9f5cf9ebae09497ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of wedge (see Murray94book) used to convert from n exponential coordinates to n*n element of the Lie algebra. <br /></td></tr>
<tr class="separator:afe28b7f8e3592fb9f5cf9ebae09497ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3041816208c79ef76d3ef2e0991d90b2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3041816208c79ef76d3ef2e0991d90b2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a3041816208c79ef76d3ef2e0991d90b2">expm</a> (const Vector &amp;x, int K=7)</td></tr>
<tr class="memdesc:a3041816208c79ef76d3ef2e0991d90b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exponential map given exponential coordinates class T needs a wedge&lt;&gt; function and a constructor from Matrix.  <a href="a01596.html#a3041816208c79ef76d3ef2e0991d90b2">More...</a><br /></td></tr>
<tr class="separator:a3041816208c79ef76d3ef2e0991d90b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf06b04fa93b050e99bc3d571d85d53"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adaf06b04fa93b050e99bc3d571d85d53"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#adaf06b04fa93b050e99bc3d571d85d53">interpolate</a> (const T &amp;X, const T &amp;Y, double t, typename <a class="el" href="a02628.html">MakeOptionalJacobian</a>&lt; T, T &gt;::type Hx=boost::none, typename <a class="el" href="a02628.html">MakeOptionalJacobian</a>&lt; T, T &gt;::type Hy=boost::none)</td></tr>
<tr class="memdesc:adaf06b04fa93b050e99bc3d571d85d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear interpolation between X and Y by coefficient t.  <a href="a01596.html#adaf06b04fa93b050e99bc3d571d85d53">More...</a><br /></td></tr>
<tr class="separator:adaf06b04fa93b050e99bc3d571d85d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb9ece2bd206193ac40f118f1815c0e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ... Args&gt; </td></tr>
<tr class="memitem:abcb9ece2bd206193ac40f118f1815c0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01596.html#a47e06cd29f4e8a20a8a7842e4045845f">gtsam::enable_if_t</a>&lt; <a class="el" href="a02728.html">needs_eigen_aligned_allocator</a>&lt; T &gt;::value, boost::shared_ptr&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#abcb9ece2bd206193ac40f118f1815c0e">make_shared</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:abcb9ece2bd206193ac40f118f1815c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add our own <code>make_shared</code> as a layer of wrapping on <code>boost::make_shared</code> This solves the problem with the stock <code>make_shared</code> that custom alignment is not respected, causing SEGFAULTs at runtime, which is notoriously hard to debug.  <a href="a01596.html#abcb9ece2bd206193ac40f118f1815c0e">More...</a><br /></td></tr>
<tr class="separator:abcb9ece2bd206193ac40f118f1815c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f805b32c5544e5552d702d5e2b4e801"><td class="memTemplParams" colspan="2"><a id="a6f805b32c5544e5552d702d5e2b4e801" name="a6f805b32c5544e5552d702d5e2b4e801"></a>
template&lt;typename T , typename ... Args&gt; </td></tr>
<tr class="memitem:a6f805b32c5544e5552d702d5e2b4e801"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01596.html#a47e06cd29f4e8a20a8a7842e4045845f">gtsam::enable_if_t</a>&lt;!<a class="el" href="a02728.html">needs_eigen_aligned_allocator</a>&lt; T &gt;::value, boost::shared_ptr&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_shared</b> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a6f805b32c5544e5552d702d5e2b4e801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fall back to the boost version if no need for alignment. <br /></td></tr>
<tr class="separator:a6f805b32c5544e5552d702d5e2b4e801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03a6aedf0a82f67c2f3e987fb3aacba"><td class="memTemplParams" colspan="2"><a id="ae03a6aedf0a82f67c2f3e987fb3aacba" name="ae03a6aedf0a82f67c2f3e987fb3aacba"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae03a6aedf0a82f67c2f3e987fb3aacba"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BOOST_CONCEPT_REQUIRES</b> (((<a class="el" href="a02644.html">IsTestable</a>&lt; T &gt;)),(bool)) check_manifold_invariants(const T &amp;a</td></tr>
<tr class="memdesc:ae03a6aedf0a82f67c2f3e987fb3aacba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check invariants for Manifold type. <br /></td></tr>
<tr class="separator:ae03a6aedf0a82f67c2f3e987fb3aacba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9622226dfe06908f11b42bf0bdd22d"><td class="memItemLeft" align="right" valign="top"><a id="a3f9622226dfe06908f11b42bf0bdd22d" name="a3f9622226dfe06908f11b42bf0bdd22d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>assert_equal</b> (const Matrix &amp;A, const Matrix &amp;B, double tol=1e-9)</td></tr>
<tr class="memdesc:a3f9622226dfe06908f11b42bf0bdd22d"><td class="mdescLeft">&#160;</td><td class="mdescRight">equals with an tolerance, prints out message if unequal <br /></td></tr>
<tr class="separator:a3f9622226dfe06908f11b42bf0bdd22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a116d0643f123ef3b15d91056506492"><td class="memItemLeft" align="right" valign="top"><a id="a7a116d0643f123ef3b15d91056506492" name="a7a116d0643f123ef3b15d91056506492"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>assert_inequal</b> (const Matrix &amp;A, const Matrix &amp;B, double tol=1e-9)</td></tr>
<tr class="memdesc:a7a116d0643f123ef3b15d91056506492"><td class="mdescLeft">&#160;</td><td class="mdescRight">inequals with an tolerance, prints out message if within tolerance <br /></td></tr>
<tr class="separator:a7a116d0643f123ef3b15d91056506492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0e19bbbeaca95843e8161b89a12fda"><td class="memItemLeft" align="right" valign="top"><a id="abb0e19bbbeaca95843e8161b89a12fda" name="abb0e19bbbeaca95843e8161b89a12fda"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>assert_equal</b> (const std::list&lt; Matrix &gt; &amp;As, const std::list&lt; Matrix &gt; &amp;Bs, double tol=1e-9)</td></tr>
<tr class="memdesc:abb0e19bbbeaca95843e8161b89a12fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">equals with an tolerance, prints out message if unequal <br /></td></tr>
<tr class="separator:abb0e19bbbeaca95843e8161b89a12fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f0349471464c1fb515819d9503849a"><td class="memItemLeft" align="right" valign="top"><a id="ad8f0349471464c1fb515819d9503849a" name="ad8f0349471464c1fb515819d9503849a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>linear_independent</b> (const Matrix &amp;A, const Matrix &amp;B, double tol=1e-9)</td></tr>
<tr class="memdesc:ad8f0349471464c1fb515819d9503849a"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether the rows of two matrices are linear independent <br /></td></tr>
<tr class="separator:ad8f0349471464c1fb515819d9503849a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b81794af72954abafbb726fc712f5db"><td class="memItemLeft" align="right" valign="top"><a id="a4b81794af72954abafbb726fc712f5db" name="a4b81794af72954abafbb726fc712f5db"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>linear_dependent</b> (const Matrix &amp;A, const Matrix &amp;B, double tol=1e-9)</td></tr>
<tr class="memdesc:a4b81794af72954abafbb726fc712f5db"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether the rows of two matrices are linear dependent <br /></td></tr>
<tr class="separator:a4b81794af72954abafbb726fc712f5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2218e53a2b99c449e70aa5b7805895fc"><td class="memItemLeft" align="right" valign="top"><a id="a2218e53a2b99c449e70aa5b7805895fc" name="a2218e53a2b99c449e70aa5b7805895fc"></a>
Vector&#160;</td><td class="memItemRight" valign="bottom"><b>operator^</b> (const Matrix &amp;A, const Vector &amp;v)</td></tr>
<tr class="memdesc:a2218e53a2b99c449e70aa5b7805895fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload ^ for trans(A)*v We transpose the vectors for speed. <br /></td></tr>
<tr class="separator:a2218e53a2b99c449e70aa5b7805895fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd023b3cf67869170df84b35e8fcc61"><td class="memItemLeft" align="right" valign="top"><a id="a9dd023b3cf67869170df84b35e8fcc61" name="a9dd023b3cf67869170df84b35e8fcc61"></a>
const Eigen::IOFormat &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>matlabFormat</b> ()</td></tr>
<tr class="separator:a9dd023b3cf67869170df84b35e8fcc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fa43c89c5334314c8c75939dd5c2d7"><td class="memItemLeft" align="right" valign="top"><a id="a54fa43c89c5334314c8c75939dd5c2d7" name="a54fa43c89c5334314c8c75939dd5c2d7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print</b> (const Matrix &amp;A, const std::string &amp;s, std::ostream &amp;stream)</td></tr>
<tr class="memdesc:a54fa43c89c5334314c8c75939dd5c2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">print without optional string, must specify cout yourself <br /></td></tr>
<tr class="separator:a54fa43c89c5334314c8c75939dd5c2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ead03912d5dcf094d8421e1702ee71"><td class="memItemLeft" align="right" valign="top"><a id="a44ead03912d5dcf094d8421e1702ee71" name="a44ead03912d5dcf094d8421e1702ee71"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print</b> (const Matrix &amp;A, const std::string &amp;s=&quot;&quot;)</td></tr>
<tr class="memdesc:a44ead03912d5dcf094d8421e1702ee71"><td class="mdescLeft">&#160;</td><td class="mdescRight">print with optional string to cout <br /></td></tr>
<tr class="separator:a44ead03912d5dcf094d8421e1702ee71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb7eed9019d3fda8fcf74fbf85b85c9"><td class="memItemLeft" align="right" valign="top"><a id="a3eb7eed9019d3fda8fcf74fbf85b85c9" name="a3eb7eed9019d3fda8fcf74fbf85b85c9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>save</b> (const Matrix &amp;A, const std::string &amp;s, const std::string &amp;filename)</td></tr>
<tr class="memdesc:a3eb7eed9019d3fda8fcf74fbf85b85c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">save a matrix to file, which can be loaded by matlab <br /></td></tr>
<tr class="separator:a3eb7eed9019d3fda8fcf74fbf85b85c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d85957bab2d18cf56ab9aaf95a106de"><td class="memItemLeft" align="right" valign="top">istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a7d85957bab2d18cf56ab9aaf95a106de">operator&gt;&gt;</a> (std::istream &amp;inputStream, Matrix &amp;destinationMatrix)</td></tr>
<tr class="memdesc:a7d85957bab2d18cf56ab9aaf95a106de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a matrix from an input stream, such as a file.  <a href="a01596.html#a7d85957bab2d18cf56ab9aaf95a106de">More...</a><br /></td></tr>
<tr class="separator:a7d85957bab2d18cf56ab9aaf95a106de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c32907adce74cf9edd6ee5bba5a085"><td class="memItemLeft" align="right" valign="top"><a id="af1c32907adce74cf9edd6ee5bba5a085" name="af1c32907adce74cf9edd6ee5bba5a085"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><b>diag</b> (const std::vector&lt; Matrix &gt; &amp;Hs)</td></tr>
<tr class="memdesc:af1c32907adce74cf9edd6ee5bba5a085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matrix with submatrices along its diagonal. <br /></td></tr>
<tr class="separator:af1c32907adce74cf9edd6ee5bba5a085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7bb98c618c787686109e18a71e87463"><td class="memItemLeft" align="right" valign="top"><a id="ac7bb98c618c787686109e18a71e87463" name="ac7bb98c618c787686109e18a71e87463"></a>
Vector&#160;</td><td class="memItemRight" valign="bottom"><b>columnNormSquare</b> (const Matrix &amp;A)</td></tr>
<tr class="separator:ac7bb98c618c787686109e18a71e87463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32c295e2c40c1e85f146a8a6266eaa8"><td class="memItemLeft" align="right" valign="top">pair&lt; Matrix, Matrix &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#ae32c295e2c40c1e85f146a8a6266eaa8">qr</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:ae32c295e2c40c1e85f146a8a6266eaa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Householder QR factorization, Golub &amp; Van Loan p 224, explicit version <br  />
  <a href="a01596.html#ae32c295e2c40c1e85f146a8a6266eaa8">More...</a><br /></td></tr>
<tr class="separator:ae32c295e2c40c1e85f146a8a6266eaa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60019a03f26b92c6b2a08e43d153d4c0"><td class="memItemLeft" align="right" valign="top">list&lt; boost::tuple&lt; Vector, double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a60019a03f26b92c6b2a08e43d153d4c0">weighted_eliminate</a> (Matrix &amp;A, Vector &amp;b, const Vector &amp;sigmas)</td></tr>
<tr class="memdesc:a60019a03f26b92c6b2a08e43d153d4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imperative algorithm for in-place full elimination with weights and constraint handling.  <a href="a01596.html#a60019a03f26b92c6b2a08e43d153d4c0">More...</a><br /></td></tr>
<tr class="separator:a60019a03f26b92c6b2a08e43d153d4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd1ab05e8ac90b340fbd8f3b322dc6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#abdd1ab05e8ac90b340fbd8f3b322dc6d">householder_</a> (Matrix &amp;A, size_t k, bool copy_vectors)</td></tr>
<tr class="memdesc:abdd1ab05e8ac90b340fbd8f3b322dc6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imperative version of Householder QR factorization, Golub &amp; Van Loan p 224 version with Householder vectors below diagonal, as in GVL.  <a href="a01596.html#abdd1ab05e8ac90b340fbd8f3b322dc6d">More...</a><br /></td></tr>
<tr class="separator:abdd1ab05e8ac90b340fbd8f3b322dc6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7baa2f3184a444adce108633c0265e0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a7baa2f3184a444adce108633c0265e0c">householder</a> (Matrix &amp;A, size_t k)</td></tr>
<tr class="memdesc:a7baa2f3184a444adce108633c0265e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Householder tranformation, zeros below diagonal.  <a href="a01596.html#a7baa2f3184a444adce108633c0265e0c">More...</a><br /></td></tr>
<tr class="separator:a7baa2f3184a444adce108633c0265e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d998e1b770c9864946ddb031b1c4522"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a0d998e1b770c9864946ddb031b1c4522">backSubstituteLower</a> (const Matrix &amp;L, const Vector &amp;b, bool unit=false)</td></tr>
<tr class="memdesc:a0d998e1b770c9864946ddb031b1c4522"><td class="mdescLeft">&#160;</td><td class="mdescRight">backSubstitute L*x=b  <a href="a01596.html#a0d998e1b770c9864946ddb031b1c4522">More...</a><br /></td></tr>
<tr class="separator:a0d998e1b770c9864946ddb031b1c4522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4876cbe85d5651a52eda0e97c60f2f"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a6c4876cbe85d5651a52eda0e97c60f2f">backSubstituteUpper</a> (const Matrix &amp;U, const Vector &amp;b, bool unit=false)</td></tr>
<tr class="memdesc:a6c4876cbe85d5651a52eda0e97c60f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">backSubstitute U*x=b  <a href="a01596.html#a6c4876cbe85d5651a52eda0e97c60f2f">More...</a><br /></td></tr>
<tr class="separator:a6c4876cbe85d5651a52eda0e97c60f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0bf332d52b333dab2b20d763c8925b"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a8b0bf332d52b333dab2b20d763c8925b">backSubstituteUpper</a> (const Vector &amp;b, const Matrix &amp;U, bool unit=false)</td></tr>
<tr class="memdesc:a8b0bf332d52b333dab2b20d763c8925b"><td class="mdescLeft">&#160;</td><td class="mdescRight">backSubstitute x'*U=b'  <a href="a01596.html#a8b0bf332d52b333dab2b20d763c8925b">More...</a><br /></td></tr>
<tr class="separator:a8b0bf332d52b333dab2b20d763c8925b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c82884a356ddd09229a5283aed04df9"><td class="memItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a5c82884a356ddd09229a5283aed04df9">stack</a> (size_t nrMatrices,...)</td></tr>
<tr class="memdesc:a5c82884a356ddd09229a5283aed04df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a matrix by stacking other matrices Given a set of matrices: A1, A2, A3...  <a href="a01596.html#a5c82884a356ddd09229a5283aed04df9">More...</a><br /></td></tr>
<tr class="separator:a5c82884a356ddd09229a5283aed04df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952843d658e0425fda99f14f408760ca"><td class="memItemLeft" align="right" valign="top"><a id="a952843d658e0425fda99f14f408760ca" name="a952843d658e0425fda99f14f408760ca"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><b>stack</b> (const std::vector&lt; Matrix &gt; &amp;blocks)</td></tr>
<tr class="separator:a952843d658e0425fda99f14f408760ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b524ba6c9aed0d21a020999c9b5d88"><td class="memItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#ad8b524ba6c9aed0d21a020999c9b5d88">collect</a> (const std::vector&lt; const Matrix * &gt; &amp;matrices, size_t m=0, size_t n=0)</td></tr>
<tr class="memdesc:ad8b524ba6c9aed0d21a020999c9b5d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a matrix by concatenating Given a set of matrices: A1, A2, A3... If all matrices have the same size, specifying single matrix dimensions will avoid the lookup of dimensions  <a href="a01596.html#ad8b524ba6c9aed0d21a020999c9b5d88">More...</a><br /></td></tr>
<tr class="separator:ad8b524ba6c9aed0d21a020999c9b5d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71fc8eaea5f380a91bcfc1e8b140522"><td class="memItemLeft" align="right" valign="top"><a id="ac71fc8eaea5f380a91bcfc1e8b140522" name="ac71fc8eaea5f380a91bcfc1e8b140522"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><b>collect</b> (size_t nrMatrices,...)</td></tr>
<tr class="separator:ac71fc8eaea5f380a91bcfc1e8b140522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d3ad0252f91f0ec301593c45cf5af7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a24d3ad0252f91f0ec301593c45cf5af7">vector_scale_inplace</a> (const Vector &amp;v, Matrix &amp;A, bool inf_mask=false)</td></tr>
<tr class="memdesc:a24d3ad0252f91f0ec301593c45cf5af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">scales a matrix row or column by the values in a vector Arguments (Matrix, Vector) scales the columns, (Vector, Matrix) scales the rows  <a href="a01596.html#a24d3ad0252f91f0ec301593c45cf5af7">More...</a><br /></td></tr>
<tr class="separator:a24d3ad0252f91f0ec301593c45cf5af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc4f0fb9712cc419aa8ff8b6d8fe407"><td class="memItemLeft" align="right" valign="top"><a id="a5bc4f0fb9712cc419aa8ff8b6d8fe407" name="a5bc4f0fb9712cc419aa8ff8b6d8fe407"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><b>vector_scale</b> (const Vector &amp;v, const Matrix &amp;A, bool inf_mask)</td></tr>
<tr class="separator:a5bc4f0fb9712cc419aa8ff8b6d8fe407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67cd7ba6f30e1e9cf47239535630c7c6"><td class="memItemLeft" align="right" valign="top"><a id="a67cd7ba6f30e1e9cf47239535630c7c6" name="a67cd7ba6f30e1e9cf47239535630c7c6"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><b>vector_scale</b> (const Matrix &amp;A, const Vector &amp;v, bool inf_mask)</td></tr>
<tr class="separator:a67cd7ba6f30e1e9cf47239535630c7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d6f844b3fc9874c46f1a753aa03489"><td class="memItemLeft" align="right" valign="top"><a id="a60d6f844b3fc9874c46f1a753aa03489" name="a60d6f844b3fc9874c46f1a753aa03489"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><b>LLt</b> (const Matrix &amp;A)</td></tr>
<tr class="separator:a60d6f844b3fc9874c46f1a753aa03489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b05b69489f07d74d392d6abf17c644c"><td class="memItemLeft" align="right" valign="top"><a id="a2b05b69489f07d74d392d6abf17c644c" name="a2b05b69489f07d74d392d6abf17c644c"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><b>RtR</b> (const Matrix &amp;A)</td></tr>
<tr class="separator:a2b05b69489f07d74d392d6abf17c644c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba542e2cd85f08b76f80a0871a4ea713"><td class="memItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#aba542e2cd85f08b76f80a0871a4ea713">cholesky_inverse</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:aba542e2cd85f08b76f80a0871a4ea713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the inverse of a S.P.D.  <a href="a01596.html#aba542e2cd85f08b76f80a0871a4ea713">More...</a><br /></td></tr>
<tr class="separator:aba542e2cd85f08b76f80a0871a4ea713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff78dee59ac0250432081f39deb5f6d1"><td class="memItemLeft" align="right" valign="top"><a id="aff78dee59ac0250432081f39deb5f6d1" name="aff78dee59ac0250432081f39deb5f6d1"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><b>inverse_square_root</b> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:aff78dee59ac0250432081f39deb5f6d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Cholesky to calculate inverse square root of a matrix. <br /></td></tr>
<tr class="separator:aff78dee59ac0250432081f39deb5f6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7e46204d953f64a39445599dbd7eee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a8d7e46204d953f64a39445599dbd7eee">svd</a> (const Matrix &amp;A, Matrix &amp;U, Vector &amp;S, Matrix &amp;V)</td></tr>
<tr class="memdesc:a8d7e46204d953f64a39445599dbd7eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">SVD computes economy SVD A=U*S*V'.  <a href="a01596.html#a8d7e46204d953f64a39445599dbd7eee">More...</a><br /></td></tr>
<tr class="separator:a8d7e46204d953f64a39445599dbd7eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c65f1a69009a306b6a5f9ef31dcee2"><td class="memItemLeft" align="right" valign="top">boost::tuple&lt; int, double, Vector &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#ab2c65f1a69009a306b6a5f9ef31dcee2">DLT</a> (const Matrix &amp;A, double rank_tol=1e-9)</td></tr>
<tr class="memdesc:ab2c65f1a69009a306b6a5f9ef31dcee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct linear transform algorithm that calls svd to find a vector v that minimizes the algebraic error A*v.  <a href="a01596.html#ab2c65f1a69009a306b6a5f9ef31dcee2">More...</a><br /></td></tr>
<tr class="separator:ab2c65f1a69009a306b6a5f9ef31dcee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15462d8c16813d0a7a5b1f76a2f64b7"><td class="memItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#ab15462d8c16813d0a7a5b1f76a2f64b7">expm</a> (const Matrix &amp;A, size_t K=7)</td></tr>
<tr class="memdesc:ab15462d8c16813d0a7a5b1f76a2f64b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerical exponential map, naive approach, not industrial strength !!!  <a href="a01596.html#ab15462d8c16813d0a7a5b1f76a2f64b7">More...</a><br /></td></tr>
<tr class="separator:ab15462d8c16813d0a7a5b1f76a2f64b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1beb274aff9f803d65219200078e7310"><td class="memItemLeft" align="right" valign="top"><a id="a1beb274aff9f803d65219200078e7310" name="a1beb274aff9f803d65219200078e7310"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>formatMatrixIndented</b> (const std::string &amp;label, const Matrix &amp;matrix, bool makeVectorHorizontal)</td></tr>
<tr class="separator:a1beb274aff9f803d65219200078e7310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eec9339ab5a008a28ddfaa6b2c94611"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a7eec9339ab5a008a28ddfaa6b2c94611">inplace_QR</a> (Matrix &amp;A)</td></tr>
<tr class="memdesc:a7eec9339ab5a008a28ddfaa6b2c94611"><td class="mdescLeft">&#160;</td><td class="mdescRight">QR factorization using Eigen's internal block QR algorithm.  <a href="a01596.html#a7eec9339ab5a008a28ddfaa6b2c94611">More...</a><br /></td></tr>
<tr class="separator:a7eec9339ab5a008a28ddfaa6b2c94611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31e657258505b2e5148846ebbaa3195"><td class="memTemplParams" colspan="2"><a id="af31e657258505b2e5148846ebbaa3195" name="af31e657258505b2e5148846ebbaa3195"></a>
template&lt;class MATRIX &gt; </td></tr>
<tr class="memitem:af31e657258505b2e5148846ebbaa3195"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equal_with_abs_tol</b> (const Eigen::DenseBase&lt; MATRIX &gt; &amp;A, const Eigen::DenseBase&lt; MATRIX &gt; &amp;B, double tol=1e-9)</td></tr>
<tr class="memdesc:af31e657258505b2e5148846ebbaa3195"><td class="mdescLeft">&#160;</td><td class="mdescRight">equals with a tolerance <br /></td></tr>
<tr class="separator:af31e657258505b2e5148846ebbaa3195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5b3cf3f54adcbdd6d9e7403f1a792f"><td class="memItemLeft" align="right" valign="top"><a id="afd5b3cf3f54adcbdd6d9e7403f1a792f" name="afd5b3cf3f54adcbdd6d9e7403f1a792f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const Matrix &amp;A, const Matrix &amp;B)</td></tr>
<tr class="memdesc:afd5b3cf3f54adcbdd6d9e7403f1a792f"><td class="mdescLeft">&#160;</td><td class="mdescRight">equality is just equal_with_abs_tol 1e-9 <br /></td></tr>
<tr class="separator:afd5b3cf3f54adcbdd6d9e7403f1a792f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab235abf7505b634be2165e0db58239dd"><td class="memItemLeft" align="right" valign="top"><a id="ab235abf7505b634be2165e0db58239dd" name="ab235abf7505b634be2165e0db58239dd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const Matrix &amp;A, const Matrix &amp;B)</td></tr>
<tr class="memdesc:ab235abf7505b634be2165e0db58239dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">inequality <br /></td></tr>
<tr class="separator:ab235abf7505b634be2165e0db58239dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc29e3164ed30e785a3c48dfd1aa6ca5"><td class="memTemplParams" colspan="2"><a id="abc29e3164ed30e785a3c48dfd1aa6ca5" name="abc29e3164ed30e785a3c48dfd1aa6ca5"></a>
template&lt;class MATRIX &gt; </td></tr>
<tr class="memitem:abc29e3164ed30e785a3c48dfd1aa6ca5"><td class="memTemplItemLeft" align="right" valign="top">MATRIX&#160;</td><td class="memTemplItemRight" valign="bottom"><b>prod</b> (const MATRIX &amp;A, const MATRIX &amp;B)</td></tr>
<tr class="memdesc:abc29e3164ed30e785a3c48dfd1aa6ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">products using old-style format to improve compatibility <br /></td></tr>
<tr class="separator:abc29e3164ed30e785a3c48dfd1aa6ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae1d9fe2ccad044fbb88b5c1d9e035a"><td class="memTemplParams" colspan="2">template&lt;class MATRIX &gt; </td></tr>
<tr class="memitem:a9ae1d9fe2ccad044fbb88b5c1d9e035a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Block&lt; const MATRIX &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a9ae1d9fe2ccad044fbb88b5c1d9e035a">sub</a> (const MATRIX &amp;A, size_t i1, size_t i2, size_t j1, size_t j2)</td></tr>
<tr class="memdesc:a9ae1d9fe2ccad044fbb88b5c1d9e035a"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract submatrix, slice semantics, i.e.  <a href="a01596.html#a9ae1d9fe2ccad044fbb88b5c1d9e035a">More...</a><br /></td></tr>
<tr class="separator:a9ae1d9fe2ccad044fbb88b5c1d9e035a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1088fa2d1494e6a4123a6bc3f5c2d7e"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:ad1088fa2d1494e6a4123a6bc3f5c2d7e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#ad1088fa2d1494e6a4123a6bc3f5c2d7e">insertSub</a> (Eigen::MatrixBase&lt; Derived1 &gt; &amp;fullMatrix, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;subMatrix, size_t i, size_t j)</td></tr>
<tr class="memdesc:ad1088fa2d1494e6a4123a6bc3f5c2d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a submatrix IN PLACE at a specified location in a larger matrix NOTE: there is no size checking  <a href="a01596.html#ad1088fa2d1494e6a4123a6bc3f5c2d7e">More...</a><br /></td></tr>
<tr class="separator:ad1088fa2d1494e6a4123a6bc3f5c2d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559dba69e2854eb66e34222f60f55722"><td class="memTemplParams" colspan="2">template&lt;class MATRIX &gt; </td></tr>
<tr class="memitem:a559dba69e2854eb66e34222f60f55722"><td class="memTemplItemLeft" align="right" valign="top">const MATRIX::ConstColXpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a559dba69e2854eb66e34222f60f55722">column</a> (const MATRIX &amp;A, size_t j)</td></tr>
<tr class="memdesc:a559dba69e2854eb66e34222f60f55722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a column view from a matrix that avoids a copy.  <a href="a01596.html#a559dba69e2854eb66e34222f60f55722">More...</a><br /></td></tr>
<tr class="separator:a559dba69e2854eb66e34222f60f55722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2754f325c8600303d627d9e8cf1f9949"><td class="memTemplParams" colspan="2">template&lt;class MATRIX &gt; </td></tr>
<tr class="memitem:a2754f325c8600303d627d9e8cf1f9949"><td class="memTemplItemLeft" align="right" valign="top">const MATRIX::ConstRowXpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a2754f325c8600303d627d9e8cf1f9949">row</a> (const MATRIX &amp;A, size_t j)</td></tr>
<tr class="memdesc:a2754f325c8600303d627d9e8cf1f9949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a row view from a matrix that avoids a copy.  <a href="a01596.html#a2754f325c8600303d627d9e8cf1f9949">More...</a><br /></td></tr>
<tr class="separator:a2754f325c8600303d627d9e8cf1f9949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57edf6ed7312f63d35f73233665c334d"><td class="memTemplParams" colspan="2">template&lt;class MATRIX &gt; </td></tr>
<tr class="memitem:a57edf6ed7312f63d35f73233665c334d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a57edf6ed7312f63d35f73233665c334d">zeroBelowDiagonal</a> (MATRIX &amp;A, size_t cols=0)</td></tr>
<tr class="memdesc:a57edf6ed7312f63d35f73233665c334d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zeros all of the elements below the diagonal of a matrix, in place.  <a href="a01596.html#a57edf6ed7312f63d35f73233665c334d">More...</a><br /></td></tr>
<tr class="separator:a57edf6ed7312f63d35f73233665c334d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e36d7ab63000feddaeb61bbfcf2db1"><td class="memItemLeft" align="right" valign="top"><a id="aa2e36d7ab63000feddaeb61bbfcf2db1" name="aa2e36d7ab63000feddaeb61bbfcf2db1"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><b>trans</b> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:aa2e36d7ab63000feddaeb61bbfcf2db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">static transpose function, just calls Eigen transpose member function <br /></td></tr>
<tr class="separator:aa2e36d7ab63000feddaeb61bbfcf2db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086aad4c2e228ff578a30ccb50382c3d"><td class="memTemplParams" colspan="2"><a id="a086aad4c2e228ff578a30ccb50382c3d" name="a086aad4c2e228ff578a30ccb50382c3d"></a>
template&lt;int OutM, int OutN, int OutOptions, int InM, int InN, int InOptions&gt; </td></tr>
<tr class="memitem:a086aad4c2e228ff578a30ccb50382c3d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02584.html">Reshape</a>&lt; OutM, OutN, OutOptions, InM, InN, InOptions &gt;::ReshapedType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reshape</b> (const Eigen::Matrix&lt; double, InM, InN, InOptions &gt; &amp;m)</td></tr>
<tr class="separator:a086aad4c2e228ff578a30ccb50382c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f108d19e52c83c331c55d35b23796e"><td class="memItemLeft" align="right" valign="top">Matrix3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a97f108d19e52c83c331c55d35b23796e">skewSymmetric</a> (double wx, double wy, double wz)</td></tr>
<tr class="memdesc:a97f108d19e52c83c331c55d35b23796e"><td class="mdescLeft">&#160;</td><td class="mdescRight">skew symmetric matrix returns this: 0 -wz wy wz 0 -wx -wy wx 0  <a href="a01596.html#a97f108d19e52c83c331c55d35b23796e">More...</a><br /></td></tr>
<tr class="separator:a97f108d19e52c83c331c55d35b23796e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699b5cddc5e7e10eb543c57a728a8b4b"><td class="memTemplParams" colspan="2"><a id="a699b5cddc5e7e10eb543c57a728a8b4b" name="a699b5cddc5e7e10eb543c57a728a8b4b"></a>
template&lt;class Derived &gt; </td></tr>
<tr class="memitem:a699b5cddc5e7e10eb543c57a728a8b4b"><td class="memTemplItemLeft" align="right" valign="top">Matrix3&#160;</td><td class="memTemplItemRight" valign="bottom"><b>skewSymmetric</b> (const Eigen::MatrixBase&lt; Derived &gt; &amp;w)</td></tr>
<tr class="separator:a699b5cddc5e7e10eb543c57a728a8b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8862271510196ec4e2d894f623942d"><td class="memTemplParams" colspan="2">template&lt;class X , int N = traits&lt;X&gt;::dimension&gt; </td></tr>
<tr class="memitem:afd8862271510196ec4e2d894f623942d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, N, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#afd8862271510196ec4e2d894f623942d">numericalGradient</a> (std::function&lt; double(const X &amp;)&gt; h, const X &amp;x, double delta=1e-5)</td></tr>
<tr class="memdesc:afd8862271510196ec4e2d894f623942d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerically compute gradient of scalar function.  <a href="a01596.html#afd8862271510196ec4e2d894f623942d">More...</a><br /></td></tr>
<tr class="separator:afd8862271510196ec4e2d894f623942d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581a9f8db043590096fbac682b8f6a93"><td class="memTemplParams" colspan="2">template&lt;class Y , class X , int N = traits&lt;X&gt;::dimension&gt; </td></tr>
<tr class="memitem:a581a9f8db043590096fbac682b8f6a93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a581a9f8db043590096fbac682b8f6a93">numericalDerivative11</a> (std::function&lt; Y(const X &amp;)&gt; h, const X &amp;x, double delta=1e-5)</td></tr>
<tr class="memdesc:a581a9f8db043590096fbac682b8f6a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">New-style numerical derivatives using manifold_traits.  <a href="a01596.html#a581a9f8db043590096fbac682b8f6a93">More...</a><br /></td></tr>
<tr class="separator:a581a9f8db043590096fbac682b8f6a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4c5744f0b348d4ec6c047f796e7924"><td class="memTemplParams" colspan="2"><a id="a4c4c5744f0b348d4ec6c047f796e7924" name="a4c4c5744f0b348d4ec6c047f796e7924"></a>
template&lt;class Y , class X &gt; </td></tr>
<tr class="memitem:a4c4c5744f0b348d4ec6c047f796e7924"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative11</b> (Y(*h)(const X &amp;), const X &amp;x, double delta=1e-5)</td></tr>
<tr class="memdesc:a4c4c5744f0b348d4ec6c047f796e7924"><td class="mdescLeft">&#160;</td><td class="mdescRight">use a raw C++ function pointer <br /></td></tr>
<tr class="separator:a4c4c5744f0b348d4ec6c047f796e7924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157eb3b44dd4e38bbd66f3cc68a20e43"><td class="memTemplParams" colspan="2">template&lt;class Y , class X1 , class X2 , int N = traits&lt;X1&gt;::dimension&gt; </td></tr>
<tr class="memitem:a157eb3b44dd4e38bbd66f3cc68a20e43"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X1 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a157eb3b44dd4e38bbd66f3cc68a20e43">numericalDerivative21</a> (const std::function&lt; Y(const X1 &amp;, const X2 &amp;)&gt; &amp;h, const X1 &amp;x1, const X2 &amp;x2, double delta=1e-5)</td></tr>
<tr class="memdesc:a157eb3b44dd4e38bbd66f3cc68a20e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 1 of binary function.  <a href="a01596.html#a157eb3b44dd4e38bbd66f3cc68a20e43">More...</a><br /></td></tr>
<tr class="separator:a157eb3b44dd4e38bbd66f3cc68a20e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc94e3b49906e824c01a3d56df62d33"><td class="memTemplParams" colspan="2"><a id="afcc94e3b49906e824c01a3d56df62d33" name="afcc94e3b49906e824c01a3d56df62d33"></a>
template&lt;class Y , class X1 , class X2 &gt; </td></tr>
<tr class="memitem:afcc94e3b49906e824c01a3d56df62d33"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X1 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative21</b> (Y(*h)(const X1 &amp;, const X2 &amp;), const X1 &amp;x1, const X2 &amp;x2, double delta=1e-5)</td></tr>
<tr class="memdesc:afcc94e3b49906e824c01a3d56df62d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">use a raw C++ function pointer <br /></td></tr>
<tr class="separator:afcc94e3b49906e824c01a3d56df62d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0db4ac5f279b12fc91fab4cb40b1bf"><td class="memTemplParams" colspan="2">template&lt;class Y , class X1 , class X2 , int N = traits&lt;X2&gt;::dimension&gt; </td></tr>
<tr class="memitem:a5b0db4ac5f279b12fc91fab4cb40b1bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a5b0db4ac5f279b12fc91fab4cb40b1bf">numericalDerivative22</a> (std::function&lt; Y(const X1 &amp;, const X2 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, double delta=1e-5)</td></tr>
<tr class="memdesc:a5b0db4ac5f279b12fc91fab4cb40b1bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 2 of binary function.  <a href="a01596.html#a5b0db4ac5f279b12fc91fab4cb40b1bf">More...</a><br /></td></tr>
<tr class="separator:a5b0db4ac5f279b12fc91fab4cb40b1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d002a0529f1172aebb7e1d85d5c08c"><td class="memTemplParams" colspan="2"><a id="a46d002a0529f1172aebb7e1d85d5c08c" name="a46d002a0529f1172aebb7e1d85d5c08c"></a>
template&lt;class Y , class X1 , class X2 &gt; </td></tr>
<tr class="memitem:a46d002a0529f1172aebb7e1d85d5c08c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative22</b> (Y(*h)(const X1 &amp;, const X2 &amp;), const X1 &amp;x1, const X2 &amp;x2, double delta=1e-5)</td></tr>
<tr class="memdesc:a46d002a0529f1172aebb7e1d85d5c08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">use a raw C++ function pointer <br /></td></tr>
<tr class="separator:a46d002a0529f1172aebb7e1d85d5c08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f0264edaf78d503809c1e3152340ee"><td class="memTemplParams" colspan="2">template&lt;class Y , class X1 , class X2 , class X3 , int N = traits&lt;X1&gt;::dimension&gt; </td></tr>
<tr class="memitem:aa8f0264edaf78d503809c1e3152340ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X1 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#aa8f0264edaf78d503809c1e3152340ee">numericalDerivative31</a> (std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double delta=1e-5)</td></tr>
<tr class="memdesc:aa8f0264edaf78d503809c1e3152340ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 1 of ternary function.  <a href="a01596.html#aa8f0264edaf78d503809c1e3152340ee">More...</a><br /></td></tr>
<tr class="separator:aa8f0264edaf78d503809c1e3152340ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a91fc87a8003f7c511c2f7fe480d3e"><td class="memTemplParams" colspan="2"><a id="ab5a91fc87a8003f7c511c2f7fe480d3e" name="ab5a91fc87a8003f7c511c2f7fe480d3e"></a>
template&lt;class Y , class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:ab5a91fc87a8003f7c511c2f7fe480d3e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X1 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative31</b> (Y(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double delta=1e-5)</td></tr>
<tr class="separator:ab5a91fc87a8003f7c511c2f7fe480d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbadc0ab0cd9386205b2737c5d0b727"><td class="memTemplParams" colspan="2">template&lt;class Y , class X1 , class X2 , class X3 , int N = traits&lt;X2&gt;::dimension&gt; </td></tr>
<tr class="memitem:acfbadc0ab0cd9386205b2737c5d0b727"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#acfbadc0ab0cd9386205b2737c5d0b727">numericalDerivative32</a> (std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double delta=1e-5)</td></tr>
<tr class="memdesc:acfbadc0ab0cd9386205b2737c5d0b727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 2 of ternary function.  <a href="a01596.html#acfbadc0ab0cd9386205b2737c5d0b727">More...</a><br /></td></tr>
<tr class="separator:acfbadc0ab0cd9386205b2737c5d0b727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb86acbba4db6e405fe7df42bff45056"><td class="memTemplParams" colspan="2"><a id="adb86acbba4db6e405fe7df42bff45056" name="adb86acbba4db6e405fe7df42bff45056"></a>
template&lt;class Y , class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:adb86acbba4db6e405fe7df42bff45056"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative32</b> (Y(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double delta=1e-5)</td></tr>
<tr class="separator:adb86acbba4db6e405fe7df42bff45056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526a422ea611724345affed8b71d9bac"><td class="memTemplParams" colspan="2">template&lt;class Y , class X1 , class X2 , class X3 , int N = traits&lt;X3&gt;::dimension&gt; </td></tr>
<tr class="memitem:a526a422ea611724345affed8b71d9bac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X3 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a526a422ea611724345affed8b71d9bac">numericalDerivative33</a> (std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double delta=1e-5)</td></tr>
<tr class="memdesc:a526a422ea611724345affed8b71d9bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 3 of ternary function.  <a href="a01596.html#a526a422ea611724345affed8b71d9bac">More...</a><br /></td></tr>
<tr class="separator:a526a422ea611724345affed8b71d9bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19db1be6b58d9c3d396bd9a1d776a1fb"><td class="memTemplParams" colspan="2"><a id="a19db1be6b58d9c3d396bd9a1d776a1fb" name="a19db1be6b58d9c3d396bd9a1d776a1fb"></a>
template&lt;class Y , class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a19db1be6b58d9c3d396bd9a1d776a1fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X3 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative33</b> (Y(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double delta=1e-5)</td></tr>
<tr class="separator:a19db1be6b58d9c3d396bd9a1d776a1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0937e08e79604ee6ab10fca6ffe65e"><td class="memTemplParams" colspan="2">template&lt;class Y , class X1 , class X2 , class X3 , class X4 , int N = traits&lt;X1&gt;::dimension&gt; </td></tr>
<tr class="memitem:a3b0937e08e79604ee6ab10fca6ffe65e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X1 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a3b0937e08e79604ee6ab10fca6ffe65e">numericalDerivative41</a> (std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, const X4 &amp;x4, double delta=1e-5)</td></tr>
<tr class="memdesc:a3b0937e08e79604ee6ab10fca6ffe65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 1 of 4-argument function.  <a href="a01596.html#a3b0937e08e79604ee6ab10fca6ffe65e">More...</a><br /></td></tr>
<tr class="separator:a3b0937e08e79604ee6ab10fca6ffe65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d5fdab1e677bc1e01b7014a910cb03"><td class="memTemplParams" colspan="2"><a id="a50d5fdab1e677bc1e01b7014a910cb03" name="a50d5fdab1e677bc1e01b7014a910cb03"></a>
template&lt;class Y , class X1 , class X2 , class X3 , class X4 &gt; </td></tr>
<tr class="memitem:a50d5fdab1e677bc1e01b7014a910cb03"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X1 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative41</b> (Y(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, const X4 &amp;x4, double delta=1e-5)</td></tr>
<tr class="separator:a50d5fdab1e677bc1e01b7014a910cb03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40f61e8eff01acdb028ad33b8f3529b"><td class="memTemplParams" colspan="2">template&lt;class Y , class X1 , class X2 , class X3 , class X4 , int N = traits&lt;X2&gt;::dimension&gt; </td></tr>
<tr class="memitem:af40f61e8eff01acdb028ad33b8f3529b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#af40f61e8eff01acdb028ad33b8f3529b">numericalDerivative42</a> (std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, const X4 &amp;x4, double delta=1e-5)</td></tr>
<tr class="memdesc:af40f61e8eff01acdb028ad33b8f3529b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 2 of 4-argument function.  <a href="a01596.html#af40f61e8eff01acdb028ad33b8f3529b">More...</a><br /></td></tr>
<tr class="separator:af40f61e8eff01acdb028ad33b8f3529b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac489afb08a9fb8a05583f113b83cbf67"><td class="memTemplParams" colspan="2"><a id="ac489afb08a9fb8a05583f113b83cbf67" name="ac489afb08a9fb8a05583f113b83cbf67"></a>
template&lt;class Y , class X1 , class X2 , class X3 , class X4 &gt; </td></tr>
<tr class="memitem:ac489afb08a9fb8a05583f113b83cbf67"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative42</b> (Y(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, const X4 &amp;x4, double delta=1e-5)</td></tr>
<tr class="separator:ac489afb08a9fb8a05583f113b83cbf67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6846b5cc84c1d5a54a436121b27057e0"><td class="memTemplParams" colspan="2">template&lt;class Y , class X1 , class X2 , class X3 , class X4 , int N = traits&lt;X3&gt;::dimension&gt; </td></tr>
<tr class="memitem:a6846b5cc84c1d5a54a436121b27057e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X3 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a6846b5cc84c1d5a54a436121b27057e0">numericalDerivative43</a> (std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, const X4 &amp;x4, double delta=1e-5)</td></tr>
<tr class="memdesc:a6846b5cc84c1d5a54a436121b27057e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 3 of 4-argument function.  <a href="a01596.html#a6846b5cc84c1d5a54a436121b27057e0">More...</a><br /></td></tr>
<tr class="separator:a6846b5cc84c1d5a54a436121b27057e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0a38e01d7e055671af0927eff53978"><td class="memTemplParams" colspan="2"><a id="a5d0a38e01d7e055671af0927eff53978" name="a5d0a38e01d7e055671af0927eff53978"></a>
template&lt;class Y , class X1 , class X2 , class X3 , class X4 &gt; </td></tr>
<tr class="memitem:a5d0a38e01d7e055671af0927eff53978"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X3 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative43</b> (Y(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, const X4 &amp;x4, double delta=1e-5)</td></tr>
<tr class="separator:a5d0a38e01d7e055671af0927eff53978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8061b20199f839b115512d95d058fcbf"><td class="memTemplParams" colspan="2">template&lt;class Y , class X1 , class X2 , class X3 , class X4 , int N = traits&lt;X4&gt;::dimension&gt; </td></tr>
<tr class="memitem:a8061b20199f839b115512d95d058fcbf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X4 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a8061b20199f839b115512d95d058fcbf">numericalDerivative44</a> (std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, const X4 &amp;x4, double delta=1e-5)</td></tr>
<tr class="memdesc:a8061b20199f839b115512d95d058fcbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 4 of 4-argument function.  <a href="a01596.html#a8061b20199f839b115512d95d058fcbf">More...</a><br /></td></tr>
<tr class="separator:a8061b20199f839b115512d95d058fcbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73e351da66f148b73a6195249db3f18"><td class="memTemplParams" colspan="2"><a id="ac73e351da66f148b73a6195249db3f18" name="ac73e351da66f148b73a6195249db3f18"></a>
template&lt;class Y , class X1 , class X2 , class X3 , class X4 &gt; </td></tr>
<tr class="memitem:ac73e351da66f148b73a6195249db3f18"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X4 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative44</b> (Y(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, const X4 &amp;x4, double delta=1e-5)</td></tr>
<tr class="separator:ac73e351da66f148b73a6195249db3f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272af6f7139b76d085279060646e32d1"><td class="memTemplParams" colspan="2">template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 , int N = traits&lt;X1&gt;::dimension&gt; </td></tr>
<tr class="memitem:a272af6f7139b76d085279060646e32d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X1 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a272af6f7139b76d085279060646e32d1">numericalDerivative51</a> (std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, const X4 &amp;x4, const X5 &amp;x5, double delta=1e-5)</td></tr>
<tr class="memdesc:a272af6f7139b76d085279060646e32d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 1 of 5-argument function.  <a href="a01596.html#a272af6f7139b76d085279060646e32d1">More...</a><br /></td></tr>
<tr class="separator:a272af6f7139b76d085279060646e32d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f853de3e2cb895eac3228e1cb9f56f4"><td class="memTemplParams" colspan="2"><a id="a1f853de3e2cb895eac3228e1cb9f56f4" name="a1f853de3e2cb895eac3228e1cb9f56f4"></a>
template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 &gt; </td></tr>
<tr class="memitem:a1f853de3e2cb895eac3228e1cb9f56f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X1 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative51</b> (Y(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, const X4 &amp;x4, const X5 &amp;x5, double delta=1e-5)</td></tr>
<tr class="separator:a1f853de3e2cb895eac3228e1cb9f56f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722e98babba795ce480f89527b572251"><td class="memTemplParams" colspan="2">template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 , int N = traits&lt;X2&gt;::dimension&gt; </td></tr>
<tr class="memitem:a722e98babba795ce480f89527b572251"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a722e98babba795ce480f89527b572251">numericalDerivative52</a> (std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, const X4 &amp;x4, const X5 &amp;x5, double delta=1e-5)</td></tr>
<tr class="memdesc:a722e98babba795ce480f89527b572251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 2 of 5-argument function.  <a href="a01596.html#a722e98babba795ce480f89527b572251">More...</a><br /></td></tr>
<tr class="separator:a722e98babba795ce480f89527b572251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1675728cfec476d99878c41efe41fed"><td class="memTemplParams" colspan="2"><a id="ae1675728cfec476d99878c41efe41fed" name="ae1675728cfec476d99878c41efe41fed"></a>
template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 &gt; </td></tr>
<tr class="memitem:ae1675728cfec476d99878c41efe41fed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative52</b> (Y(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, const X4 &amp;x4, const X5 &amp;x5, double delta=1e-5)</td></tr>
<tr class="separator:ae1675728cfec476d99878c41efe41fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2f741132522a6ce57d544a27a95855"><td class="memTemplParams" colspan="2">template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 , int N = traits&lt;X3&gt;::dimension&gt; </td></tr>
<tr class="memitem:acc2f741132522a6ce57d544a27a95855"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X3 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#acc2f741132522a6ce57d544a27a95855">numericalDerivative53</a> (std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, const X4 &amp;x4, const X5 &amp;x5, double delta=1e-5)</td></tr>
<tr class="memdesc:acc2f741132522a6ce57d544a27a95855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 3 of 5-argument function.  <a href="a01596.html#acc2f741132522a6ce57d544a27a95855">More...</a><br /></td></tr>
<tr class="separator:acc2f741132522a6ce57d544a27a95855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2d5bb7323daa19e56f9587415f8eb8"><td class="memTemplParams" colspan="2"><a id="a0e2d5bb7323daa19e56f9587415f8eb8" name="a0e2d5bb7323daa19e56f9587415f8eb8"></a>
template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 &gt; </td></tr>
<tr class="memitem:a0e2d5bb7323daa19e56f9587415f8eb8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X3 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative53</b> (Y(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, const X4 &amp;x4, const X5 &amp;x5, double delta=1e-5)</td></tr>
<tr class="separator:a0e2d5bb7323daa19e56f9587415f8eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf5181fc7bca1ef6a1070959de7b975"><td class="memTemplParams" colspan="2">template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 , int N = traits&lt;X4&gt;::dimension&gt; </td></tr>
<tr class="memitem:a2cf5181fc7bca1ef6a1070959de7b975"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X4 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a2cf5181fc7bca1ef6a1070959de7b975">numericalDerivative54</a> (std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, const X4 &amp;x4, const X5 &amp;x5, double delta=1e-5)</td></tr>
<tr class="memdesc:a2cf5181fc7bca1ef6a1070959de7b975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 4 of 5-argument function.  <a href="a01596.html#a2cf5181fc7bca1ef6a1070959de7b975">More...</a><br /></td></tr>
<tr class="separator:a2cf5181fc7bca1ef6a1070959de7b975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92914f824c4f2c01c3e0db95d76103fb"><td class="memTemplParams" colspan="2"><a id="a92914f824c4f2c01c3e0db95d76103fb" name="a92914f824c4f2c01c3e0db95d76103fb"></a>
template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 &gt; </td></tr>
<tr class="memitem:a92914f824c4f2c01c3e0db95d76103fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X4 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative54</b> (Y(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, const X4 &amp;x4, const X5 &amp;x5, double delta=1e-5)</td></tr>
<tr class="separator:a92914f824c4f2c01c3e0db95d76103fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca42a2fc87373c005299f3087995a97"><td class="memTemplParams" colspan="2">template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 , int N = traits&lt;X5&gt;::dimension&gt; </td></tr>
<tr class="memitem:a5ca42a2fc87373c005299f3087995a97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X5 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a5ca42a2fc87373c005299f3087995a97">numericalDerivative55</a> (std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, const X4 &amp;x4, const X5 &amp;x5, double delta=1e-5)</td></tr>
<tr class="memdesc:a5ca42a2fc87373c005299f3087995a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 5 of 5-argument function.  <a href="a01596.html#a5ca42a2fc87373c005299f3087995a97">More...</a><br /></td></tr>
<tr class="separator:a5ca42a2fc87373c005299f3087995a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9cdba13e4b3bc8ac780365ff4acc1a"><td class="memTemplParams" colspan="2"><a id="afd9cdba13e4b3bc8ac780365ff4acc1a" name="afd9cdba13e4b3bc8ac780365ff4acc1a"></a>
template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 &gt; </td></tr>
<tr class="memitem:afd9cdba13e4b3bc8ac780365ff4acc1a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X5 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative55</b> (Y(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, const X4 &amp;x4, const X5 &amp;x5, double delta=1e-5)</td></tr>
<tr class="separator:afd9cdba13e4b3bc8ac780365ff4acc1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca8a22de666bc39015da34f150df748"><td class="memTemplParams" colspan="2">template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 , class X6 , int N = traits&lt;X1&gt;::dimension&gt; </td></tr>
<tr class="memitem:a0ca8a22de666bc39015da34f150df748"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X1 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a0ca8a22de666bc39015da34f150df748">numericalDerivative61</a> (std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;, const X6 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, const X4 &amp;x4, const X5 &amp;x5, const X6 &amp;x6, double delta=1e-5)</td></tr>
<tr class="memdesc:a0ca8a22de666bc39015da34f150df748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 1 of 6-argument function.  <a href="a01596.html#a0ca8a22de666bc39015da34f150df748">More...</a><br /></td></tr>
<tr class="separator:a0ca8a22de666bc39015da34f150df748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1cbc58e6ed79b7d7c98079a150d70f4"><td class="memTemplParams" colspan="2"><a id="aa1cbc58e6ed79b7d7c98079a150d70f4" name="aa1cbc58e6ed79b7d7c98079a150d70f4"></a>
template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 , class X6 &gt; </td></tr>
<tr class="memitem:aa1cbc58e6ed79b7d7c98079a150d70f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X1 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative61</b> (Y(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;, const X6 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, const X4 &amp;x4, const X5 &amp;x5, const X6 &amp;x6, double delta=1e-5)</td></tr>
<tr class="separator:aa1cbc58e6ed79b7d7c98079a150d70f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac224e2384e41171181b2dbc0f700cdc1"><td class="memTemplParams" colspan="2">template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 , class X6 , int N = traits&lt;X2&gt;::dimension&gt; </td></tr>
<tr class="memitem:ac224e2384e41171181b2dbc0f700cdc1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#ac224e2384e41171181b2dbc0f700cdc1">numericalDerivative62</a> (std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;, const X6 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, const X4 &amp;x4, const X5 &amp;x5, const X6 &amp;x6, double delta=1e-5)</td></tr>
<tr class="memdesc:ac224e2384e41171181b2dbc0f700cdc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 2 of 6-argument function.  <a href="a01596.html#ac224e2384e41171181b2dbc0f700cdc1">More...</a><br /></td></tr>
<tr class="separator:ac224e2384e41171181b2dbc0f700cdc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1091b8e012a5f9047baea72134a138d8"><td class="memTemplParams" colspan="2"><a id="a1091b8e012a5f9047baea72134a138d8" name="a1091b8e012a5f9047baea72134a138d8"></a>
template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 , class X6 &gt; </td></tr>
<tr class="memitem:a1091b8e012a5f9047baea72134a138d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative62</b> (Y(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;, const X6 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, const X4 &amp;x4, const X5 &amp;x5, const X6 &amp;x6, double delta=1e-5)</td></tr>
<tr class="separator:a1091b8e012a5f9047baea72134a138d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c46aa999886d4ccd06ab73fc02db31"><td class="memTemplParams" colspan="2">template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 , class X6 , int N = traits&lt;X3&gt;::dimension&gt; </td></tr>
<tr class="memitem:a15c46aa999886d4ccd06ab73fc02db31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X3 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a15c46aa999886d4ccd06ab73fc02db31">numericalDerivative63</a> (std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;, const X6 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, const X4 &amp;x4, const X5 &amp;x5, const X6 &amp;x6, double delta=1e-5)</td></tr>
<tr class="memdesc:a15c46aa999886d4ccd06ab73fc02db31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 3 of 6-argument function.  <a href="a01596.html#a15c46aa999886d4ccd06ab73fc02db31">More...</a><br /></td></tr>
<tr class="separator:a15c46aa999886d4ccd06ab73fc02db31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cb5109a40f9674612ae9e40e498d12"><td class="memTemplParams" colspan="2"><a id="a53cb5109a40f9674612ae9e40e498d12" name="a53cb5109a40f9674612ae9e40e498d12"></a>
template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 , class X6 &gt; </td></tr>
<tr class="memitem:a53cb5109a40f9674612ae9e40e498d12"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X3 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative63</b> (Y(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;, const X6 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, const X4 &amp;x4, const X5 &amp;x5, const X6 &amp;x6, double delta=1e-5)</td></tr>
<tr class="separator:a53cb5109a40f9674612ae9e40e498d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb3fef9c77920dfd9496e71a0bcf669"><td class="memTemplParams" colspan="2">template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 , class X6 , int N = traits&lt;X4&gt;::dimension&gt; </td></tr>
<tr class="memitem:a3eb3fef9c77920dfd9496e71a0bcf669"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X4 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a3eb3fef9c77920dfd9496e71a0bcf669">numericalDerivative64</a> (std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;, const X6 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, const X4 &amp;x4, const X5 &amp;x5, const X6 &amp;x6, double delta=1e-5)</td></tr>
<tr class="memdesc:a3eb3fef9c77920dfd9496e71a0bcf669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 4 of 6-argument function.  <a href="a01596.html#a3eb3fef9c77920dfd9496e71a0bcf669">More...</a><br /></td></tr>
<tr class="separator:a3eb3fef9c77920dfd9496e71a0bcf669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0484771e1e5fa049d7cc9d218fc2ff1"><td class="memTemplParams" colspan="2"><a id="ad0484771e1e5fa049d7cc9d218fc2ff1" name="ad0484771e1e5fa049d7cc9d218fc2ff1"></a>
template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 , class X6 &gt; </td></tr>
<tr class="memitem:ad0484771e1e5fa049d7cc9d218fc2ff1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X4 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative64</b> (Y(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;, const X6 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, const X4 &amp;x4, const X5 &amp;x5, const X6 &amp;x6, double delta=1e-5)</td></tr>
<tr class="separator:ad0484771e1e5fa049d7cc9d218fc2ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799c83517a20a8e0b0b014f26b50f660"><td class="memTemplParams" colspan="2">template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 , class X6 , int N = traits&lt;X5&gt;::dimension&gt; </td></tr>
<tr class="memitem:a799c83517a20a8e0b0b014f26b50f660"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X5 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a799c83517a20a8e0b0b014f26b50f660">numericalDerivative65</a> (std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;, const X6 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, const X4 &amp;x4, const X5 &amp;x5, const X6 &amp;x6, double delta=1e-5)</td></tr>
<tr class="memdesc:a799c83517a20a8e0b0b014f26b50f660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 5 of 6-argument function.  <a href="a01596.html#a799c83517a20a8e0b0b014f26b50f660">More...</a><br /></td></tr>
<tr class="separator:a799c83517a20a8e0b0b014f26b50f660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1074296abca5a2371ea548e7094007"><td class="memTemplParams" colspan="2"><a id="aad1074296abca5a2371ea548e7094007" name="aad1074296abca5a2371ea548e7094007"></a>
template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 , class X6 &gt; </td></tr>
<tr class="memitem:aad1074296abca5a2371ea548e7094007"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X5 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative65</b> (Y(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;, const X6 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, const X4 &amp;x4, const X5 &amp;x5, const X6 &amp;x6, double delta=1e-5)</td></tr>
<tr class="separator:aad1074296abca5a2371ea548e7094007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e010b7f436124b9b421ba7dc438d987"><td class="memTemplParams" colspan="2">template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 , class X6 , int N = traits&lt;X6&gt;::dimension&gt; </td></tr>
<tr class="memitem:a4e010b7f436124b9b421ba7dc438d987"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X6 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a4e010b7f436124b9b421ba7dc438d987">numericalDerivative66</a> (std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;, const X6 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, const X4 &amp;x4, const X5 &amp;x5, const X6 &amp;x6, double delta=1e-5)</td></tr>
<tr class="memdesc:a4e010b7f436124b9b421ba7dc438d987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 6 of 6-argument function.  <a href="a01596.html#a4e010b7f436124b9b421ba7dc438d987">More...</a><br /></td></tr>
<tr class="separator:a4e010b7f436124b9b421ba7dc438d987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1798e116323d4122679a17b372b10173"><td class="memTemplParams" colspan="2"><a id="a1798e116323d4122679a17b372b10173" name="a1798e116323d4122679a17b372b10173"></a>
template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 , class X6 &gt; </td></tr>
<tr class="memitem:a1798e116323d4122679a17b372b10173"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X6 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative66</b> (Y(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;, const X6 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, const X4 &amp;x4, const X5 &amp;x5, const X6 &amp;x6, double delta=1e-5)</td></tr>
<tr class="separator:a1798e116323d4122679a17b372b10173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11011d8e9bd69e486c9752875f710c18"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:a11011d8e9bd69e486c9752875f710c18"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; X, X &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a11011d8e9bd69e486c9752875f710c18">numericalHessian</a> (std::function&lt; double(const X &amp;)&gt; f, const X &amp;x, double delta=1e-5)</td></tr>
<tr class="memdesc:a11011d8e9bd69e486c9752875f710c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical Hessian matrix.  <a href="a01596.html#a11011d8e9bd69e486c9752875f710c18">More...</a><br /></td></tr>
<tr class="separator:a11011d8e9bd69e486c9752875f710c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af6f956025f80c6bab5fa28640a2ffb"><td class="memTemplParams" colspan="2"><a id="a7af6f956025f80c6bab5fa28640a2ffb" name="a7af6f956025f80c6bab5fa28640a2ffb"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:a7af6f956025f80c6bab5fa28640a2ffb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; X, X &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian</b> (double(*f)(const X &amp;), const X &amp;x, double delta=1e-5)</td></tr>
<tr class="separator:a7af6f956025f80c6bab5fa28640a2ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364a549f11ed9936d31884ffda503f70"><td class="memTemplParams" colspan="2"><a id="a364a549f11ed9936d31884ffda503f70" name="a364a549f11ed9936d31884ffda503f70"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:a364a549f11ed9936d31884ffda503f70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; X1, X2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian212</b> (std::function&lt; double(const X1 &amp;, const X2 &amp;)&gt; f, const X1 &amp;x1, const X2 &amp;x2, double delta=1e-5)</td></tr>
<tr class="separator:a364a549f11ed9936d31884ffda503f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6412177426b62a86d0425cc1041f62f"><td class="memTemplParams" colspan="2"><a id="af6412177426b62a86d0425cc1041f62f" name="af6412177426b62a86d0425cc1041f62f"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:af6412177426b62a86d0425cc1041f62f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; X1, X2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian212</b> (double(*f)(const X1 &amp;, const X2 &amp;), const X1 &amp;x1, const X2 &amp;x2, double delta=1e-5)</td></tr>
<tr class="separator:af6412177426b62a86d0425cc1041f62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1fcf5d206c5111103ca824390fa9c10"><td class="memTemplParams" colspan="2"><a id="ad1fcf5d206c5111103ca824390fa9c10" name="ad1fcf5d206c5111103ca824390fa9c10"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:ad1fcf5d206c5111103ca824390fa9c10"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; X1, X1 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian211</b> (std::function&lt; double(const X1 &amp;, const X2 &amp;)&gt; f, const X1 &amp;x1, const X2 &amp;x2, double delta=1e-5)</td></tr>
<tr class="separator:ad1fcf5d206c5111103ca824390fa9c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48eb06101f6c62bc9fc70ac278979194"><td class="memTemplParams" colspan="2"><a id="a48eb06101f6c62bc9fc70ac278979194" name="a48eb06101f6c62bc9fc70ac278979194"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:a48eb06101f6c62bc9fc70ac278979194"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; X1, X1 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian211</b> (double(*f)(const X1 &amp;, const X2 &amp;), const X1 &amp;x1, const X2 &amp;x2, double delta=1e-5)</td></tr>
<tr class="separator:a48eb06101f6c62bc9fc70ac278979194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5b03c9806fe2b0887905628cc642db"><td class="memTemplParams" colspan="2"><a id="a8d5b03c9806fe2b0887905628cc642db" name="a8d5b03c9806fe2b0887905628cc642db"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:a8d5b03c9806fe2b0887905628cc642db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; X2, X2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian222</b> (std::function&lt; double(const X1 &amp;, const X2 &amp;)&gt; f, const X1 &amp;x1, const X2 &amp;x2, double delta=1e-5)</td></tr>
<tr class="separator:a8d5b03c9806fe2b0887905628cc642db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00575fd26cbad6e7f84524ff56380eb"><td class="memTemplParams" colspan="2"><a id="af00575fd26cbad6e7f84524ff56380eb" name="af00575fd26cbad6e7f84524ff56380eb"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:af00575fd26cbad6e7f84524ff56380eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; X2, X2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian222</b> (double(*f)(const X1 &amp;, const X2 &amp;), const X1 &amp;x1, const X2 &amp;x2, double delta=1e-5)</td></tr>
<tr class="separator:af00575fd26cbad6e7f84524ff56380eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10295660c0177e08d45812fbb7e4c554"><td class="memTemplParams" colspan="2"><a id="a10295660c0177e08d45812fbb7e4c554" name="a10295660c0177e08d45812fbb7e4c554"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a10295660c0177e08d45812fbb7e4c554"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; X1, X1 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian311</b> (std::function&lt; double(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; f, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double delta=1e-5)</td></tr>
<tr class="memdesc:a10295660c0177e08d45812fbb7e4c554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerical Hessian for tenary functions. <br /></td></tr>
<tr class="separator:a10295660c0177e08d45812fbb7e4c554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e4228e2f2c4f450d877d7a300ea424"><td class="memTemplParams" colspan="2"><a id="a74e4228e2f2c4f450d877d7a300ea424" name="a74e4228e2f2c4f450d877d7a300ea424"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a74e4228e2f2c4f450d877d7a300ea424"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; X1, X1 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian311</b> (double(*f)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double delta=1e-5)</td></tr>
<tr class="separator:a74e4228e2f2c4f450d877d7a300ea424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268ef755779fdbdb8053a5e7f0d093f9"><td class="memTemplParams" colspan="2"><a id="a268ef755779fdbdb8053a5e7f0d093f9" name="a268ef755779fdbdb8053a5e7f0d093f9"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a268ef755779fdbdb8053a5e7f0d093f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; X2, X2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian322</b> (std::function&lt; double(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; f, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double delta=1e-5)</td></tr>
<tr class="separator:a268ef755779fdbdb8053a5e7f0d093f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72130887f68361c56d12c971cba0b329"><td class="memTemplParams" colspan="2"><a id="a72130887f68361c56d12c971cba0b329" name="a72130887f68361c56d12c971cba0b329"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a72130887f68361c56d12c971cba0b329"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; X2, X2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian322</b> (double(*f)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double delta=1e-5)</td></tr>
<tr class="separator:a72130887f68361c56d12c971cba0b329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb09e37b76cc723800d2e39995a4db9e"><td class="memTemplParams" colspan="2"><a id="acb09e37b76cc723800d2e39995a4db9e" name="acb09e37b76cc723800d2e39995a4db9e"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:acb09e37b76cc723800d2e39995a4db9e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; X3, X3 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian333</b> (std::function&lt; double(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; f, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double delta=1e-5)</td></tr>
<tr class="separator:acb09e37b76cc723800d2e39995a4db9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c0e430095dc815b46e126d11342462"><td class="memTemplParams" colspan="2"><a id="ab2c0e430095dc815b46e126d11342462" name="ab2c0e430095dc815b46e126d11342462"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:ab2c0e430095dc815b46e126d11342462"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; X3, X3 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian333</b> (double(*f)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double delta=1e-5)</td></tr>
<tr class="separator:ab2c0e430095dc815b46e126d11342462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4372ede8831ecae084eb90a0018f5e8a"><td class="memTemplParams" colspan="2"><a id="a4372ede8831ecae084eb90a0018f5e8a" name="a4372ede8831ecae084eb90a0018f5e8a"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a4372ede8831ecae084eb90a0018f5e8a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; X1, X2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian312</b> (std::function&lt; double(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; f, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double delta=1e-5)</td></tr>
<tr class="separator:a4372ede8831ecae084eb90a0018f5e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352969ebba3df90e4c1d4c2986f0f0f3"><td class="memTemplParams" colspan="2"><a id="a352969ebba3df90e4c1d4c2986f0f0f3" name="a352969ebba3df90e4c1d4c2986f0f0f3"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a352969ebba3df90e4c1d4c2986f0f0f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; X1, X3 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian313</b> (std::function&lt; double(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; f, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double delta=1e-5)</td></tr>
<tr class="separator:a352969ebba3df90e4c1d4c2986f0f0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b3567991f1dcb460fd1df1c4b3ca31"><td class="memTemplParams" colspan="2"><a id="ac7b3567991f1dcb460fd1df1c4b3ca31" name="ac7b3567991f1dcb460fd1df1c4b3ca31"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:ac7b3567991f1dcb460fd1df1c4b3ca31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; X2, X3 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian323</b> (std::function&lt; double(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; f, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double delta=1e-5)</td></tr>
<tr class="separator:ac7b3567991f1dcb460fd1df1c4b3ca31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754347d1d518a3b3cff10c2e64e81eb0"><td class="memTemplParams" colspan="2"><a id="a754347d1d518a3b3cff10c2e64e81eb0" name="a754347d1d518a3b3cff10c2e64e81eb0"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a754347d1d518a3b3cff10c2e64e81eb0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; X1, X2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian312</b> (double(*f)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double delta=1e-5)</td></tr>
<tr class="separator:a754347d1d518a3b3cff10c2e64e81eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ee66c096fec8ceda474d072729a886"><td class="memTemplParams" colspan="2"><a id="a83ee66c096fec8ceda474d072729a886" name="a83ee66c096fec8ceda474d072729a886"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a83ee66c096fec8ceda474d072729a886"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; X1, X3 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian313</b> (double(*f)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double delta=1e-5)</td></tr>
<tr class="separator:a83ee66c096fec8ceda474d072729a886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96023b60d620919c932548377cc1ad26"><td class="memTemplParams" colspan="2"><a id="a96023b60d620919c932548377cc1ad26" name="a96023b60d620919c932548377cc1ad26"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a96023b60d620919c932548377cc1ad26"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; X2, X3 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian323</b> (double(*f)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double delta=1e-5)</td></tr>
<tr class="separator:a96023b60d620919c932548377cc1ad26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4a964885d404ce95952a426d6ec66f"><td class="memItemLeft" align="right" valign="top"><a id="acd4a964885d404ce95952a426d6ec66f" name="acd4a964885d404ce95952a426d6ec66f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print</b> (float v, const std::string &amp;s=&quot;&quot;)</td></tr>
<tr class="separator:acd4a964885d404ce95952a426d6ec66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18388d9f853471b852e9cb5c2f6e321d"><td class="memItemLeft" align="right" valign="top"><a id="a18388d9f853471b852e9cb5c2f6e321d" name="a18388d9f853471b852e9cb5c2f6e321d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print</b> (double v, const std::string &amp;s=&quot;&quot;)</td></tr>
<tr class="separator:a18388d9f853471b852e9cb5c2f6e321d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2dbee4a72127938c79162cc8b6d5152"><td class="memTemplParams" colspan="2"><a id="ad2dbee4a72127938c79162cc8b6d5152" name="ad2dbee4a72127938c79162cc8b6d5152"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad2dbee4a72127938c79162cc8b6d5152"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equal</b> (const T &amp;obj1, const T &amp;obj2, double tol)</td></tr>
<tr class="memdesc:ad2dbee4a72127938c79162cc8b6d5152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call equal on the object. <br /></td></tr>
<tr class="separator:ad2dbee4a72127938c79162cc8b6d5152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3dc67ad88b799c469088e428c583b1"><td class="memTemplParams" colspan="2"><a id="a1f3dc67ad88b799c469088e428c583b1" name="a1f3dc67ad88b799c469088e428c583b1"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1f3dc67ad88b799c469088e428c583b1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equal</b> (const T &amp;obj1, const T &amp;obj2)</td></tr>
<tr class="memdesc:a1f3dc67ad88b799c469088e428c583b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call equal without tolerance (use default tolerance) <br /></td></tr>
<tr class="separator:a1f3dc67ad88b799c469088e428c583b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659619cca082d1c10b07c033d48c54da"><td class="memTemplParams" colspan="2"><a id="a659619cca082d1c10b07c033d48c54da" name="a659619cca082d1c10b07c033d48c54da"></a>
template&lt;class V &gt; </td></tr>
<tr class="memitem:a659619cca082d1c10b07c033d48c54da"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assert_equal</b> (const V &amp;expected, const V &amp;actual, double tol=1e-9)</td></tr>
<tr class="memdesc:a659619cca082d1c10b07c033d48c54da"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template works for any type with equals. <br /></td></tr>
<tr class="separator:a659619cca082d1c10b07c033d48c54da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982034802415eb6e9bd02355257ed96a"><td class="memItemLeft" align="right" valign="top"><a id="a982034802415eb6e9bd02355257ed96a" name="a982034802415eb6e9bd02355257ed96a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>assert_equal</b> (const <a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a> &amp;expected, const <a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a> &amp;actual, double tol=0.0)</td></tr>
<tr class="memdesc:a982034802415eb6e9bd02355257ed96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equals testing for basic types. <br /></td></tr>
<tr class="separator:a982034802415eb6e9bd02355257ed96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6d6575582314cc9b5dbdbe2a86374d"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:add6d6575582314cc9b5dbdbe2a86374d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#add6d6575582314cc9b5dbdbe2a86374d">assert_equal</a> (const boost::optional&lt; V &gt; &amp;expected, const boost::optional&lt; V &gt; &amp;actual, double tol=1e-9)</td></tr>
<tr class="memdesc:add6d6575582314cc9b5dbdbe2a86374d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparisons for boost.optional objects that checks whether objects exist before comparing their values.  <a href="a01596.html#add6d6575582314cc9b5dbdbe2a86374d">More...</a><br /></td></tr>
<tr class="separator:add6d6575582314cc9b5dbdbe2a86374d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb156f7b9ac630cc6fd956b386cf1dab"><td class="memTemplParams" colspan="2"><a id="abb156f7b9ac630cc6fd956b386cf1dab" name="abb156f7b9ac630cc6fd956b386cf1dab"></a>
template&lt;class V &gt; </td></tr>
<tr class="memitem:abb156f7b9ac630cc6fd956b386cf1dab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assert_equal</b> (const V &amp;expected, const boost::optional&lt; V &gt; &amp;actual, double tol=1e-9)</td></tr>
<tr class="separator:abb156f7b9ac630cc6fd956b386cf1dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5242be27f83219abc3f9793975986a35"><td class="memTemplParams" colspan="2"><a id="a5242be27f83219abc3f9793975986a35" name="a5242be27f83219abc3f9793975986a35"></a>
template&lt;class V &gt; </td></tr>
<tr class="memitem:a5242be27f83219abc3f9793975986a35"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assert_equal</b> (const V &amp;expected, const boost::optional&lt; const V &amp; &gt; &amp;actual, double tol=1e-9)</td></tr>
<tr class="separator:a5242be27f83219abc3f9793975986a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bbdbded37ed58ebbabe6c16d66a61d9"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:a6bbdbded37ed58ebbabe6c16d66a61d9"><td class="memTemplItemLeft" align="right" valign="top">bool GTSAM_DEPRECATED&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a6bbdbded37ed58ebbabe6c16d66a61d9">assert_equal</a> (const std::vector&lt; V &gt; &amp;expected, const std::vector&lt; V &gt; &amp;actual, double tol=1e-9)</td></tr>
<tr class="memdesc:a6bbdbded37ed58ebbabe6c16d66a61d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of assert_equals to work with vectors.  <a href="a01596.html#a6bbdbded37ed58ebbabe6c16d66a61d9">More...</a><br /></td></tr>
<tr class="separator:a6bbdbded37ed58ebbabe6c16d66a61d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254be27d6d4b416fa2b546c77ae783fc"><td class="memTemplParams" colspan="2"><a id="a254be27d6d4b416fa2b546c77ae783fc" name="a254be27d6d4b416fa2b546c77ae783fc"></a>
template&lt;class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a254be27d6d4b416fa2b546c77ae783fc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assert_container_equal</b> (const std::map&lt; V1, V2 &gt; &amp;expected, const std::map&lt; V1, V2 &gt; &amp;actual, double tol=1e-9)</td></tr>
<tr class="memdesc:a254be27d6d4b416fa2b546c77ae783fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for comparing maps of testable-&gt;testable TODO: replace with more generalized version. <br /></td></tr>
<tr class="separator:a254be27d6d4b416fa2b546c77ae783fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f509195ea2180d0f7dbd3a99a088ff4"><td class="memTemplParams" colspan="2"><a id="a2f509195ea2180d0f7dbd3a99a088ff4" name="a2f509195ea2180d0f7dbd3a99a088ff4"></a>
template&lt;class V2 &gt; </td></tr>
<tr class="memitem:a2f509195ea2180d0f7dbd3a99a088ff4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assert_container_equal</b> (const std::map&lt; size_t, V2 &gt; &amp;expected, const std::map&lt; size_t, V2 &gt; &amp;actual, double tol=1e-9)</td></tr>
<tr class="memdesc:a2f509195ea2180d0f7dbd3a99a088ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for comparing maps of size_t-&gt;testable. <br /></td></tr>
<tr class="separator:a2f509195ea2180d0f7dbd3a99a088ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eec17f894b358dd9f30d7af28082ba5"><td class="memTemplParams" colspan="2"><a id="a0eec17f894b358dd9f30d7af28082ba5" name="a0eec17f894b358dd9f30d7af28082ba5"></a>
template&lt;class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a0eec17f894b358dd9f30d7af28082ba5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assert_container_equal</b> (const std::vector&lt; std::pair&lt; V1, V2 &gt; &gt; &amp;expected, const std::vector&lt; std::pair&lt; V1, V2 &gt; &gt; &amp;actual, double tol=1e-9)</td></tr>
<tr class="memdesc:a0eec17f894b358dd9f30d7af28082ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for comparing vector of pairs (testable, testable) <br /></td></tr>
<tr class="separator:a0eec17f894b358dd9f30d7af28082ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6b2964354593f69848f6bf5d3e0ca1"><td class="memTemplParams" colspan="2"><a id="a6d6b2964354593f69848f6bf5d3e0ca1" name="a6d6b2964354593f69848f6bf5d3e0ca1"></a>
template&lt;class V &gt; </td></tr>
<tr class="memitem:a6d6b2964354593f69848f6bf5d3e0ca1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assert_container_equal</b> (const V &amp;expected, const V &amp;actual, double tol=1e-9)</td></tr>
<tr class="memdesc:a6d6b2964354593f69848f6bf5d3e0ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">General function for comparing containers of testable objects. <br /></td></tr>
<tr class="separator:a6d6b2964354593f69848f6bf5d3e0ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ba6a7db27344c5cb021f1421905020"><td class="memTemplParams" colspan="2"><a id="a59ba6a7db27344c5cb021f1421905020" name="a59ba6a7db27344c5cb021f1421905020"></a>
template&lt;class V2 &gt; </td></tr>
<tr class="memitem:a59ba6a7db27344c5cb021f1421905020"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assert_container_equality</b> (const std::map&lt; size_t, V2 &gt; &amp;expected, const std::map&lt; size_t, V2 &gt; &amp;actual)</td></tr>
<tr class="memdesc:a59ba6a7db27344c5cb021f1421905020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for comparing maps of size_t-&gt;testable Types are assumed to have operator ==. <br /></td></tr>
<tr class="separator:a59ba6a7db27344c5cb021f1421905020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0926a5d779171bd8e1d30fb5982b5c0"><td class="memTemplParams" colspan="2"><a id="aa0926a5d779171bd8e1d30fb5982b5c0" name="aa0926a5d779171bd8e1d30fb5982b5c0"></a>
template&lt;class V &gt; </td></tr>
<tr class="memitem:aa0926a5d779171bd8e1d30fb5982b5c0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assert_container_equality</b> (const V &amp;expected, const V &amp;actual)</td></tr>
<tr class="memdesc:aa0926a5d779171bd8e1d30fb5982b5c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">General function for comparing containers of objects with operator==. <br /></td></tr>
<tr class="separator:aa0926a5d779171bd8e1d30fb5982b5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e760bc75888053afd86a27d56b6148"><td class="memItemLeft" align="right" valign="top"><a id="a21e760bc75888053afd86a27d56b6148" name="a21e760bc75888053afd86a27d56b6148"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>assert_equal</b> (const std::string &amp;expected, const std::string &amp;actual)</td></tr>
<tr class="memdesc:a21e760bc75888053afd86a27d56b6148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare strings for unit tests. <br /></td></tr>
<tr class="separator:a21e760bc75888053afd86a27d56b6148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f19ba6625a264457805513fefcb5c32"><td class="memTemplParams" colspan="2"><a id="a2f19ba6625a264457805513fefcb5c32" name="a2f19ba6625a264457805513fefcb5c32"></a>
template&lt;class V &gt; </td></tr>
<tr class="memitem:a2f19ba6625a264457805513fefcb5c32"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assert_inequal</b> (const V &amp;expected, const V &amp;actual, double tol=1e-9)</td></tr>
<tr class="memdesc:a2f19ba6625a264457805513fefcb5c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow for testing inequality. <br /></td></tr>
<tr class="separator:a2f19ba6625a264457805513fefcb5c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08641f0f7145716bba9159dd95099a44"><td class="memTemplParams" colspan="2"><a id="a08641f0f7145716bba9159dd95099a44" name="a08641f0f7145716bba9159dd95099a44"></a>
template&lt;class V &gt; </td></tr>
<tr class="memitem:a08641f0f7145716bba9159dd95099a44"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assert_stdout_equal</b> (const std::string &amp;expected, const V &amp;actual)</td></tr>
<tr class="memdesc:a08641f0f7145716bba9159dd95099a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capture std out via cout stream and compare against string. <br /></td></tr>
<tr class="separator:a08641f0f7145716bba9159dd95099a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830c8c65902d7d0e763562e6c9357346"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:a830c8c65902d7d0e763562e6c9357346"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a830c8c65902d7d0e763562e6c9357346">assert_print_equal</a> (const std::string &amp;expected, const V &amp;actual, const std::string &amp;s=&quot;&quot;)</td></tr>
<tr class="memdesc:a830c8c65902d7d0e763562e6c9357346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capture print function output and compare against string.  <a href="a01596.html#a830c8c65902d7d0e763562e6c9357346">More...</a><br /></td></tr>
<tr class="separator:a830c8c65902d7d0e763562e6c9357346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b21c317684ba3dd6a06ee3acffc31e9"><td class="memTemplParams" colspan="2"><a id="a5b21c317684ba3dd6a06ee3acffc31e9" name="a5b21c317684ba3dd6a06ee3acffc31e9"></a>
template&lt;typename G &gt; </td></tr>
<tr class="memitem:a5b21c317684ba3dd6a06ee3acffc31e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>testLieGroupDerivatives</b> (TestResult &amp;result_, const std::string &amp;name_, const G &amp;t1, const G &amp;t2)</td></tr>
<tr class="separator:a5b21c317684ba3dd6a06ee3acffc31e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c0b66f7e195dd7407cf286828c6af8"><td class="memTemplParams" colspan="2"><a id="a53c0b66f7e195dd7407cf286828c6af8" name="a53c0b66f7e195dd7407cf286828c6af8"></a>
template&lt;typename G &gt; </td></tr>
<tr class="memitem:a53c0b66f7e195dd7407cf286828c6af8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>testChartDerivatives</b> (TestResult &amp;result_, const std::string &amp;name_, const G &amp;t1, const G &amp;t2)</td></tr>
<tr class="separator:a53c0b66f7e195dd7407cf286828c6af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3230ae4ee4a803cf8d837ea66a735703"><td class="memItemLeft" align="right" valign="top"><a id="a3230ae4ee4a803cf8d837ea66a735703" name="a3230ae4ee4a803cf8d837ea66a735703"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tictoc_finishedIteration_</b> ()</td></tr>
<tr class="separator:a3230ae4ee4a803cf8d837ea66a735703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4733cdc946435aef61a5478b201d1042"><td class="memItemLeft" align="right" valign="top"><a id="a4733cdc946435aef61a5478b201d1042" name="a4733cdc946435aef61a5478b201d1042"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tictoc_print_</b> ()</td></tr>
<tr class="separator:a4733cdc946435aef61a5478b201d1042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7945a7256f5f54c8fcf0c2aa1bf4b3f9"><td class="memItemLeft" align="right" valign="top"><a id="a7945a7256f5f54c8fcf0c2aa1bf4b3f9" name="a7945a7256f5f54c8fcf0c2aa1bf4b3f9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tictoc_print2_</b> ()</td></tr>
<tr class="separator:a7945a7256f5f54c8fcf0c2aa1bf4b3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e469989c2312c6c5ccb33b1202ef41"><td class="memItemLeft" align="right" valign="top"><a id="a05e469989c2312c6c5ccb33b1202ef41" name="a05e469989c2312c6c5ccb33b1202ef41"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tictoc_reset_</b> ()</td></tr>
<tr class="separator:a05e469989c2312c6c5ccb33b1202ef41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b97fc96e5f69236e81489c66d5b92ba"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a0b97fc96e5f69236e81489c66d5b92ba">demangle</a> (const char *name)</td></tr>
<tr class="memdesc:a0b97fc96e5f69236e81489c66d5b92ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty print <a class="el" href="a02740.html" title="This is the base class for any type to be stored in Values.">Value</a> type name.  <a href="a01596.html#a0b97fc96e5f69236e81489c66d5b92ba">More...</a><br /></td></tr>
<tr class="separator:a0b97fc96e5f69236e81489c66d5b92ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac272566642a6375b8981b8620f6d7cc5"><td class="memItemLeft" align="right" valign="top"><a id="ac272566642a6375b8981b8620f6d7cc5" name="ac272566642a6375b8981b8620f6d7cc5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_CONCEPT_ASSERT</b> ((boost::RandomAccessRangeConcept&lt; <a class="el" href="a02720.html">ListOfOneContainer</a>&lt; int &gt; &gt;))</td></tr>
<tr class="separator:ac272566642a6375b8981b8620f6d7cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045b43784acac77531813c4ab6c4d281"><td class="memTemplParams" colspan="2"><a id="a045b43784acac77531813c4ab6c4d281" name="a045b43784acac77531813c4ab6c4d281"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a045b43784acac77531813c4ab6c4d281"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02720.html">ListOfOneContainer</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ListOfOne</b> (const T &amp;element)</td></tr>
<tr class="memdesc:a045b43784acac77531813c4ab6c4d281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function for <a class="el" href="a02720.html" title="A helper class that behaves as a container with one element, and works with boost::range.">ListOfOneContainer</a> to enable ListOfOne(e) syntax. <br /></td></tr>
<tr class="separator:a045b43784acac77531813c4ab6c4d281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19c359190a379cba44bf818a2293f7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#ae19c359190a379cba44bf818a2293f7c">fpEqual</a> (double a, double b, double tol, bool check_relative_also=true)</td></tr>
<tr class="memdesc:ae19c359190a379cba44bf818a2293f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure we are not including a different version of Eigen in user code than while compiling gtsam, since it can lead to hard-to-understand runtime crashes.  <a href="a01596.html#ae19c359190a379cba44bf818a2293f7c">More...</a><br /></td></tr>
<tr class="separator:ae19c359190a379cba44bf818a2293f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760cc36e9009b23cf564c436294b3504"><td class="memItemLeft" align="right" valign="top"><a id="a760cc36e9009b23cf564c436294b3504" name="a760cc36e9009b23cf564c436294b3504"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print</b> (const Vector &amp;v, const std::string &amp;s, std::ostream &amp;stream)</td></tr>
<tr class="memdesc:a760cc36e9009b23cf564c436294b3504"><td class="mdescLeft">&#160;</td><td class="mdescRight">print without optional string, must specify cout yourself <br /></td></tr>
<tr class="separator:a760cc36e9009b23cf564c436294b3504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5d8018a0f44a6a299406aeda27d44b"><td class="memItemLeft" align="right" valign="top"><a id="a5e5d8018a0f44a6a299406aeda27d44b" name="a5e5d8018a0f44a6a299406aeda27d44b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print</b> (const Vector &amp;v, const std::string &amp;s=&quot;&quot;)</td></tr>
<tr class="memdesc:a5e5d8018a0f44a6a299406aeda27d44b"><td class="mdescLeft">&#160;</td><td class="mdescRight">print with optional string to cout <br /></td></tr>
<tr class="separator:a5e5d8018a0f44a6a299406aeda27d44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f2bbdb9f9d633542362dbe8d79f9ab"><td class="memItemLeft" align="right" valign="top"><a id="a09f2bbdb9f9d633542362dbe8d79f9ab" name="a09f2bbdb9f9d633542362dbe8d79f9ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>save</b> (const Vector &amp;A, const std::string &amp;s, const std::string &amp;filename)</td></tr>
<tr class="memdesc:a09f2bbdb9f9d633542362dbe8d79f9ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">save a vector to file, which can be loaded by matlab <br /></td></tr>
<tr class="separator:a09f2bbdb9f9d633542362dbe8d79f9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64988014ab746343803620dc42513646"><td class="memItemLeft" align="right" valign="top"><a id="a64988014ab746343803620dc42513646" name="a64988014ab746343803620dc42513646"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const Vector &amp;vec1, const Vector &amp;vec2)</td></tr>
<tr class="memdesc:a64988014ab746343803620dc42513646"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a01596.html#afd5b3cf3f54adcbdd6d9e7403f1a792f" title="equality is just equal_with_abs_tol 1e-9">operator==()</a> <br /></td></tr>
<tr class="separator:a64988014ab746343803620dc42513646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368ee40bd9c0124d572d2e49bcb077bf"><td class="memItemLeft" align="right" valign="top"><a id="a368ee40bd9c0124d572d2e49bcb077bf" name="a368ee40bd9c0124d572d2e49bcb077bf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>greaterThanOrEqual</b> (const Vector &amp;v1, const Vector &amp;v2)</td></tr>
<tr class="memdesc:a368ee40bd9c0124d572d2e49bcb077bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than or equal to operation returns true if all elements in v1 are greater than corresponding elements in v2. <br /></td></tr>
<tr class="separator:a368ee40bd9c0124d572d2e49bcb077bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bdced1844ffd6a53af0396d82eaa6da"><td class="memItemLeft" align="right" valign="top"><a id="a8bdced1844ffd6a53af0396d82eaa6da" name="a8bdced1844ffd6a53af0396d82eaa6da"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>equal_with_abs_tol</b> (const Vector &amp;vec1, const Vector &amp;vec2, double tol=1e-9)</td></tr>
<tr class="memdesc:a8bdced1844ffd6a53af0396d82eaa6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">VecA == VecB up to tolerance. <br /></td></tr>
<tr class="separator:a8bdced1844ffd6a53af0396d82eaa6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14034da7e28c95db712ec344d4a2ffaf"><td class="memItemLeft" align="right" valign="top"><a id="a14034da7e28c95db712ec344d4a2ffaf" name="a14034da7e28c95db712ec344d4a2ffaf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>equal_with_abs_tol</b> (const SubVector &amp;vec1, const SubVector &amp;vec2, double tol)</td></tr>
<tr class="separator:a14034da7e28c95db712ec344d4a2ffaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3ee662d25ffb8c04b4e35c4b02e90b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a9f3ee662d25ffb8c04b4e35c4b02e90b">assert_equal</a> (const Vector &amp;vec1, const Vector &amp;vec2, double tol=1e-9)</td></tr>
<tr class="memdesc:a9f3ee662d25ffb8c04b4e35c4b02e90b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same, prints if error.  <a href="a01596.html#a9f3ee662d25ffb8c04b4e35c4b02e90b">More...</a><br /></td></tr>
<tr class="separator:a9f3ee662d25ffb8c04b4e35c4b02e90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca3db47b15350977c1f03c5560ab332"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a2ca3db47b15350977c1f03c5560ab332">assert_inequal</a> (const Vector &amp;vec1, const Vector &amp;vec2, double tol=1e-9)</td></tr>
<tr class="memdesc:a2ca3db47b15350977c1f03c5560ab332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not the same, prints if error.  <a href="a01596.html#a2ca3db47b15350977c1f03c5560ab332">More...</a><br /></td></tr>
<tr class="separator:a2ca3db47b15350977c1f03c5560ab332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3cf8e8e70cd696d9c789c31bc1e89a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#ac3cf8e8e70cd696d9c789c31bc1e89a7">assert_equal</a> (const SubVector &amp;vec1, const SubVector &amp;vec2, double tol=1e-9)</td></tr>
<tr class="memdesc:ac3cf8e8e70cd696d9c789c31bc1e89a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same, prints if error.  <a href="a01596.html#ac3cf8e8e70cd696d9c789c31bc1e89a7">More...</a><br /></td></tr>
<tr class="separator:ac3cf8e8e70cd696d9c789c31bc1e89a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95292df1087c65aa5b5388bf4c11842"><td class="memItemLeft" align="right" valign="top"><a id="ac95292df1087c65aa5b5388bf4c11842" name="ac95292df1087c65aa5b5388bf4c11842"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>assert_equal</b> (const ConstSubVector &amp;expected, const ConstSubVector &amp;actual, double tol)</td></tr>
<tr class="separator:ac95292df1087c65aa5b5388bf4c11842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0cfd7908b06491df49b6a9c9186775"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a2a0cfd7908b06491df49b6a9c9186775">linear_dependent</a> (const Vector &amp;vec1, const Vector &amp;vec2, double tol=1e-9)</td></tr>
<tr class="memdesc:a2a0cfd7908b06491df49b6a9c9186775"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether two vectors are linearly dependent  <a href="a01596.html#a2a0cfd7908b06491df49b6a9c9186775">More...</a><br /></td></tr>
<tr class="separator:a2a0cfd7908b06491df49b6a9c9186775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14844c96706dc362917e0d5e76d65fbe"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a14844c96706dc362917e0d5e76d65fbe">ediv_</a> (const Vector &amp;a, const Vector &amp;b)</td></tr>
<tr class="memdesc:a14844c96706dc362917e0d5e76d65fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">elementwise division, but 0/0 = 0, not inf  <a href="a01596.html#a14844c96706dc362917e0d5e76d65fbe">More...</a><br /></td></tr>
<tr class="separator:a14844c96706dc362917e0d5e76d65fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c0c05b0198ec0fb6e4115edb755910"><td class="memItemLeft" align="right" valign="top"><a id="ac9c0c05b0198ec0fb6e4115edb755910" name="ac9c0c05b0198ec0fb6e4115edb755910"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>houseInPlace</b> (Vector &amp;x)</td></tr>
<tr class="memdesc:ac9c0c05b0198ec0fb6e4115edb755910"><td class="mdescLeft">&#160;</td><td class="mdescRight">beta = house(x) computes the HouseHolder vector in place <br /></td></tr>
<tr class="separator:ac9c0c05b0198ec0fb6e4115edb755910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb77eefc25dea0fb3e0fcc8f246b617a"><td class="memItemLeft" align="right" valign="top">pair&lt; double, Vector &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#afb77eefc25dea0fb3e0fcc8f246b617a">house</a> (const Vector &amp;x)</td></tr>
<tr class="memdesc:afb77eefc25dea0fb3e0fcc8f246b617a"><td class="mdescLeft">&#160;</td><td class="mdescRight">house(x,j) computes HouseHolder vector v and scaling factor beta from x, such that the corresponding Householder reflection zeroes out all but x.  <a href="a01596.html#afb77eefc25dea0fb3e0fcc8f246b617a">More...</a><br /></td></tr>
<tr class="separator:afb77eefc25dea0fb3e0fcc8f246b617a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3f9d6140621a7e935f051d8fb23284"><td class="memItemLeft" align="right" valign="top"><a id="aca3f9d6140621a7e935f051d8fb23284" name="aca3f9d6140621a7e935f051d8fb23284"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>weightedPseudoinverse</b> (const Vector &amp;a, const Vector &amp;weights, Vector &amp;pseudo)</td></tr>
<tr class="separator:aca3f9d6140621a7e935f051d8fb23284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1c56d11a05464a7a5458dc32ccc777"><td class="memItemLeft" align="right" valign="top">pair&lt; Vector, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#aca1c56d11a05464a7a5458dc32ccc777">weightedPseudoinverse</a> (const Vector &amp;v, const Vector &amp;weights)</td></tr>
<tr class="memdesc:aca1c56d11a05464a7a5458dc32ccc777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weighted Householder solution vector, a.k.a., the pseudoinverse of the column NOTE: if any sigmas are zero (indicating a constraint) the pseudoinverse will be a selection vector, and the variance will be zero.  <a href="a01596.html#aca1c56d11a05464a7a5458dc32ccc777">More...</a><br /></td></tr>
<tr class="separator:aca1c56d11a05464a7a5458dc32ccc777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c88acfa9575bcea3f2e738cb637a85"><td class="memItemLeft" align="right" valign="top"><a id="ae1c88acfa9575bcea3f2e738cb637a85" name="ae1c88acfa9575bcea3f2e738cb637a85"></a>
Vector&#160;</td><td class="memItemRight" valign="bottom"><b>concatVectors</b> (const std::list&lt; Vector &gt; &amp;vs)</td></tr>
<tr class="memdesc:ae1c88acfa9575bcea3f2e738cb637a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">concatenate Vectors <br /></td></tr>
<tr class="separator:ae1c88acfa9575bcea3f2e738cb637a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09610ec69a8b3f3a00399bb378eda9cf"><td class="memItemLeft" align="right" valign="top"><a id="a09610ec69a8b3f3a00399bb378eda9cf" name="a09610ec69a8b3f3a00399bb378eda9cf"></a>
Vector&#160;</td><td class="memItemRight" valign="bottom"><b>concatVectors</b> (size_t nrVectors,...)</td></tr>
<tr class="memdesc:a09610ec69a8b3f3a00399bb378eda9cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">concatenate Vectors <br /></td></tr>
<tr class="separator:a09610ec69a8b3f3a00399bb378eda9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ed1d4fe2dd6828cfeb2d8f488b818d"><td class="memItemLeft" align="right" valign="top"><a id="aa7ed1d4fe2dd6828cfeb2d8f488b818d" name="aa7ed1d4fe2dd6828cfeb2d8f488b818d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>equal</b> (const Vector &amp;vec1, const Vector &amp;vec2, double tol)</td></tr>
<tr class="memdesc:aa7ed1d4fe2dd6828cfeb2d8f488b818d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override of equal in <a class="el" href="a00131.html" title="Base class and basic functions for Lie types.">Lie.h</a>. <br /></td></tr>
<tr class="separator:aa7ed1d4fe2dd6828cfeb2d8f488b818d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1cad2313f69f9fa5008fdc348d1526"><td class="memItemLeft" align="right" valign="top"><a id="a3d1cad2313f69f9fa5008fdc348d1526" name="a3d1cad2313f69f9fa5008fdc348d1526"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>equal</b> (const Vector &amp;vec1, const Vector &amp;vec2)</td></tr>
<tr class="memdesc:a3d1cad2313f69f9fa5008fdc348d1526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override of equal in <a class="el" href="a00131.html" title="Base class and basic functions for Lie types.">Lie.h</a>. <br /></td></tr>
<tr class="separator:a3d1cad2313f69f9fa5008fdc348d1526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80249acf12bbea741e755cd8fc73042"><td class="memTemplParams" colspan="2"><a id="ad80249acf12bbea741e755cd8fc73042" name="ad80249acf12bbea741e755cd8fc73042"></a>
template&lt;class V1 , class V2 &gt; </td></tr>
<tr class="memitem:ad80249acf12bbea741e755cd8fc73042"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dot</b> (const V1 &amp;a, const V2 &amp;b)</td></tr>
<tr class="memdesc:ad80249acf12bbea741e755cd8fc73042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product. <br /></td></tr>
<tr class="separator:ad80249acf12bbea741e755cd8fc73042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca41ba9ec9d6d21a2b9f5e00f9f25ed"><td class="memTemplParams" colspan="2"><a id="a4ca41ba9ec9d6d21a2b9f5e00f9f25ed" name="a4ca41ba9ec9d6d21a2b9f5e00f9f25ed"></a>
template&lt;class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a4ca41ba9ec9d6d21a2b9f5e00f9f25ed"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inner_prod</b> (const V1 &amp;a, const V2 &amp;b)</td></tr>
<tr class="memdesc:a4ca41ba9ec9d6d21a2b9f5e00f9f25ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">compatibility version for ublas' <a class="el" href="a01596.html#a4ca41ba9ec9d6d21a2b9f5e00f9f25ed" title="compatibility version for ublas&#39; inner_prod()">inner_prod()</a> <br /></td></tr>
<tr class="separator:a4ca41ba9ec9d6d21a2b9f5e00f9f25ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf40203c6d7820aa6ddf23cdbbd770f"><td class="memItemLeft" align="right" valign="top">void GTSAM_DEPRECATED&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a9bf40203c6d7820aa6ddf23cdbbd770f">scal</a> (double alpha, Vector &amp;x)</td></tr>
<tr class="memdesc:a9bf40203c6d7820aa6ddf23cdbbd770f"><td class="mdescLeft">&#160;</td><td class="mdescRight">BLAS Level 1 scal: x &lt;- alpha*x.  <a href="a01596.html#a9bf40203c6d7820aa6ddf23cdbbd770f">More...</a><br /></td></tr>
<tr class="separator:a9bf40203c6d7820aa6ddf23cdbbd770f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55c9458246c733317a7dfad7f9f813a"><td class="memTemplParams" colspan="2">template&lt;class V1 , class V2 &gt; </td></tr>
<tr class="memitem:af55c9458246c733317a7dfad7f9f813a"><td class="memTemplItemLeft" align="right" valign="top">void GTSAM_DEPRECATED&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#af55c9458246c733317a7dfad7f9f813a">axpy</a> (double alpha, const V1 &amp;x, V2 &amp;y)</td></tr>
<tr class="memdesc:af55c9458246c733317a7dfad7f9f813a"><td class="mdescLeft">&#160;</td><td class="mdescRight">BLAS Level 1 axpy: y &lt;- alpha*x + y.  <a href="a01596.html#af55c9458246c733317a7dfad7f9f813a">More...</a><br /></td></tr>
<tr class="separator:af55c9458246c733317a7dfad7f9f813a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6947eb9313cdaf0a67bbc333e57e387f"><td class="memItemLeft" align="right" valign="top"><a id="a6947eb9313cdaf0a67bbc333e57e387f" name="a6947eb9313cdaf0a67bbc333e57e387f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>axpy</b> (double alpha, const Vector &amp;x, SubVector y)</td></tr>
<tr class="separator:a6947eb9313cdaf0a67bbc333e57e387f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce44d31cae1eda44c2a86d32d92b935"><td class="memTemplParams" colspan="2">template&lt;size_t M&gt; </td></tr>
<tr class="memitem:a2ce44d31cae1eda44c2a86d32d92b935"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a2ce44d31cae1eda44c2a86d32d92b935">kroneckerProductIdentity</a> (const Weights &amp;w)</td></tr>
<tr class="memdesc:a2ce44d31cae1eda44c2a86d32d92b935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for computing the kronecker product of the 1*N Weight vector <code>w</code> with the MxM identity matrix <code>I</code> efficiently.  <a href="a01596.html#a2ce44d31cae1eda44c2a86d32d92b935">More...</a><br /></td></tr>
<tr class="separator:a2ce44d31cae1eda44c2a86d32d92b935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1103d3fad113e53d2746412ce08e633c"><td class="memTemplParams" colspan="2"><a id="a1103d3fad113e53d2746412ce08e633c" name="a1103d3fad113e53d2746412ce08e633c"></a>
template&lt;int M&gt; </td></tr>
<tr class="memitem:a1103d3fad113e53d2746412ce08e633c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="a02896.html">ParameterMatrix</a>&lt; M &gt; &amp;parameterMatrix)</td></tr>
<tr class="separator:a1103d3fad113e53d2746412ce08e633c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec77610fa3e4905d142a72b2199158db"><td class="memTemplParams" colspan="2">template&lt;typename L &gt; </td></tr>
<tr class="memitem:aec77610fa3e4905d142a72b2199158db"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a02912.html">Assignment</a>&lt; L &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#aec77610fa3e4905d142a72b2199158db">cartesianProduct</a> (const std::vector&lt; std::pair&lt; L, size_t &gt; &gt; &amp;keys)</td></tr>
<tr class="memdesc:aec77610fa3e4905d142a72b2199158db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Cartesian product consisting all possible configurations.  <a href="a01596.html#aec77610fa3e4905d142a72b2199158db">More...</a><br /></td></tr>
<tr class="separator:aec77610fa3e4905d142a72b2199158db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19a5c8f7d997b0b16cf646659834b0f"><td class="memTemplParams" colspan="2"><a id="ad19a5c8f7d997b0b16cf646659834b0f" name="ad19a5c8f7d997b0b16cf646659834b0f"></a>
template&lt;typename Y , typename L &gt; </td></tr>
<tr class="memitem:ad19a5c8f7d997b0b16cf646659834b0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02924.html">DecisionTree</a>&lt; L, Y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply</b> (const <a class="el" href="a02924.html">DecisionTree</a>&lt; L, Y &gt; &amp;f, const typename <a class="el" href="a02924.html">DecisionTree</a>&lt; L, Y &gt;::Unary &amp;op)</td></tr>
<tr class="memdesc:ad19a5c8f7d997b0b16cf646659834b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">free versions of apply <br /></td></tr>
<tr class="separator:ad19a5c8f7d997b0b16cf646659834b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae890a8919b441443ffdc0d8ab047838d"><td class="memTemplParams" colspan="2"><a id="ae890a8919b441443ffdc0d8ab047838d" name="ae890a8919b441443ffdc0d8ab047838d"></a>
template&lt;typename Y , typename L &gt; </td></tr>
<tr class="memitem:ae890a8919b441443ffdc0d8ab047838d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02924.html">DecisionTree</a>&lt; L, Y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply</b> (const <a class="el" href="a02924.html">DecisionTree</a>&lt; L, Y &gt; &amp;f, const <a class="el" href="a02924.html">DecisionTree</a>&lt; L, Y &gt; &amp;g, const typename <a class="el" href="a02924.html">DecisionTree</a>&lt; L, Y &gt;::Binary &amp;op)</td></tr>
<tr class="separator:ae890a8919b441443ffdc0d8ab047838d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0767417e558bbac14f3b27bc54d033e9"><td class="memItemLeft" align="right" valign="top"><a id="a0767417e558bbac14f3b27bc54d033e9" name="a0767417e558bbac14f3b27bc54d033e9"></a>
std::pair&lt; <a class="el" href="a02956.html#a4d8b3999aa607019946cbcfd255c09dd">DiscreteConditional::shared_ptr</a>, DecisionTreeFactor::shared_ptr &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EliminateDiscrete</b> (const <a class="el" href="a02984.html">DiscreteFactorGraph</a> &amp;factors, const <a class="el" href="a03632.html">Ordering</a> &amp;keys)</td></tr>
<tr class="memdesc:a0767417e558bbac14f3b27bc54d033e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main elimination function for <a class="el" href="a02984.html" title="A Discrete Factor Graph is a factor graph where all factors are Discrete, i.e.">DiscreteFactorGraph</a>. <br /></td></tr>
<tr class="separator:a0767417e558bbac14f3b27bc54d033e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be4f243161c2fd937df60aee511eb16"><td class="memItemLeft" align="right" valign="top"><a id="a0be4f243161c2fd937df60aee511eb16" name="a0be4f243161c2fd937df60aee511eb16"></a>
<a class="el" href="a02996.html">DiscreteKeys</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator&amp;</b> (const <a class="el" href="a01596.html#acd19e5d1e5d06c37246d4c15af38ee67">DiscreteKey</a> &amp;key1, const <a class="el" href="a01596.html#acd19e5d1e5d06c37246d4c15af38ee67">DiscreteKey</a> &amp;key2)</td></tr>
<tr class="memdesc:a0be4f243161c2fd937df60aee511eb16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a list from two keys. <br /></td></tr>
<tr class="separator:a0be4f243161c2fd937df60aee511eb16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb908dc2c6a21befce6367d4d23b0395"><td class="memItemLeft" align="right" valign="top"><a id="acb908dc2c6a21befce6367d4d23b0395" name="acb908dc2c6a21befce6367d4d23b0395"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const <a class="el" href="a03020.html#a058b129adfd1cdb887c88efedf2c8ca3">Signature::Row</a> &amp;<a class="el" href="a01596.html#a2754f325c8600303d627d9e8cf1f9949">row</a>)</td></tr>
<tr class="separator:acb908dc2c6a21befce6367d4d23b0395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfddcad865daa78da5a604b1306e889e"><td class="memItemLeft" align="right" valign="top"><a id="abfddcad865daa78da5a604b1306e889e" name="abfddcad865daa78da5a604b1306e889e"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const Signature::Table &amp;table)</td></tr>
<tr class="separator:abfddcad865daa78da5a604b1306e889e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adffe855c98c461676f292c8dbd663526"><td class="memItemLeft" align="right" valign="top"><a id="adffe855c98c461676f292c8dbd663526" name="adffe855c98c461676f292c8dbd663526"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const <a class="el" href="a03020.html">Signature</a> &amp;s)</td></tr>
<tr class="separator:adffe855c98c461676f292c8dbd663526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c58dfb2fc9398a026e3268ba2edfad"><td class="memItemLeft" align="right" valign="top"><a id="aa6c58dfb2fc9398a026e3268ba2edfad" name="aa6c58dfb2fc9398a026e3268ba2edfad"></a>
<a class="el" href="a03020.html">Signature</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator|</b> (const <a class="el" href="a01596.html#acd19e5d1e5d06c37246d4c15af38ee67">DiscreteKey</a> &amp;key, const <a class="el" href="a01596.html#acd19e5d1e5d06c37246d4c15af38ee67">DiscreteKey</a> &amp;parent)</td></tr>
<tr class="memdesc:aa6c58dfb2fc9398a026e3268ba2edfad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create <a class="el" href="a03020.html" title="Signature for a discrete conditional density, used to construct conditionals.">Signature</a> objects example: <a class="el" href="a03020.html" title="Signature for a discrete conditional density, used to construct conditionals.">Signature</a> s = D | E;. <br /></td></tr>
<tr class="separator:aa6c58dfb2fc9398a026e3268ba2edfad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98cf2a4777006c28d6983db5d8ec574"><td class="memItemLeft" align="right" valign="top"><a id="ab98cf2a4777006c28d6983db5d8ec574" name="ab98cf2a4777006c28d6983db5d8ec574"></a>
<a class="el" href="a03020.html">Signature</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator%</b> (const <a class="el" href="a01596.html#acd19e5d1e5d06c37246d4c15af38ee67">DiscreteKey</a> &amp;key, const std::string &amp;parent)</td></tr>
<tr class="memdesc:ab98cf2a4777006c28d6983db5d8ec574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create <a class="el" href="a03020.html" title="Signature for a discrete conditional density, used to construct conditionals.">Signature</a> objects example: <a class="el" href="a03020.html" title="Signature for a discrete conditional density, used to construct conditionals.">Signature</a> s(D % "99/1"); Uses string parser, which requires BOOST 1.42 or higher. <br /></td></tr>
<tr class="separator:ab98cf2a4777006c28d6983db5d8ec574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4856250df52ce4b9b4b16c7a833408c"><td class="memItemLeft" align="right" valign="top"><a id="ae4856250df52ce4b9b4b16c7a833408c" name="ae4856250df52ce4b9b4b16c7a833408c"></a>
<a class="el" href="a03020.html">Signature</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator%</b> (const <a class="el" href="a01596.html#acd19e5d1e5d06c37246d4c15af38ee67">DiscreteKey</a> &amp;key, const Signature::Table &amp;parent)</td></tr>
<tr class="memdesc:ae4856250df52ce4b9b4b16c7a833408c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create <a class="el" href="a03020.html" title="Signature for a discrete conditional density, used to construct conditionals.">Signature</a> objects, using table construction directly example: <a class="el" href="a03020.html" title="Signature for a discrete conditional density, used to construct conditionals.">Signature</a> s(D % table);. <br /></td></tr>
<tr class="separator:ae4856250df52ce4b9b4b16c7a833408c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f53aba13fa1d88189b6b31df2a5805f"><td class="memItemLeft" align="right" valign="top"><a id="a8f53aba13fa1d88189b6b31df2a5805f" name="a8f53aba13fa1d88189b6b31df2a5805f"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="a03048.html">Cal3</a> &amp;cal)</td></tr>
<tr class="separator:a8f53aba13fa1d88189b6b31df2a5805f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac814fcc4484bce32e4616d69afb225"><td class="memTemplParams" colspan="2">template&lt;typename Cal , size_t Dim&gt; </td></tr>
<tr class="memitem:a9ac814fcc4484bce32e4616d69afb225"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a9ac814fcc4484bce32e4616d69afb225">calibrateJacobians</a> (const Cal &amp;calibration, const <a class="el" href="a01596.html#a6ede8384dee0353a0ce5fb54ea50c21d">Point2</a> &amp;pn, <a class="el" href="a02616.html">OptionalJacobian</a>&lt; 2, Dim &gt; Dcal=boost::none, <a class="el" href="a02616.html">OptionalJacobian</a>&lt; 2, 2 &gt; Dp=boost::none)</td></tr>
<tr class="memdesc:a9ac814fcc4484bce32e4616d69afb225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which makes use of the Implicit Function Theorem to compute the Jacobians of <code>calibrate</code> using <code>uncalibrate</code>.  <a href="a01596.html#a9ac814fcc4484bce32e4616d69afb225">More...</a><br /></td></tr>
<tr class="separator:a9ac814fcc4484bce32e4616d69afb225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d71ac66372025933d65ce5efee8cdf"><td class="memItemLeft" align="right" valign="top"><a id="aa1d71ac66372025933d65ce5efee8cdf" name="aa1d71ac66372025933d65ce5efee8cdf"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="a03052.html">Cal3_S2</a> &amp;cal)</td></tr>
<tr class="separator:aa1d71ac66372025933d65ce5efee8cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f405cafedd26463262d9f6e23443e14"><td class="memItemLeft" align="right" valign="top"><a id="a9f405cafedd26463262d9f6e23443e14" name="a9f405cafedd26463262d9f6e23443e14"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="a03064.html">Cal3_S2Stereo</a> &amp;cal)</td></tr>
<tr class="separator:a9f405cafedd26463262d9f6e23443e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da01ca3c91c699ba3b315a6d0ae9bc2"><td class="memItemLeft" align="right" valign="top"><a id="a4da01ca3c91c699ba3b315a6d0ae9bc2" name="a4da01ca3c91c699ba3b315a6d0ae9bc2"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="a03076.html">Cal3Bundler</a> &amp;cal)</td></tr>
<tr class="separator:a4da01ca3c91c699ba3b315a6d0ae9bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f6dbf948468025a348758d28593097"><td class="memItemLeft" align="right" valign="top"><a id="a01f6dbf948468025a348758d28593097" name="a01f6dbf948468025a348758d28593097"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="a03088.html">Cal3DS2</a> &amp;cal)</td></tr>
<tr class="separator:a01f6dbf948468025a348758d28593097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7804979ad8bb1a32c54eff40daa76a4d"><td class="memItemLeft" align="right" valign="top"><a id="a7804979ad8bb1a32c54eff40daa76a4d" name="a7804979ad8bb1a32c54eff40daa76a4d"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="a03100.html">Cal3DS2_Base</a> &amp;cal)</td></tr>
<tr class="separator:a7804979ad8bb1a32c54eff40daa76a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeabfca29b5d82252a4c226e4e5e25b8"><td class="memItemLeft" align="right" valign="top"><a id="afeabfca29b5d82252a4c226e4e5e25b8" name="afeabfca29b5d82252a4c226e4e5e25b8"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="a03104.html">Cal3Fisheye</a> &amp;cal)</td></tr>
<tr class="separator:afeabfca29b5d82252a4c226e4e5e25b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802dde254e274a34f262accefe627da5"><td class="memItemLeft" align="right" valign="top"><a id="a802dde254e274a34f262accefe627da5" name="a802dde254e274a34f262accefe627da5"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="a03116.html">Cal3Unified</a> &amp;cal)</td></tr>
<tr class="separator:a802dde254e274a34f262accefe627da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc028275498bcaa0df4993408073de16"><td class="memItemLeft" align="right" valign="top"><a id="abc028275498bcaa0df4993408073de16" name="abc028275498bcaa0df4993408073de16"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const <a class="el" href="a03176.html">EssentialMatrix</a> &amp;E)</td></tr>
<tr class="separator:abc028275498bcaa0df4993408073de16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd2f9315e244d46695d8811d2bccc12"><td class="memItemLeft" align="right" valign="top"><a id="a0fd2f9315e244d46695d8811d2bccc12" name="a0fd2f9315e244d46695d8811d2bccc12"></a>
istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (istream &amp;is, <a class="el" href="a03176.html">EssentialMatrix</a> &amp;E)</td></tr>
<tr class="separator:a0fd2f9315e244d46695d8811d2bccc12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb48c80bef807e34d7189efdc8875cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a03188.html">Line3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a3eb48c80bef807e34d7189efdc8875cd">transformTo</a> (const <a class="el" href="a03288.html">Pose3</a> &amp;wTc, const <a class="el" href="a03188.html">Line3</a> &amp;wL, <a class="el" href="a02616.html">OptionalJacobian</a>&lt; 4, 6 &gt; Dpose=boost::none, <a class="el" href="a02616.html">OptionalJacobian</a>&lt; 4, 4 &gt; Dline=boost::none)</td></tr>
<tr class="memdesc:a3eb48c80bef807e34d7189efdc8875cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a line from world to camera frame.  <a href="a01596.html#a3eb48c80bef807e34d7189efdc8875cd">More...</a><br /></td></tr>
<tr class="separator:a3eb48c80bef807e34d7189efdc8875cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee4e6aa4aba9b6a6b421ddd75b52dfc"><td class="memItemLeft" align="right" valign="top"><a id="afee4e6aa4aba9b6a6b421ddd75b52dfc" name="afee4e6aa4aba9b6a6b421ddd75b52dfc"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>norm2</b> (const <a class="el" href="a01596.html#a6ede8384dee0353a0ce5fb54ea50c21d">Point2</a> &amp;p, <a class="el" href="a02616.html">OptionalJacobian</a>&lt; 1, 2 &gt; H=boost::none)</td></tr>
<tr class="memdesc:afee4e6aa4aba9b6a6b421ddd75b52dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distance of the point from the origin, with Jacobian. <br /></td></tr>
<tr class="separator:afee4e6aa4aba9b6a6b421ddd75b52dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1282dfb080cb393ae60188b4582cb2"><td class="memItemLeft" align="right" valign="top"><a id="afd1282dfb080cb393ae60188b4582cb2" name="afd1282dfb080cb393ae60188b4582cb2"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>distance2</b> (const <a class="el" href="a01596.html#a6ede8384dee0353a0ce5fb54ea50c21d">Point2</a> &amp;p1, const <a class="el" href="a01596.html#a6ede8384dee0353a0ce5fb54ea50c21d">Point2</a> &amp;q, <a class="el" href="a02616.html">OptionalJacobian</a>&lt; 1, 2 &gt; H1=boost::none, <a class="el" href="a02616.html">OptionalJacobian</a>&lt; 1, 2 &gt; H2=boost::none)</td></tr>
<tr class="memdesc:afd1282dfb080cb393ae60188b4582cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">distance between two points <br /></td></tr>
<tr class="separator:afd1282dfb080cb393ae60188b4582cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5973516e4af8db350dbaadb98de53a2a"><td class="memItemLeft" align="right" valign="top"><a id="a5973516e4af8db350dbaadb98de53a2a" name="a5973516e4af8db350dbaadb98de53a2a"></a>
boost::optional&lt; <a class="el" href="a01596.html#a6ede8384dee0353a0ce5fb54ea50c21d">Point2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>circleCircleIntersection</b> (double R_d, double r_d, double tol)</td></tr>
<tr class="separator:a5973516e4af8db350dbaadb98de53a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04244016af43048cedf8df2006ccda45"><td class="memItemLeft" align="right" valign="top"><a id="a04244016af43048cedf8df2006ccda45" name="a04244016af43048cedf8df2006ccda45"></a>
list&lt; <a class="el" href="a01596.html#a6ede8384dee0353a0ce5fb54ea50c21d">Point2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>circleCircleIntersection</b> (<a class="el" href="a01596.html#a6ede8384dee0353a0ce5fb54ea50c21d">Point2</a> c1, <a class="el" href="a01596.html#a6ede8384dee0353a0ce5fb54ea50c21d">Point2</a> c2, boost::optional&lt; <a class="el" href="a01596.html#a6ede8384dee0353a0ce5fb54ea50c21d">Point2</a> &gt; fh)</td></tr>
<tr class="separator:a04244016af43048cedf8df2006ccda45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d4e38a582b6f32fc4f301df10721d5"><td class="memItemLeft" align="right" valign="top">list&lt; <a class="el" href="a01596.html#a6ede8384dee0353a0ce5fb54ea50c21d">Point2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a93d4e38a582b6f32fc4f301df10721d5">circleCircleIntersection</a> (<a class="el" href="a01596.html#a6ede8384dee0353a0ce5fb54ea50c21d">Point2</a> c1, double r1, <a class="el" href="a01596.html#a6ede8384dee0353a0ce5fb54ea50c21d">Point2</a> c2, double r2, double tol=1e-9)</td></tr>
<tr class="memdesc:a93d4e38a582b6f32fc4f301df10721d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersect 2 circles.  <a href="a01596.html#a93d4e38a582b6f32fc4f301df10721d5">More...</a><br /></td></tr>
<tr class="separator:a93d4e38a582b6f32fc4f301df10721d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9655d963c3776bbf707f74c59989dc"><td class="memItemLeft" align="right" valign="top"><a id="aec9655d963c3776bbf707f74c59989dc" name="aec9655d963c3776bbf707f74c59989dc"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const <a class="el" href="a01596.html#aea758f150791443afe1191868963b4e1">gtsam::Point2Pair</a> &amp;p)</td></tr>
<tr class="separator:aec9655d963c3776bbf707f74c59989dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d86e99c211c6daeac2b7b4dd9d928e"><td class="memItemLeft" align="right" valign="top"><a id="a63d86e99c211c6daeac2b7b4dd9d928e" name="a63d86e99c211c6daeac2b7b4dd9d928e"></a>
<a class="el" href="a01596.html#a6ede8384dee0353a0ce5fb54ea50c21d">Point2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (double s, const <a class="el" href="a01596.html#a6ede8384dee0353a0ce5fb54ea50c21d">Point2</a> &amp;p)</td></tr>
<tr class="memdesc:a63d86e99c211c6daeac2b7b4dd9d928e"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiply with scalar <br /></td></tr>
<tr class="separator:a63d86e99c211c6daeac2b7b4dd9d928e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42f7ec660b7353de39f9c86a26711cc"><td class="memItemLeft" align="right" valign="top"><a id="aa42f7ec660b7353de39f9c86a26711cc" name="aa42f7ec660b7353de39f9c86a26711cc"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>distance3</b> (const <a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a> &amp;p1, const <a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a> &amp;q, <a class="el" href="a02616.html">OptionalJacobian</a>&lt; 1, 3 &gt; H1=boost::none, <a class="el" href="a02616.html">OptionalJacobian</a>&lt; 1, 3 &gt; H2=boost::none)</td></tr>
<tr class="memdesc:aa42f7ec660b7353de39f9c86a26711cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">distance between two points <br /></td></tr>
<tr class="separator:aa42f7ec660b7353de39f9c86a26711cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37b6f807985ffd25217e33f6136fe58"><td class="memItemLeft" align="right" valign="top"><a id="ac37b6f807985ffd25217e33f6136fe58" name="ac37b6f807985ffd25217e33f6136fe58"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>norm3</b> (const <a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a> &amp;p, <a class="el" href="a02616.html">OptionalJacobian</a>&lt; 1, 3 &gt; H=boost::none)</td></tr>
<tr class="memdesc:ac37b6f807985ffd25217e33f6136fe58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distance of the point from the origin, with Jacobian. <br /></td></tr>
<tr class="separator:ac37b6f807985ffd25217e33f6136fe58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb52bb00c68909fc1147e5d112e8c2ae"><td class="memItemLeft" align="right" valign="top"><a id="abb52bb00c68909fc1147e5d112e8c2ae" name="abb52bb00c68909fc1147e5d112e8c2ae"></a>
<a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a>&#160;</td><td class="memItemRight" valign="bottom"><b>normalize</b> (const <a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a> &amp;p, <a class="el" href="a02616.html">OptionalJacobian</a>&lt; 3, 3 &gt; H=boost::none)</td></tr>
<tr class="memdesc:abb52bb00c68909fc1147e5d112e8c2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">normalize, with optional Jacobian <br /></td></tr>
<tr class="separator:abb52bb00c68909fc1147e5d112e8c2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86bf6ed2ffb0ecc42a7deb8922f4ca4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a86bf6ed2ffb0ecc42a7deb8922f4ca4f">cross</a> (const <a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a> &amp;p, const <a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a> &amp;q, <a class="el" href="a02616.html">OptionalJacobian</a>&lt; 3, 3 &gt; H_p=boost::none, <a class="el" href="a02616.html">OptionalJacobian</a>&lt; 3, 3 &gt; H_q=boost::none)</td></tr>
<tr class="memdesc:a86bf6ed2ffb0ecc42a7deb8922f4ca4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">cross product  <a href="a01596.html#a86bf6ed2ffb0ecc42a7deb8922f4ca4f">More...</a><br /></td></tr>
<tr class="separator:a86bf6ed2ffb0ecc42a7deb8922f4ca4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc820e4e47218768f104b43a184a1bd"><td class="memItemLeft" align="right" valign="top"><a id="a7dc820e4e47218768f104b43a184a1bd" name="a7dc820e4e47218768f104b43a184a1bd"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>dot</b> (const <a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a> &amp;p, const <a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a> &amp;q, <a class="el" href="a02616.html">OptionalJacobian</a>&lt; 1, 3 &gt; H_p=boost::none, <a class="el" href="a02616.html">OptionalJacobian</a>&lt; 1, 3 &gt; H_q=boost::none)</td></tr>
<tr class="memdesc:a7dc820e4e47218768f104b43a184a1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">dot product <br /></td></tr>
<tr class="separator:a7dc820e4e47218768f104b43a184a1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f778b84bc6106471006421d289b832"><td class="memItemLeft" align="right" valign="top"><a id="a57f778b84bc6106471006421d289b832" name="a57f778b84bc6106471006421d289b832"></a>
Point3Pair&#160;</td><td class="memItemRight" valign="bottom"><b>means</b> (const std::vector&lt; Point3Pair &gt; &amp;abPointPairs)</td></tr>
<tr class="memdesc:a57f778b84bc6106471006421d289b832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the two means of a set of Point3 pairs. <br /></td></tr>
<tr class="separator:a57f778b84bc6106471006421d289b832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0cf4b44adc94a39066254a3ea63fbef"><td class="memItemLeft" align="right" valign="top"><a id="aa0cf4b44adc94a39066254a3ea63fbef" name="aa0cf4b44adc94a39066254a3ea63fbef"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const gtsam::Point3Pair &amp;p)</td></tr>
<tr class="separator:aa0cf4b44adc94a39066254a3ea63fbef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300205092710091b8745c0a145da20a1"><td class="memTemplParams" colspan="2"><a id="a300205092710091b8745c0a145da20a1" name="a300205092710091b8745c0a145da20a1"></a>
template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:a300205092710091b8745c0a145da20a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mean</b> (const CONTAINER &amp;points)</td></tr>
<tr class="memdesc:a300205092710091b8745c0a145da20a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">mean <br /></td></tr>
<tr class="separator:a300205092710091b8745c0a145da20a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee19d5c02398557b04d94f562af9084"><td class="memItemLeft" align="right" valign="top"><a id="aeee19d5c02398557b04d94f562af9084" name="aeee19d5c02398557b04d94f562af9084"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="a03264.html">Pose2</a> &amp;pose)</td></tr>
<tr class="separator:aeee19d5c02398557b04d94f562af9084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5f3d592b1eb52ab4bf4d34003178f0"><td class="memItemLeft" align="right" valign="top"><a id="a2d5f3d592b1eb52ab4bf4d34003178f0" name="a2d5f3d592b1eb52ab4bf4d34003178f0"></a>
boost::optional&lt; <a class="el" href="a03264.html">Pose2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>align</b> (const vector&lt; <a class="el" href="a01596.html#aea758f150791443afe1191868963b4e1">Point2Pair</a> &gt; &amp;pairs)</td></tr>
<tr class="separator:a2d5f3d592b1eb52ab4bf4d34003178f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b78f4db0e05f3ca838ee4da6187710e"><td class="memItemLeft" align="right" valign="top"><a id="a4b78f4db0e05f3ca838ee4da6187710e" name="a4b78f4db0e05f3ca838ee4da6187710e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a4b78f4db0e05f3ca838ee4da6187710e"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>wedge&lt; Pose2 &gt;</b> (const Vector &amp;xi)</td></tr>
<tr class="memdesc:a4b78f4db0e05f3ca838ee4da6187710e"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialization for pose2 wedge function (generic template in <a class="el" href="a00131.html" title="Base class and basic functions for Lie types.">Lie.h</a>) <br /></td></tr>
<tr class="separator:a4b78f4db0e05f3ca838ee4da6187710e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7810f064014e39d2af18ce2834178151"><td class="memItemLeft" align="right" valign="top"><a id="a7810f064014e39d2af18ce2834178151" name="a7810f064014e39d2af18ce2834178151"></a>
boost::optional&lt; <a class="el" href="a03288.html">Pose3</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>align</b> (const Point3Pairs &amp;baPointPairs)</td></tr>
<tr class="separator:a7810f064014e39d2af18ce2834178151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95effc0d8f9cddca334be651f3f3757"><td class="memItemLeft" align="right" valign="top"><a id="ae95effc0d8f9cddca334be651f3f3757" name="ae95effc0d8f9cddca334be651f3f3757"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="a03288.html">Pose3</a> &amp;pose)</td></tr>
<tr class="separator:ae95effc0d8f9cddca334be651f3f3757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb606eb24889c0f418acf1515a2c723"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aefb606eb24889c0f418acf1515a2c723"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#aefb606eb24889c0f418acf1515a2c723">wedge&lt; Pose3 &gt;</a> (const Vector &amp;xi)</td></tr>
<tr class="memdesc:aefb606eb24889c0f418acf1515a2c723"><td class="mdescLeft">&#160;</td><td class="mdescRight">wedge for <a class="el" href="a03288.html">Pose3</a>:  <a href="a01596.html#aefb606eb24889c0f418acf1515a2c723">More...</a><br /></td></tr>
<tr class="separator:aefb606eb24889c0f418acf1515a2c723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5172b5b6d51bd5348c7e551e1376f60a"><td class="memItemLeft" align="right" valign="top">pair&lt; Matrix3, Vector3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a5172b5b6d51bd5348c7e551e1376f60a">RQ</a> (const Matrix3 &amp;A, <a class="el" href="a02616.html">OptionalJacobian</a>&lt; 3, 9 &gt; H=boost::none)</td></tr>
<tr class="memdesc:a5172b5b6d51bd5348c7e551e1376f60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">[RQ] receives a 3 by 3 matrix and returns an upper triangular matrix R and 3 rotation angles corresponding to the rotation matrix Q=Qz'*Qy'*Qx' such that A = R*Q = R*Qz'*Qy'*Qx'.  <a href="a01596.html#a5172b5b6d51bd5348c7e551e1376f60a">More...</a><br /></td></tr>
<tr class="separator:a5172b5b6d51bd5348c7e551e1376f60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac656af94e4fdb990e206390d8bdfe49b"><td class="memItemLeft" align="right" valign="top"><a id="ac656af94e4fdb990e206390d8bdfe49b" name="ac656af94e4fdb990e206390d8bdfe49b"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const <a class="el" href="a03336.html">Rot3</a> &amp;R)</td></tr>
<tr class="separator:ac656af94e4fdb990e206390d8bdfe49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa234f504b04d6aae1b70643d11c7ac3c"><td class="memItemLeft" align="right" valign="top"><a id="aa234f504b04d6aae1b70643d11c7ac3c" name="aa234f504b04d6aae1b70643d11c7ac3c"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="a03356.html">Similarity3</a> &amp;p)</td></tr>
<tr class="separator:aa234f504b04d6aae1b70643d11c7ac3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5678009a227aa206df50905d47686f64"><td class="memItemLeft" align="right" valign="top"><a id="a5678009a227aa206df50905d47686f64" name="a5678009a227aa206df50905d47686f64"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a5678009a227aa206df50905d47686f64"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>wedge&lt; Similarity3 &gt;</b> (const Vector &amp;xi)</td></tr>
<tr class="separator:a5678009a227aa206df50905d47686f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0b14126ed42ee95ca5f5f092c5bc84"><td class="memTemplParams" colspan="2"><a id="a2e0b14126ed42ee95ca5f5f092c5bc84" name="a2e0b14126ed42ee95ca5f5f092c5bc84"></a>
template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a2e0b14126ed42ee95ca5f5f092c5bc84"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serialize</b> (Archive &amp;ar, <a class="el" href="a03396.html">SO3</a> &amp;R, const unsigned int)</td></tr>
<tr class="memdesc:a2e0b14126ed42ee95ca5f5f092c5bc84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization function. <br /></td></tr>
<tr class="separator:a2e0b14126ed42ee95ca5f5f092c5bc84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d21728e3da4cf1a96e1b6f87a97da47"><td class="memItemLeft" align="right" valign="top">GTSAM_EXPORT Matrix3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a8d21728e3da4cf1a96e1b6f87a97da47">topLeft</a> (const <a class="el" href="a03396.html">SO4</a> &amp;Q, <a class="el" href="a02616.html">OptionalJacobian</a>&lt; 9, 6 &gt; H=boost::none)</td></tr>
<tr class="memdesc:a8d21728e3da4cf1a96e1b6f87a97da47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project to top-left 3*3 matrix.  <a href="a01596.html#a8d21728e3da4cf1a96e1b6f87a97da47">More...</a><br /></td></tr>
<tr class="separator:a8d21728e3da4cf1a96e1b6f87a97da47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e57e4771f13855a495ec2c6454c9121"><td class="memItemLeft" align="right" valign="top"><a id="a3e57e4771f13855a495ec2c6454c9121" name="a3e57e4771f13855a495ec2c6454c9121"></a>
GTSAM_EXPORT Matrix43&#160;</td><td class="memItemRight" valign="bottom"><b>stiefel</b> (const <a class="el" href="a03396.html">SO4</a> &amp;Q, <a class="el" href="a02616.html">OptionalJacobian</a>&lt; 12, 6 &gt; H=boost::none)</td></tr>
<tr class="memdesc:a3e57e4771f13855a495ec2c6454c9121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project to Stiefel manifold of 4*3 orthonormal 3-frames in R^4, i.e., pi(Q) -&gt; S \in St(3,4). <br /></td></tr>
<tr class="separator:a3e57e4771f13855a495ec2c6454c9121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76855a1214bf05a8704ee3deaece6339"><td class="memTemplParams" colspan="2"><a id="a76855a1214bf05a8704ee3deaece6339" name="a76855a1214bf05a8704ee3deaece6339"></a>
template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a76855a1214bf05a8704ee3deaece6339"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serialize</b> (Archive &amp;ar, <a class="el" href="a03396.html">SO4</a> &amp;Q, const unsigned int)</td></tr>
<tr class="memdesc:a76855a1214bf05a8704ee3deaece6339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization function. <br /></td></tr>
<tr class="separator:a76855a1214bf05a8704ee3deaece6339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1829b506847127f406c0d6182fc0cdd"><td class="memTemplParams" colspan="2"><a id="ac1829b506847127f406c0d6182fc0cdd" name="ac1829b506847127f406c0d6182fc0cdd"></a>
template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ac1829b506847127f406c0d6182fc0cdd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serialize</b> (Archive &amp;ar, <a class="el" href="a03396.html">SOn</a> &amp;Q, const unsigned int file_version)</td></tr>
<tr class="memdesc:ac1829b506847127f406c0d6182fc0cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization function. <br /></td></tr>
<tr class="separator:ac1829b506847127f406c0d6182fc0cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a54f1f148aae3d1d818305d844116c9"><td class="memItemLeft" align="right" valign="top"><a id="a3a54f1f148aae3d1d818305d844116c9" name="a3a54f1f148aae3d1d818305d844116c9"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const <a class="el" href="a03428.html">StereoPoint2</a> &amp;p)</td></tr>
<tr class="separator:a3a54f1f148aae3d1d818305d844116c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af378e231b519e8bb1f09f4aa13a38dca"><td class="memItemLeft" align="right" valign="top">Vector4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#af378e231b519e8bb1f09f4aa13a38dca">triangulateHomogeneousDLT</a> (const std::vector&lt; Matrix34, Eigen::aligned_allocator&lt; Matrix34 &gt; &gt; &amp;projection_matrices, const Point2Vector &amp;measurements, double rank_tol=1e-9)</td></tr>
<tr class="memdesc:af378e231b519e8bb1f09f4aa13a38dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">DLT triangulation: See Hartley and Zisserman, 2nd Ed., page 312.  <a href="a01596.html#af378e231b519e8bb1f09f4aa13a38dca">More...</a><br /></td></tr>
<tr class="separator:af378e231b519e8bb1f09f4aa13a38dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2918ac0049316bf09f96879efca3b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#aed2918ac0049316bf09f96879efca3b6">triangulateDLT</a> (const std::vector&lt; Matrix34, Eigen::aligned_allocator&lt; Matrix34 &gt; &gt; &amp;projection_matrices, const Point2Vector &amp;measurements, double rank_tol=1e-9)</td></tr>
<tr class="memdesc:aed2918ac0049316bf09f96879efca3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">DLT triangulation: See Hartley and Zisserman, 2nd Ed., page 312.  <a href="a01596.html#aed2918ac0049316bf09f96879efca3b6">More...</a><br /></td></tr>
<tr class="separator:aed2918ac0049316bf09f96879efca3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0057879b0c5f323185452b0d1a4232"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a4b0057879b0c5f323185452b0d1a4232">optimize</a> (const <a class="el" href="a04480.html">NonlinearFactorGraph</a> &amp;graph, const <a class="el" href="a04560.html">Values</a> &amp;values, <a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a> landmarkKey)</td></tr>
<tr class="memdesc:a4b0057879b0c5f323185452b0d1a4232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize for triangulation.  <a href="a01596.html#a4b0057879b0c5f323185452b0d1a4232">More...</a><br /></td></tr>
<tr class="separator:a4b0057879b0c5f323185452b0d1a4232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb854935c3a0b73ba63adfb86a5c141"><td class="memTemplParams" colspan="2">template&lt;class CALIBRATION &gt; </td></tr>
<tr class="memitem:a3fb854935c3a0b73ba63adfb86a5c141"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="a04480.html">NonlinearFactorGraph</a>, <a class="el" href="a04560.html">Values</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a3fb854935c3a0b73ba63adfb86a5c141">triangulationGraph</a> (const std::vector&lt; <a class="el" href="a03288.html">Pose3</a> &gt; &amp;poses, boost::shared_ptr&lt; CALIBRATION &gt; sharedCal, const Point2Vector &amp;measurements, <a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a> landmarkKey, const <a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a> &amp;initialEstimate)</td></tr>
<tr class="memdesc:a3fb854935c3a0b73ba63adfb86a5c141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a factor graph with projection factors from poses and one calibration.  <a href="a01596.html#a3fb854935c3a0b73ba63adfb86a5c141">More...</a><br /></td></tr>
<tr class="separator:a3fb854935c3a0b73ba63adfb86a5c141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afefb1a863211aa15c603fbac3541fc4b"><td class="memTemplParams" colspan="2">template&lt;class CAMERA &gt; </td></tr>
<tr class="memitem:afefb1a863211aa15c603fbac3541fc4b"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="a04480.html">NonlinearFactorGraph</a>, <a class="el" href="a04560.html">Values</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#afefb1a863211aa15c603fbac3541fc4b">triangulationGraph</a> (const <a class="el" href="a03152.html">CameraSet</a>&lt; CAMERA &gt; &amp;cameras, const typename CAMERA::MeasurementVector &amp;measurements, <a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a> landmarkKey, const <a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a> &amp;initialEstimate)</td></tr>
<tr class="memdesc:afefb1a863211aa15c603fbac3541fc4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a factor graph with projection factors from pinhole cameras (each camera has a pose and calibration)  <a href="a01596.html#afefb1a863211aa15c603fbac3541fc4b">More...</a><br /></td></tr>
<tr class="separator:afefb1a863211aa15c603fbac3541fc4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd76f4999d5ac79b85c4271943e9251f"><td class="memTemplParams" colspan="2">template&lt;class CALIBRATION &gt; </td></tr>
<tr class="memitem:afd76f4999d5ac79b85c4271943e9251f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#afd76f4999d5ac79b85c4271943e9251f">triangulateNonlinear</a> (const std::vector&lt; <a class="el" href="a03288.html">Pose3</a> &gt; &amp;poses, boost::shared_ptr&lt; CALIBRATION &gt; sharedCal, const Point2Vector &amp;measurements, const <a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a> &amp;initialEstimate)</td></tr>
<tr class="memdesc:afd76f4999d5ac79b85c4271943e9251f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an initial estimate , refine a point using measurements in several cameras.  <a href="a01596.html#afd76f4999d5ac79b85c4271943e9251f">More...</a><br /></td></tr>
<tr class="separator:afd76f4999d5ac79b85c4271943e9251f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa35400ef37861ce74067b6a38884ba"><td class="memTemplParams" colspan="2">template&lt;class CAMERA &gt; </td></tr>
<tr class="memitem:a2fa35400ef37861ce74067b6a38884ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a2fa35400ef37861ce74067b6a38884ba">triangulateNonlinear</a> (const <a class="el" href="a03152.html">CameraSet</a>&lt; CAMERA &gt; &amp;cameras, const typename CAMERA::MeasurementVector &amp;measurements, const <a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a> &amp;initialEstimate)</td></tr>
<tr class="memdesc:a2fa35400ef37861ce74067b6a38884ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an initial estimate , refine a point using measurements in several cameras.  <a href="a01596.html#a2fa35400ef37861ce74067b6a38884ba">More...</a><br /></td></tr>
<tr class="separator:a2fa35400ef37861ce74067b6a38884ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b725c367246edb1beea32060fd50f7"><td class="memTemplParams" colspan="2">template&lt;class CALIBRATION &gt; </td></tr>
<tr class="memitem:ae7b725c367246edb1beea32060fd50f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#ae7b725c367246edb1beea32060fd50f7">triangulatePoint3</a> (const std::vector&lt; <a class="el" href="a03288.html">Pose3</a> &gt; &amp;poses, boost::shared_ptr&lt; CALIBRATION &gt; sharedCal, const Point2Vector &amp;measurements, double rank_tol=1e-9, bool <a class="el" href="a01596.html#a4b0057879b0c5f323185452b0d1a4232">optimize</a>=false)</td></tr>
<tr class="memdesc:ae7b725c367246edb1beea32060fd50f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to triangulate 3D landmark point from an arbitrary number of poses (at least 2) using the DLT.  <a href="a01596.html#ae7b725c367246edb1beea32060fd50f7">More...</a><br /></td></tr>
<tr class="separator:ae7b725c367246edb1beea32060fd50f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0493526601a58e173f8c0646ed302739"><td class="memTemplParams" colspan="2">template&lt;class CAMERA &gt; </td></tr>
<tr class="memitem:a0493526601a58e173f8c0646ed302739"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a0493526601a58e173f8c0646ed302739">triangulatePoint3</a> (const <a class="el" href="a03152.html">CameraSet</a>&lt; CAMERA &gt; &amp;cameras, const typename CAMERA::MeasurementVector &amp;measurements, double rank_tol=1e-9, bool <a class="el" href="a01596.html#a4b0057879b0c5f323185452b0d1a4232">optimize</a>=false)</td></tr>
<tr class="memdesc:a0493526601a58e173f8c0646ed302739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to triangulate 3D landmark point from an arbitrary number of poses (at least 2) using the DLT.  <a href="a01596.html#a0493526601a58e173f8c0646ed302739">More...</a><br /></td></tr>
<tr class="separator:a0493526601a58e173f8c0646ed302739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a9a20bbbd347f4cf2a7153a5d43ec4"><td class="memTemplParams" colspan="2"><a id="a22a9a20bbbd347f4cf2a7153a5d43ec4" name="a22a9a20bbbd347f4cf2a7153a5d43ec4"></a>
template&lt;class CALIBRATION &gt; </td></tr>
<tr class="memitem:a22a9a20bbbd347f4cf2a7153a5d43ec4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>triangulatePoint3</b> (const <a class="el" href="a03152.html">CameraSet</a>&lt; <a class="el" href="a03212.html">PinholeCamera</a>&lt; CALIBRATION &gt; &gt; &amp;cameras, const Point2Vector &amp;measurements, double rank_tol=1e-9, bool <a class="el" href="a01596.html#a4b0057879b0c5f323185452b0d1a4232">optimize</a>=false)</td></tr>
<tr class="memdesc:a22a9a20bbbd347f4cf2a7153a5d43ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pinhole-specific version. <br /></td></tr>
<tr class="separator:a22a9a20bbbd347f4cf2a7153a5d43ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d52d7d8a5e5c8d7318ce95ee57e9cfa"><td class="memTemplParams" colspan="2"><a id="a8d52d7d8a5e5c8d7318ce95ee57e9cfa" name="a8d52d7d8a5e5c8d7318ce95ee57e9cfa"></a>
template&lt;class CAMERA &gt; </td></tr>
<tr class="memitem:a8d52d7d8a5e5c8d7318ce95ee57e9cfa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a03456.html">TriangulationResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>triangulateSafe</b> (const <a class="el" href="a03152.html">CameraSet</a>&lt; CAMERA &gt; &amp;cameras, const typename CAMERA::MeasurementVector &amp;measured, const <a class="el" href="a03452.html">TriangulationParameters</a> &amp;params)</td></tr>
<tr class="memdesc:a8d52d7d8a5e5c8d7318ce95ee57e9cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">triangulateSafe: extensive checking of the outcome <br /></td></tr>
<tr class="separator:a8d52d7d8a5e5c8d7318ce95ee57e9cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7b3dce934eb43af5158b71c6f98c62"><td class="memItemLeft" align="right" valign="top"><a id="a3e7b3dce934eb43af5158b71c6f98c62" name="a3e7b3dce934eb43af5158b71c6f98c62"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="a03460.html">Unit3</a> &amp;pair)</td></tr>
<tr class="separator:a3e7b3dce934eb43af5158b71c6f98c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81e78a9bbb281668fedfd68009ec550"><td class="memTemplParams" colspan="2"><a id="ad81e78a9bbb281668fedfd68009ec550" name="ad81e78a9bbb281668fedfd68009ec550"></a>
template&lt;class CLIQUE &gt; </td></tr>
<tr class="memitem:ad81e78a9bbb281668fedfd68009ec550"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>check_sharedCliques</b> (const std::pair&lt; <a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a>, typename <a class="el" href="a03496.html">BayesTree</a>&lt; CLIQUE &gt;::sharedClique &gt; &amp;v1, const std::pair&lt; <a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a>, typename <a class="el" href="a03496.html">BayesTree</a>&lt; CLIQUE &gt;::sharedClique &gt; &amp;v2)</td></tr>
<tr class="separator:ad81e78a9bbb281668fedfd68009ec550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a265afdea057ea54be10262396be12"><td class="memTemplParams" colspan="2"><a id="a18a265afdea057ea54be10262396be12" name="a18a265afdea057ea54be10262396be12"></a>
template&lt;class KEY &gt; </td></tr>
<tr class="memitem:a18a265afdea057ea54be10262396be12"><td class="memTemplItemLeft" align="right" valign="top">std::list&lt; KEY &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>predecessorMap2Keys</b> (const <a class="el" href="a03576.html">PredecessorMap</a>&lt; KEY &gt; &amp;p_map)</td></tr>
<tr class="memdesc:a18a265afdea057ea54be10262396be12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a list of keys from a spanning tree represented by its predecessor map. <br /></td></tr>
<tr class="separator:a18a265afdea057ea54be10262396be12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0319a6ebcc83d4a5cf9ff51729bb80"><td class="memTemplParams" colspan="2"><a id="a6c0319a6ebcc83d4a5cf9ff51729bb80" name="a6c0319a6ebcc83d4a5cf9ff51729bb80"></a>
template&lt;class G , class F , class KEY &gt; </td></tr>
<tr class="memitem:a6c0319a6ebcc83d4a5cf9ff51729bb80"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a03568.html">SDGraph</a>&lt; KEY &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>toBoostGraph</b> (const G &amp;graph)</td></tr>
<tr class="memdesc:a6c0319a6ebcc83d4a5cf9ff51729bb80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the factor graph to an <a class="el" href="a03568.html" title="SDGraph is undirected graph with variable keys and double edge weights.">SDGraph</a> G = Graph type F = <a class="el" href="a03544.html" title="This is the base class for all factor types.">Factor</a> type Key = Key type. <br /></td></tr>
<tr class="separator:a6c0319a6ebcc83d4a5cf9ff51729bb80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67d0d86c4e55b175859967a70b36983"><td class="memTemplParams" colspan="2">template&lt;class G , class V , class KEY &gt; </td></tr>
<tr class="memitem:ae67d0d86c4e55b175859967a70b36983"><td class="memTemplItemLeft" align="right" valign="top">boost::tuple&lt; G, V, std::map&lt; KEY, V &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#ae67d0d86c4e55b175859967a70b36983">predecessorMap2Graph</a> (const <a class="el" href="a03576.html">PredecessorMap</a>&lt; KEY &gt; &amp;p_map)</td></tr>
<tr class="memdesc:ae67d0d86c4e55b175859967a70b36983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build takes a predecessor map, and builds a directed graph corresponding to the tree.  <a href="a01596.html#ae67d0d86c4e55b175859967a70b36983">More...</a><br /></td></tr>
<tr class="separator:ae67d0d86c4e55b175859967a70b36983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b34d6038ccdfa84d8a5bb0c15328b1"><td class="memTemplParams" colspan="2"><a id="a62b34d6038ccdfa84d8a5bb0c15328b1" name="a62b34d6038ccdfa84d8a5bb0c15328b1"></a>
template&lt;class G , class <a class="el" href="a03544.html">Factor</a> , class POSE , class KEY &gt; </td></tr>
<tr class="memitem:a62b34d6038ccdfa84d8a5bb0c15328b1"><td class="memTemplItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="a04560.html">Values</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>composePoses</b> (const G &amp;graph, const <a class="el" href="a03576.html">PredecessorMap</a>&lt; KEY &gt; &amp;tree, const POSE &amp;rootPose)</td></tr>
<tr class="memdesc:a62b34d6038ccdfa84d8a5bb0c15328b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose the poses by following the chain specified by the spanning tree. <br /></td></tr>
<tr class="separator:a62b34d6038ccdfa84d8a5bb0c15328b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7771a103b41708e88763ff67059ff01d"><td class="memTemplParams" colspan="2"><a id="a7771a103b41708e88763ff67059ff01d" name="a7771a103b41708e88763ff67059ff01d"></a>
template&lt;class G , class KEY , class FACTOR2 &gt; </td></tr>
<tr class="memitem:a7771a103b41708e88763ff67059ff01d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a03576.html">PredecessorMap</a>&lt; KEY &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>findMinimumSpanningTree</b> (const G &amp;g)</td></tr>
<tr class="memdesc:a7771a103b41708e88763ff67059ff01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the minimum spanning tree using boost graph library <br /></td></tr>
<tr class="separator:a7771a103b41708e88763ff67059ff01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3453247aec1d8b4642947ffd4bca426b"><td class="memTemplParams" colspan="2"><a id="a3453247aec1d8b4642947ffd4bca426b" name="a3453247aec1d8b4642947ffd4bca426b"></a>
template&lt;class G , class KEY , class FACTOR2 &gt; </td></tr>
<tr class="memitem:a3453247aec1d8b4642947ffd4bca426b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>split</b> (const G &amp;g, const <a class="el" href="a03576.html">PredecessorMap</a>&lt; KEY &gt; &amp;tree, G &amp;Ab1, G &amp;Ab2)</td></tr>
<tr class="memdesc:a3453247aec1d8b4642947ffd4bca426b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the graph into two parts: one corresponds to the given spanning tree, and the other corresponds to the rest of the factors. <br /></td></tr>
<tr class="separator:a3453247aec1d8b4642947ffd4bca426b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6435f73056db87524ffa53c2f7e8c72a"><td class="memItemLeft" align="right" valign="top"><a id="a6435f73056db87524ffa53c2f7e8c72a" name="a6435f73056db87524ffa53c2f7e8c72a"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>_defaultKeyFormatter</b> (<a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a> key)</td></tr>
<tr class="separator:a6435f73056db87524ffa53c2f7e8c72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9e295c4f7086ce05cbe37aeeca47fe"><td class="memItemLeft" align="right" valign="top"><a id="a4f9e295c4f7086ce05cbe37aeeca47fe" name="a4f9e295c4f7086ce05cbe37aeeca47fe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PrintKey</b> (<a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a> key, const std::string &amp;s=&quot;&quot;, const <a class="el" href="a01596.html#ae4b4e8e7f0d745882c6a02b507d5bffe">KeyFormatter</a> &amp;keyFormatter=DefaultKeyFormatter)</td></tr>
<tr class="memdesc:a4f9e295c4f7086ce05cbe37aeeca47fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to print one key with optional prefix. <br /></td></tr>
<tr class="separator:a4f9e295c4f7086ce05cbe37aeeca47fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378dab7dd4f60f820d0bcb638542812a"><td class="memItemLeft" align="right" valign="top"><a id="a378dab7dd4f60f820d0bcb638542812a" name="a378dab7dd4f60f820d0bcb638542812a"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>_multirobotKeyFormatter</b> (<a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a> key)</td></tr>
<tr class="separator:a378dab7dd4f60f820d0bcb638542812a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d860ab2fcbfdadd31055f2d3062a63"><td class="memTemplParams" colspan="2"><a id="a66d860ab2fcbfdadd31055f2d3062a63" name="a66d860ab2fcbfdadd31055f2d3062a63"></a>
template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:a66d860ab2fcbfdadd31055f2d3062a63"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Print</b> (const CONTAINER &amp;keys, const string &amp;s, const <a class="el" href="a01596.html#ae4b4e8e7f0d745882c6a02b507d5bffe">KeyFormatter</a> &amp;keyFormatter)</td></tr>
<tr class="separator:a66d860ab2fcbfdadd31055f2d3062a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7ddea9b0bc36f296327e0ec08c4ef0"><td class="memItemLeft" align="right" valign="top"><a id="aab7ddea9b0bc36f296327e0ec08c4ef0" name="aab7ddea9b0bc36f296327e0ec08c4ef0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PrintKeyList</b> (const <a class="el" href="a02480.html">KeyList</a> &amp;keys, const std::string &amp;s=&quot;&quot;, const <a class="el" href="a01596.html#ae4b4e8e7f0d745882c6a02b507d5bffe">KeyFormatter</a> &amp;keyFormatter=DefaultKeyFormatter)</td></tr>
<tr class="memdesc:aab7ddea9b0bc36f296327e0ec08c4ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to print sets of keys with optional prefix. <br /></td></tr>
<tr class="separator:aab7ddea9b0bc36f296327e0ec08c4ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c14be406d50f65bd404429a7b1d3af0"><td class="memItemLeft" align="right" valign="top"><a id="a4c14be406d50f65bd404429a7b1d3af0" name="a4c14be406d50f65bd404429a7b1d3af0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PrintKeyVector</b> (const <a class="el" href="a01596.html#a1c320e42b033352fbbd8266e3bd5faad">KeyVector</a> &amp;keys, const std::string &amp;s=&quot;&quot;, const <a class="el" href="a01596.html#ae4b4e8e7f0d745882c6a02b507d5bffe">KeyFormatter</a> &amp;keyFormatter=DefaultKeyFormatter)</td></tr>
<tr class="memdesc:a4c14be406d50f65bd404429a7b1d3af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to print sets of keys with optional prefix. <br /></td></tr>
<tr class="separator:a4c14be406d50f65bd404429a7b1d3af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac25d6c8afb07054416ba6727685bf55"><td class="memItemLeft" align="right" valign="top"><a id="aac25d6c8afb07054416ba6727685bf55" name="aac25d6c8afb07054416ba6727685bf55"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PrintKeySet</b> (const <a class="el" href="a02488.html">KeySet</a> &amp;keys, const std::string &amp;s=&quot;&quot;, const <a class="el" href="a01596.html#ae4b4e8e7f0d745882c6a02b507d5bffe">KeyFormatter</a> &amp;keyFormatter=DefaultKeyFormatter)</td></tr>
<tr class="memdesc:aac25d6c8afb07054416ba6727685bf55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to print sets of keys with optional prefix. <br /></td></tr>
<tr class="separator:aac25d6c8afb07054416ba6727685bf55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7cf1da7f59e07c172e0b29f9c129ae"><td class="memItemLeft" align="right" valign="top"><a id="aad7cf1da7f59e07c172e0b29f9c129ae" name="aad7cf1da7f59e07c172e0b29f9c129ae"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const <a class="el" href="a03612.html">key_formatter</a> &amp;m)</td></tr>
<tr class="separator:aad7cf1da7f59e07c172e0b29f9c129ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d36065eec39f37f4795abddfc39144"><td class="memItemLeft" align="right" valign="top"><a id="aa0d36065eec39f37f4795abddfc39144" name="aa0d36065eec39f37f4795abddfc39144"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const <a class="el" href="a03608.html">StreamedKey</a> &amp;streamedKey)</td></tr>
<tr class="separator:aa0d36065eec39f37f4795abddfc39144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31b08a93721af2bafb3db2ddf278f2b"><td class="memItemLeft" align="right" valign="top"><a id="ae31b08a93721af2bafb3db2ddf278f2b" name="ae31b08a93721af2bafb3db2ddf278f2b"></a>
GTSAM_EXPORT std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="a03620.html">LabeledSymbol</a> &amp;<a class="el" href="a01596.html#a3bfdb8456463015b2dda092a5805a745">symbol</a>)</td></tr>
<tr class="separator:ae31b08a93721af2bafb3db2ddf278f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a7dceb0a85c356062b55f6939b1419"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#ae9a7dceb0a85c356062b55f6939b1419">mrsymbol</a> (unsigned char c, unsigned char label, size_t j)</td></tr>
<tr class="memdesc:ae9a7dceb0a85c356062b55f6939b1419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a symbol key from a character, label and index, i.e.  <a href="a01596.html#ae9a7dceb0a85c356062b55f6939b1419">More...</a><br /></td></tr>
<tr class="separator:ae9a7dceb0a85c356062b55f6939b1419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37995b0d0610e5fb29c6bd0715151d67"><td class="memItemLeft" align="right" valign="top"><a id="a37995b0d0610e5fb29c6bd0715151d67" name="a37995b0d0610e5fb29c6bd0715151d67"></a>
unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>mrsymbolChr</b> (<a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a> key)</td></tr>
<tr class="memdesc:a37995b0d0610e5fb29c6bd0715151d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the character portion of a symbol key. <br /></td></tr>
<tr class="separator:a37995b0d0610e5fb29c6bd0715151d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4c133c4fd0d9d73593f601be2248a6"><td class="memItemLeft" align="right" valign="top"><a id="a4e4c133c4fd0d9d73593f601be2248a6" name="a4e4c133c4fd0d9d73593f601be2248a6"></a>
unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>mrsymbolLabel</b> (<a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a> key)</td></tr>
<tr class="memdesc:a4e4c133c4fd0d9d73593f601be2248a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the label portion of a symbol key. <br /></td></tr>
<tr class="separator:a4e4c133c4fd0d9d73593f601be2248a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4adc1bb606fa4a14d5dbd246f95cecd3"><td class="memItemLeft" align="right" valign="top"><a id="a4adc1bb606fa4a14d5dbd246f95cecd3" name="a4adc1bb606fa4a14d5dbd246f95cecd3"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>mrsymbolIndex</b> (<a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a> key)</td></tr>
<tr class="memdesc:a4adc1bb606fa4a14d5dbd246f95cecd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index portion of a symbol key. <br /></td></tr>
<tr class="separator:a4adc1bb606fa4a14d5dbd246f95cecd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ada276febeb9327efbcc5afdf470db"><td class="memItemLeft" align="right" valign="top"><a id="ac2ada276febeb9327efbcc5afdf470db" name="ac2ada276febeb9327efbcc5afdf470db"></a>
GTSAM_EXPORT std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="a03640.html">Symbol</a> &amp;<a class="el" href="a01596.html#a3bfdb8456463015b2dda092a5805a745">symbol</a>)</td></tr>
<tr class="separator:ac2ada276febeb9327efbcc5afdf470db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfdb8456463015b2dda092a5805a745"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a3bfdb8456463015b2dda092a5805a745">symbol</a> (unsigned char c, std::uint64_t j)</td></tr>
<tr class="memdesc:a3bfdb8456463015b2dda092a5805a745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a symbol key from a character and index, i.e.  <a href="a01596.html#a3bfdb8456463015b2dda092a5805a745">More...</a><br /></td></tr>
<tr class="separator:a3bfdb8456463015b2dda092a5805a745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca9499e881d22361b4833c2854d941f"><td class="memItemLeft" align="right" valign="top"><a id="a9ca9499e881d22361b4833c2854d941f" name="a9ca9499e881d22361b4833c2854d941f"></a>
unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>symbolChr</b> (<a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a> key)</td></tr>
<tr class="memdesc:a9ca9499e881d22361b4833c2854d941f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the character portion of a symbol key. <br /></td></tr>
<tr class="separator:a9ca9499e881d22361b4833c2854d941f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4d98c5186046db873a6c05aebbdf9c"><td class="memItemLeft" align="right" valign="top"><a id="a2f4d98c5186046db873a6c05aebbdf9c" name="a2f4d98c5186046db873a6c05aebbdf9c"></a>
std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>symbolIndex</b> (<a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a> key)</td></tr>
<tr class="memdesc:a2f4d98c5186046db873a6c05aebbdf9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index portion of a symbol key. <br /></td></tr>
<tr class="separator:a2f4d98c5186046db873a6c05aebbdf9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59c7e1d84d5e8570a143898def32125"><td class="memTemplParams" colspan="2"><a id="ac59c7e1d84d5e8570a143898def32125" name="ac59c7e1d84d5e8570a143898def32125"></a>
template&lt;class S , class V &gt; </td></tr>
<tr class="memitem:ac59c7e1d84d5e8570a143898def32125"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preconditionedConjugateGradient</b> (const S &amp;system, const V &amp;initial, const <a class="el" href="a03680.html">ConjugateGradientParameters</a> &amp;parameters)</td></tr>
<tr class="separator:ac59c7e1d84d5e8570a143898def32125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106ec458ddb425604809da93346af55d"><td class="memItemLeft" align="right" valign="top"><a id="a106ec458ddb425604809da93346af55d" name="a106ec458ddb425604809da93346af55d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>dot</b> (const <a class="el" href="a03688.html">Errors</a> &amp;a, const <a class="el" href="a03688.html">Errors</a> &amp;b)</td></tr>
<tr class="memdesc:a106ec458ddb425604809da93346af55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">dot product <br /></td></tr>
<tr class="separator:a106ec458ddb425604809da93346af55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1740d42a2e3b2b6b5ab772b10df484e5"><td class="memItemLeft" align="right" valign="top"><a id="a1740d42a2e3b2b6b5ab772b10df484e5" name="a1740d42a2e3b2b6b5ab772b10df484e5"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a1740d42a2e3b2b6b5ab772b10df484e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>axpy</b> (double alpha, const <a class="el" href="a03688.html">Errors</a> &amp;x, <a class="el" href="a03688.html">Errors</a> &amp;y)</td></tr>
<tr class="memdesc:a1740d42a2e3b2b6b5ab772b10df484e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">BLAS level 2 style. <br /></td></tr>
<tr class="separator:a1740d42a2e3b2b6b5ab772b10df484e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9528f84279a6f9c18d7d5a444735e57a"><td class="memItemLeft" align="right" valign="top"><a id="a9528f84279a6f9c18d7d5a444735e57a" name="a9528f84279a6f9c18d7d5a444735e57a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print</b> (const <a class="el" href="a03688.html">Errors</a> &amp;a, const std::string &amp;s=&quot;Error&quot;)</td></tr>
<tr class="memdesc:a9528f84279a6f9c18d7d5a444735e57a"><td class="mdescLeft">&#160;</td><td class="mdescRight">print with optional string <br /></td></tr>
<tr class="separator:a9528f84279a6f9c18d7d5a444735e57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac339f9bf9dfb0f1eef6b9494a9c0317f"><td class="memItemLeft" align="right" valign="top"><a id="ac339f9bf9dfb0f1eef6b9494a9c0317f" name="ac339f9bf9dfb0f1eef6b9494a9c0317f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac339f9bf9dfb0f1eef6b9494a9c0317f"><td class="memTemplItemLeft" align="right" valign="top">GTSAM_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>axpy</b> (double alpha, const <a class="el" href="a03688.html">Errors</a> &amp;x, <a class="el" href="a03688.html">Errors</a> &amp;y)</td></tr>
<tr class="memdesc:ac339f9bf9dfb0f1eef6b9494a9c0317f"><td class="mdescLeft">&#160;</td><td class="mdescRight">BLAS level 2 style. <br /></td></tr>
<tr class="separator:ac339f9bf9dfb0f1eef6b9494a9c0317f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c269c3243cab16a7475239a9c91021"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a35c269c3243cab16a7475239a9c91021">hasConstraints</a> (const <a class="el" href="a03744.html">GaussianFactorGraph</a> &amp;factors)</td></tr>
<tr class="memdesc:a35c269c3243cab16a7475239a9c91021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates whether linear factors have any constrained noise models.  <a href="a01596.html#a35c269c3243cab16a7475239a9c91021">More...</a><br /></td></tr>
<tr class="separator:a35c269c3243cab16a7475239a9c91021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37760d3ca31c6d8d60a3a2a17babc3a4"><td class="memItemLeft" align="right" valign="top"><a id="a37760d3ca31c6d8d60a3a2a17babc3a4" name="a37760d3ca31c6d8d60a3a2a17babc3a4"></a>
std::pair&lt; boost::shared_ptr&lt; <a class="el" href="a03716.html">GaussianConditional</a> &gt;, boost::shared_ptr&lt; <a class="el" href="a03764.html">HessianFactor</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EliminateCholesky</b> (const <a class="el" href="a03744.html">GaussianFactorGraph</a> &amp;factors, const <a class="el" href="a03632.html">Ordering</a> &amp;keys)</td></tr>
<tr class="separator:a37760d3ca31c6d8d60a3a2a17babc3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb147d2a9039f67ad3b8b5515d2e5cc"><td class="memItemLeft" align="right" valign="top"><a id="adbb147d2a9039f67ad3b8b5515d2e5cc" name="adbb147d2a9039f67ad3b8b5515d2e5cc"></a>
std::pair&lt; boost::shared_ptr&lt; <a class="el" href="a03716.html">GaussianConditional</a> &gt;, boost::shared_ptr&lt; <a class="el" href="a03732.html">GaussianFactor</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EliminatePreferCholesky</b> (const <a class="el" href="a03744.html">GaussianFactorGraph</a> &amp;factors, const <a class="el" href="a03632.html">Ordering</a> &amp;keys)</td></tr>
<tr class="separator:adbb147d2a9039f67ad3b8b5515d2e5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6516ea957c3a22ddf429cefef1fe9486"><td class="memTemplParams" colspan="2">template&lt;class S , class V , class E &gt; </td></tr>
<tr class="memitem:a6516ea957c3a22ddf429cefef1fe9486"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a6516ea957c3a22ddf429cefef1fe9486">conjugateGradients</a> (const S &amp;Ab, V x, const <a class="el" href="a03680.html">ConjugateGradientParameters</a> &amp;parameters, bool steepest=false)</td></tr>
<tr class="memdesc:a6516ea957c3a22ddf429cefef1fe9486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method of conjugate gradients (CG) template "System" class S needs gradient(S,v), e=S*v, v=S^e "Vector" class V needs dot(v,v), -v, v+v, s*v "Vector" class E needs dot(v,v)  <a href="a01596.html#a6516ea957c3a22ddf429cefef1fe9486">More...</a><br /></td></tr>
<tr class="separator:a6516ea957c3a22ddf429cefef1fe9486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dffaf102d7e9efcaea199e4cc2e95e3"><td class="memItemLeft" align="right" valign="top"><a id="a0dffaf102d7e9efcaea199e4cc2e95e3" name="a0dffaf102d7e9efcaea199e4cc2e95e3"></a>
Vector&#160;</td><td class="memItemRight" valign="bottom"><b>steepestDescent</b> (const <a class="el" href="a03776.html">System</a> &amp;Ab, const Vector &amp;x, const <a class="el" href="a03680.html">ConjugateGradientParameters</a> &amp;parameters)</td></tr>
<tr class="separator:a0dffaf102d7e9efcaea199e4cc2e95e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b587fde5d35a27d6c88feb4432e785"><td class="memItemLeft" align="right" valign="top"><a id="ad2b587fde5d35a27d6c88feb4432e785" name="ad2b587fde5d35a27d6c88feb4432e785"></a>
Vector&#160;</td><td class="memItemRight" valign="bottom"><b>conjugateGradientDescent</b> (const <a class="el" href="a03776.html">System</a> &amp;Ab, const Vector &amp;x, const <a class="el" href="a03680.html">ConjugateGradientParameters</a> &amp;parameters)</td></tr>
<tr class="memdesc:ad2b587fde5d35a27d6c88feb4432e785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method of conjugate gradients (CG), <a class="el" href="a03776.html" title="Helper class encapsulating the combined system |Ax-b_|^2 Needed to run Conjugate Gradients on matrice...">System</a> version. <br /></td></tr>
<tr class="separator:ad2b587fde5d35a27d6c88feb4432e785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4b2ca704ddd6530ea70122f883ac88"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#aed4b2ca704ddd6530ea70122f883ac88">steepestDescent</a> (const Matrix &amp;A, const Vector &amp;b, const Vector &amp;x, const <a class="el" href="a03680.html">ConjugateGradientParameters</a> &amp;parameters)</td></tr>
<tr class="memdesc:aed4b2ca704ddd6530ea70122f883ac88"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience calls using matrices, will create <a class="el" href="a03776.html" title="Helper class encapsulating the combined system |Ax-b_|^2 Needed to run Conjugate Gradients on matrice...">System</a> class internally:  <a href="a01596.html#aed4b2ca704ddd6530ea70122f883ac88">More...</a><br /></td></tr>
<tr class="separator:aed4b2ca704ddd6530ea70122f883ac88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55440f741d8b2f706101f7a79ba7111"><td class="memItemLeft" align="right" valign="top"><a id="af55440f741d8b2f706101f7a79ba7111" name="af55440f741d8b2f706101f7a79ba7111"></a>
Vector&#160;</td><td class="memItemRight" valign="bottom"><b>conjugateGradientDescent</b> (const Matrix &amp;A, const Vector &amp;b, const Vector &amp;x, const <a class="el" href="a03680.html">ConjugateGradientParameters</a> &amp;parameters)</td></tr>
<tr class="memdesc:af55440f741d8b2f706101f7a79ba7111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method of conjugate gradients (CG), Matrix version. <br /></td></tr>
<tr class="separator:af55440f741d8b2f706101f7a79ba7111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b7af7638d28555c3f404318cc67b22"><td class="memItemLeft" align="right" valign="top"><a id="a81b7af7638d28555c3f404318cc67b22" name="a81b7af7638d28555c3f404318cc67b22"></a>
<a class="el" href="a04016.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><b>steepestDescent</b> (const <a class="el" href="a03744.html">GaussianFactorGraph</a> &amp;fg, const <a class="el" href="a04016.html">VectorValues</a> &amp;x, const <a class="el" href="a03680.html">ConjugateGradientParameters</a> &amp;parameters)</td></tr>
<tr class="memdesc:a81b7af7638d28555c3f404318cc67b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method of steepest gradients, Gaussian <a class="el" href="a03544.html" title="This is the base class for all factor types.">Factor</a> Graph version. <br /></td></tr>
<tr class="separator:a81b7af7638d28555c3f404318cc67b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84114ad1593684ad739088a2898afdb"><td class="memItemLeft" align="right" valign="top"><a id="aa84114ad1593684ad739088a2898afdb" name="aa84114ad1593684ad739088a2898afdb"></a>
<a class="el" href="a04016.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><b>conjugateGradientDescent</b> (const <a class="el" href="a03744.html">GaussianFactorGraph</a> &amp;fg, const <a class="el" href="a04016.html">VectorValues</a> &amp;x, const <a class="el" href="a03680.html">ConjugateGradientParameters</a> &amp;parameters)</td></tr>
<tr class="memdesc:aa84114ad1593684ad739088a2898afdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method of conjugate gradients (CG), Gaussian <a class="el" href="a03544.html" title="This is the base class for all factor types.">Factor</a> Graph version. <br /></td></tr>
<tr class="separator:aa84114ad1593684ad739088a2898afdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ca85391e3bc671c71b68bc324296f0"><td class="memItemLeft" align="right" valign="top"><a id="a37ca85391e3bc671c71b68bc324296f0" name="a37ca85391e3bc671c71b68bc324296f0"></a>
GTSAM_EXPORT Vector&#160;</td><td class="memItemRight" valign="bottom"><b>steepestDescent</b> (const <a class="el" href="a03776.html">System</a> &amp;Ab, const Vector &amp;x, const <a class="el" href="a03780.html">IterativeOptimizationParameters</a> &amp;parameters)</td></tr>
<tr class="memdesc:a37ca85391e3bc671c71b68bc324296f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method of steepest gradients, <a class="el" href="a03776.html" title="Helper class encapsulating the combined system |Ax-b_|^2 Needed to run Conjugate Gradients on matrice...">System</a> version. <br /></td></tr>
<tr class="separator:a37ca85391e3bc671c71b68bc324296f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4fce2472860a0352b08bd4303d11833"><td class="memItemLeft" align="right" valign="top"><a id="ae4fce2472860a0352b08bd4303d11833" name="ae4fce2472860a0352b08bd4303d11833"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const <a class="el" href="a03780.html">IterativeOptimizationParameters</a> &amp;p)</td></tr>
<tr class="separator:ae4fce2472860a0352b08bd4303d11833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad694dc473cd9cf50cd0f1018b565b074"><td class="memItemLeft" align="right" valign="top"><a id="ad694dc473cd9cf50cd0f1018b565b074" name="ad694dc473cd9cf50cd0f1018b565b074"></a>
FastVector&lt; VariableSlots::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>orderedSlotsHelper</b> (const <a class="el" href="a03632.html">Ordering</a> &amp;ordering, const <a class="el" href="a03660.html">VariableSlots</a> &amp;variableSlots)</td></tr>
<tr class="separator:ad694dc473cd9cf50cd0f1018b565b074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56c4bfa363f8c23c48eb078e9c84a9c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="a03716.html#aca05dc6ca9aea64f4621a8c8d2bf3d01">GaussianConditional::shared_ptr</a>, <a class="el" href="a03796.html#adaf03a52ed83559d6a03cbab95092698">JacobianFactor::shared_ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#ab56c4bfa363f8c23c48eb078e9c84a9c">EliminateQR</a> (const <a class="el" href="a03744.html">GaussianFactorGraph</a> &amp;factors, const <a class="el" href="a03632.html">Ordering</a> &amp;keys)</td></tr>
<tr class="memdesc:ab56c4bfa363f8c23c48eb078e9c84a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply all factors and eliminate the given keys from the resulting factor using a QR variant that handles constraints (zero sigmas).  <a href="a01596.html#ab56c4bfa363f8c23c48eb078e9c84a9c">More...</a><br /></td></tr>
<tr class="separator:ab56c4bfa363f8c23c48eb078e9c84a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ae90e770b12b83d1d6b66f094a7217"><td class="memItemLeft" align="right" valign="top"><a id="a27ae90e770b12b83d1d6b66f094a7217" name="a27ae90e770b12b83d1d6b66f094a7217"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const <a class="el" href="a03936.html">PreconditionerParameters</a> &amp;p)</td></tr>
<tr class="separator:a27ae90e770b12b83d1d6b66f094a7217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15166e9109e27ad12da01627efc9b856"><td class="memItemLeft" align="right" valign="top"><a id="a15166e9109e27ad12da01627efc9b856" name="a15166e9109e27ad12da01627efc9b856"></a>
boost::shared_ptr&lt; <a class="el" href="a03940.html">Preconditioner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>createPreconditioner</b> (const boost::shared_ptr&lt; <a class="el" href="a03936.html">PreconditionerParameters</a> &gt; params)</td></tr>
<tr class="separator:a15166e9109e27ad12da01627efc9b856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9013a9053629f0c00b97726d9d8e19e"><td class="memItemLeft" align="right" valign="top"><a id="aa9013a9053629f0c00b97726d9d8e19e" name="aa9013a9053629f0c00b97726d9d8e19e"></a>
<a class="el" href="a01596.html#a52b9b28b076a8ae17d6d3d72ee1229c3">SparseEigen</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sparseJacobianEigen</b> (const <a class="el" href="a03744.html">GaussianFactorGraph</a> &amp;gfg, const <a class="el" href="a03632.html">Ordering</a> &amp;ordering)</td></tr>
<tr class="memdesc:aa9013a9053629f0c00b97726d9d8e19e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an Eigen-format SparseMatrix of a <a class="el" href="a03744.html" title="A Linear Factor Graph is a factor graph where all factors are Gaussian, i.e.">GaussianFactorGraph</a>. <br /></td></tr>
<tr class="separator:aa9013a9053629f0c00b97726d9d8e19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe813c3f6ac885c7f2a842ed296d97ed"><td class="memItemLeft" align="right" valign="top"><a id="abe813c3f6ac885c7f2a842ed296d97ed" name="abe813c3f6ac885c7f2a842ed296d97ed"></a>
<a class="el" href="a01596.html#a52b9b28b076a8ae17d6d3d72ee1229c3">SparseEigen</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sparseJacobianEigen</b> (const <a class="el" href="a03744.html">GaussianFactorGraph</a> &amp;gfg)</td></tr>
<tr class="separator:abe813c3f6ac885c7f2a842ed296d97ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f790f9aa8d772e952af57e29d0adec"><td class="memItemLeft" align="right" valign="top"><a id="ae3f790f9aa8d772e952af57e29d0adec" name="ae3f790f9aa8d772e952af57e29d0adec"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const <a class="el" href="a03988.html">Subgraph::Edge</a> &amp;edge)</td></tr>
<tr class="separator:ae3f790f9aa8d772e952af57e29d0adec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80fda1fb2d88d5adb95dc327e1e6cf71"><td class="memItemLeft" align="right" valign="top"><a id="a80fda1fb2d88d5adb95dc327e1e6cf71" name="a80fda1fb2d88d5adb95dc327e1e6cf71"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const <a class="el" href="a03984.html">Subgraph</a> &amp;subgraph)</td></tr>
<tr class="separator:a80fda1fb2d88d5adb95dc327e1e6cf71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e97ebb64a29a2bf2fa337339a1ee27"><td class="memItemLeft" align="right" valign="top"><a id="ad6e97ebb64a29a2bf2fa337339a1ee27" name="ad6e97ebb64a29a2bf2fa337339a1ee27"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const <a class="el" href="a03992.html">SubgraphBuilderParameters</a> &amp;p)</td></tr>
<tr class="separator:ad6e97ebb64a29a2bf2fa337339a1ee27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06ac82e22341b1b9fdcd4c67280f619"><td class="memItemLeft" align="right" valign="top"><a id="ac06ac82e22341b1b9fdcd4c67280f619" name="ac06ac82e22341b1b9fdcd4c67280f619"></a>
<a class="el" href="a03744.html#a1f73f4987b9bdaac5c1414a401c0364c">GaussianFactorGraph::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>buildFactorSubgraph</b> (const <a class="el" href="a03744.html">GaussianFactorGraph</a> &amp;gfg, const <a class="el" href="a03984.html">Subgraph</a> &amp;subgraph, const bool clone)</td></tr>
<tr class="memdesc:ac06ac82e22341b1b9fdcd4c67280f619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select the factors in a factor graph according to the subgraph. <br /></td></tr>
<tr class="separator:ac06ac82e22341b1b9fdcd4c67280f619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3749ce0f63e205e55daa615aa1fd74a"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="a03744.html#a1f73f4987b9bdaac5c1414a401c0364c">GaussianFactorGraph::shared_ptr</a>, <a class="el" href="a03744.html#a1f73f4987b9bdaac5c1414a401c0364c">GaussianFactorGraph::shared_ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#ab3749ce0f63e205e55daa615aa1fd74a">splitFactorGraph</a> (const <a class="el" href="a03744.html">GaussianFactorGraph</a> &amp;factorGraph, const <a class="el" href="a03984.html">Subgraph</a> &amp;subgraph)</td></tr>
<tr class="memdesc:ab3749ce0f63e205e55daa615aa1fd74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the graph into a subgraph and the remaining edges.  <a href="a01596.html#ab3749ce0f63e205e55daa615aa1fd74a">More...</a><br /></td></tr>
<tr class="separator:ab3749ce0f63e205e55daa615aa1fd74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd8a1269185cc3808cadb1d602ecd4e"><td class="memItemLeft" align="right" valign="top"><a id="adcd8a1269185cc3808cadb1d602ecd4e" name="adcd8a1269185cc3808cadb1d602ecd4e"></a>
GTSAM_EXPORT ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const <a class="el" href="a04016.html">VectorValues</a> &amp;v)</td></tr>
<tr class="separator:adcd8a1269185cc3808cadb1d602ecd4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131393739a049cb8d3c3d0c3c6e960d6"><td class="memItemLeft" align="right" valign="top"><a id="a131393739a049cb8d3c3d0c3c6e960d6" name="a131393739a049cb8d3c3d0c3c6e960d6"></a>
<a class="el" href="a04016.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const double a, const <a class="el" href="a04016.html">VectorValues</a> &amp;v)</td></tr>
<tr class="separator:a131393739a049cb8d3c3d0c3c6e960d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d16827e9074dad6703e6f166bad49f"><td class="memItemLeft" align="right" valign="top"><a id="a00d16827e9074dad6703e6f166bad49f" name="a00d16827e9074dad6703e6f166bad49f"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="a04060.html">CombinedImuFactor</a> &amp;f)</td></tr>
<tr class="separator:a00d16827e9074dad6703e6f166bad49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d41716214e4a8679cc3e8746b39bee0"><td class="memItemLeft" align="right" valign="top"><a id="a5d41716214e4a8679cc3e8746b39bee0" name="a5d41716214e4a8679cc3e8746b39bee0"></a>
<a class="el" href="a04240.html">Rot3_</a>&#160;</td><td class="memItemRight" valign="bottom"><b>attitude</b> (const <a class="el" href="a04240.html">NavState_</a> &amp;X)</td></tr>
<tr class="separator:a5d41716214e4a8679cc3e8746b39bee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafae0cdebb673850c56e44aa9af11bc4"><td class="memItemLeft" align="right" valign="top"><a id="aafae0cdebb673850c56e44aa9af11bc4" name="aafae0cdebb673850c56e44aa9af11bc4"></a>
<a class="el" href="a04240.html">Point3_</a>&#160;</td><td class="memItemRight" valign="bottom"><b>position</b> (const <a class="el" href="a04240.html">NavState_</a> &amp;X)</td></tr>
<tr class="separator:aafae0cdebb673850c56e44aa9af11bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae860cbcc2ecf1b1272b77e7086445e93"><td class="memItemLeft" align="right" valign="top"><a id="ae860cbcc2ecf1b1272b77e7086445e93" name="ae860cbcc2ecf1b1272b77e7086445e93"></a>
<a class="el" href="a04240.html">Velocity3_</a>&#160;</td><td class="memItemRight" valign="bottom"><b>velocity</b> (const <a class="el" href="a04240.html">NavState_</a> &amp;X)</td></tr>
<tr class="separator:ae860cbcc2ecf1b1272b77e7086445e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27bf3e1cd62b587ef1b3bc76e8fbe720"><td class="memItemLeft" align="right" valign="top"><a id="a27bf3e1cd62b587ef1b3bc76e8fbe720" name="a27bf3e1cd62b587ef1b3bc76e8fbe720"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="a04100.html">ImuFactor</a> &amp;f)</td></tr>
<tr class="separator:a27bf3e1cd62b587ef1b3bc76e8fbe720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe04e42120f4aacda80ed4fcd9ba2012"><td class="memItemLeft" align="right" valign="top"><a id="afe04e42120f4aacda80ed4fcd9ba2012" name="afe04e42120f4aacda80ed4fcd9ba2012"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="a04104.html">ImuFactor2</a> &amp;f)</td></tr>
<tr class="separator:afe04e42120f4aacda80ed4fcd9ba2012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745a98451e58f728a43fc65df516cf3a"><td class="memItemLeft" align="right" valign="top"><a id="a745a98451e58f728a43fc65df516cf3a" name="a745a98451e58f728a43fc65df516cf3a"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const <a class="el" href="a04144.html">NavState</a> &amp;state)</td></tr>
<tr class="separator:a745a98451e58f728a43fc65df516cf3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d355fa45d72ea7c960908231c895674"><td class="memItemLeft" align="right" valign="top"><a id="a7d355fa45d72ea7c960908231c895674" name="a7d355fa45d72ea7c960908231c895674"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const <a class="el" href="a04164.html">PreintegrationBase</a> &amp;pim)</td></tr>
<tr class="separator:a7d355fa45d72ea7c960908231c895674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db519caa1b7e43412c9a7e13acf8329"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3db519caa1b7e43412c9a7e13acf8329"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a04240.html">Expression</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a3db519caa1b7e43412c9a7e13acf8329">operator*</a> (const <a class="el" href="a04240.html">Expression</a>&lt; T &gt; &amp;expression1, const <a class="el" href="a04240.html">Expression</a>&lt; T &gt; &amp;expression2)</td></tr>
<tr class="memdesc:a3db519caa1b7e43412c9a7e13acf8329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a product expression, assumes T::compose(T) -&gt; T.  <a href="a01596.html#a3db519caa1b7e43412c9a7e13acf8329">More...</a><br /></td></tr>
<tr class="separator:a3db519caa1b7e43412c9a7e13acf8329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51881c20dd5ecdd129cb993ea8374846"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51881c20dd5ecdd129cb993ea8374846"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a04240.html">Expression</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a51881c20dd5ecdd129cb993ea8374846">createUnknowns</a> (size_t n, char c, size_t start)</td></tr>
<tr class="memdesc:a51881c20dd5ecdd129cb993ea8374846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an array of leaves.  <a href="a01596.html#a51881c20dd5ecdd129cb993ea8374846">More...</a><br /></td></tr>
<tr class="separator:a51881c20dd5ecdd129cb993ea8374846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794029fe8dfc03f67a8cb64ad05d47c9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:a794029fe8dfc03f67a8cb64ad05d47c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a04240.html">Expression</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a794029fe8dfc03f67a8cb64ad05d47c9">linearExpression</a> (const std::function&lt; T(A)&gt; &amp;f, const <a class="el" href="a04240.html">Expression</a>&lt; A &gt; &amp;expression, const Eigen::Matrix&lt; double, <a class="el" href="a02444.html">traits</a>&lt; T &gt;::dimension, <a class="el" href="a02444.html">traits</a>&lt; A &gt;::dimension &gt; &amp;dTdA)</td></tr>
<tr class="memdesc:a794029fe8dfc03f67a8cb64ad05d47c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an expression out of a linear function f:T-&gt;A with (constant) Jacobian dTdA TODO(frank): create a more efficient version like <a class="el" href="a04256.html" title="A ScalarMultiplyExpression is a specialization of Expression that multiplies with a scalar It optimiz...">ScalarMultiplyExpression</a>.  <a href="a01596.html#a794029fe8dfc03f67a8cb64ad05d47c9">More...</a><br /></td></tr>
<tr class="separator:a794029fe8dfc03f67a8cb64ad05d47c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405f3793afc2cc3173c3fbdecadb162a"><td class="memTemplParams" colspan="2"><a id="a405f3793afc2cc3173c3fbdecadb162a" name="a405f3793afc2cc3173c3fbdecadb162a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a405f3793afc2cc3173c3fbdecadb162a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a04256.html">ScalarMultiplyExpression</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (double s, const <a class="el" href="a04240.html">Expression</a>&lt; T &gt; &amp;e)</td></tr>
<tr class="memdesc:a405f3793afc2cc3173c3fbdecadb162a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an expression that executes the scalar multiplication with an input expression The type T must be a vector space Example: Expression&lt;Point2&gt; a(0), b = 12 * a;. <br /></td></tr>
<tr class="separator:a405f3793afc2cc3173c3fbdecadb162a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589e3ff8cd71e5a17ee1dcfae8b2df26"><td class="memTemplParams" colspan="2"><a id="a589e3ff8cd71e5a17ee1dcfae8b2df26" name="a589e3ff8cd71e5a17ee1dcfae8b2df26"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a589e3ff8cd71e5a17ee1dcfae8b2df26"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a04260.html">BinarySumExpression</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="a04240.html">Expression</a>&lt; T &gt; &amp;e1, const <a class="el" href="a04240.html">Expression</a>&lt; T &gt; &amp;e2)</td></tr>
<tr class="memdesc:a589e3ff8cd71e5a17ee1dcfae8b2df26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an expression that sums two input expressions of the same type T The type T must be a vector space Example: Expression&lt;Point2&gt; a(0), b(1), c = a + b;. <br /></td></tr>
<tr class="separator:a589e3ff8cd71e5a17ee1dcfae8b2df26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9512eb02324210895442f2bf8268902d"><td class="memTemplParams" colspan="2"><a id="a9512eb02324210895442f2bf8268902d" name="a9512eb02324210895442f2bf8268902d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9512eb02324210895442f2bf8268902d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a04260.html">BinarySumExpression</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="a04240.html">Expression</a>&lt; T &gt; &amp;e1, const <a class="el" href="a04240.html">Expression</a>&lt; T &gt; &amp;e2)</td></tr>
<tr class="memdesc:a9512eb02324210895442f2bf8268902d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an expression that subtracts one expression from another. <br /></td></tr>
<tr class="separator:a9512eb02324210895442f2bf8268902d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628d95be36359707accc947aa8a56101"><td class="memTemplParams" colspan="2"><a id="a628d95be36359707accc947aa8a56101" name="a628d95be36359707accc947aa8a56101"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a628d95be36359707accc947aa8a56101"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a04240.html">Expression</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>between</b> (const <a class="el" href="a04240.html">Expression</a>&lt; T &gt; &amp;t1, const <a class="el" href="a04240.html">Expression</a>&lt; T &gt; &amp;t2)</td></tr>
<tr class="separator:a628d95be36359707accc947aa8a56101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc28db7b30377fdebc95972751938c8f"><td class="memTemplParams" colspan="2"><a id="acc28db7b30377fdebc95972751938c8f" name="acc28db7b30377fdebc95972751938c8f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acc28db7b30377fdebc95972751938c8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a04240.html">Expression</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compose</b> (const <a class="el" href="a04240.html">Expression</a>&lt; T &gt; &amp;t1, const <a class="el" href="a04240.html">Expression</a>&lt; T &gt; &amp;t2)</td></tr>
<tr class="separator:acc28db7b30377fdebc95972751938c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9753b4e62378151d30bf8af5e2fc1602"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a03796.html">JacobianFactor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a9753b4e62378151d30bf8af5e2fc1602">linearizeNumerically</a> (const <a class="el" href="a04448.html">NoiseModelFactor</a> &amp;factor, const <a class="el" href="a04560.html">Values</a> &amp;values, double delta=1e-5)</td></tr>
<tr class="memdesc:a9753b4e62378151d30bf8af5e2fc1602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linearize a nonlinear factor using numerical differentiation The benefit of this method is that it does not need to know what types are involved to evaluate the factor.  <a href="a01596.html#a9753b4e62378151d30bf8af5e2fc1602">More...</a><br /></td></tr>
<tr class="separator:a9753b4e62378151d30bf8af5e2fc1602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2a0b16c9f78f20fc78fa39c7426242"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R , typename FUNC &gt; </td></tr>
<tr class="memitem:a9d2a0b16c9f78f20fc78fa39c7426242"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a04284.html">FunctorizedFactor</a>&lt; R, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a9d2a0b16c9f78f20fc78fa39c7426242">MakeFunctorizedFactor</a> (<a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a> key, const R &amp;z, const <a class="el" href="a01596.html#ab6e5a4884342656e0837ef07008ec03f">SharedNoiseModel</a> &amp;model, const FUNC func)</td></tr>
<tr class="memdesc:a9d2a0b16c9f78f20fc78fa39c7426242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create a functorized factor.  <a href="a01596.html#a9d2a0b16c9f78f20fc78fa39c7426242">More...</a><br /></td></tr>
<tr class="separator:a9d2a0b16c9f78f20fc78fa39c7426242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313f0e290f370cff0b7e25024d1b8c6d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename R , typename FUNC &gt; </td></tr>
<tr class="memitem:a313f0e290f370cff0b7e25024d1b8c6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a04292.html">FunctorizedFactor2</a>&lt; R, T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a313f0e290f370cff0b7e25024d1b8c6d">MakeFunctorizedFactor2</a> (<a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a> key1, <a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a> key2, const R &amp;z, const <a class="el" href="a01596.html#ab6e5a4884342656e0837ef07008ec03f">SharedNoiseModel</a> &amp;model, const FUNC func)</td></tr>
<tr class="memdesc:a313f0e290f370cff0b7e25024d1b8c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create a functorized factor.  <a href="a01596.html#a313f0e290f370cff0b7e25024d1b8c6d">More...</a><br /></td></tr>
<tr class="separator:a313f0e290f370cff0b7e25024d1b8c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0857edd76f8d63eeee0ce9944e28d4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a2b0857edd76f8d63eeee0ce9944e28d4">optimizeWildfire</a> (const ISAM2Clique::shared_ptr &amp;root, double threshold, const <a class="el" href="a02488.html">KeySet</a> &amp;replaced, <a class="el" href="a04016.html">VectorValues</a> *delta)</td></tr>
<tr class="memdesc:a2b0857edd76f8d63eeee0ce9944e28d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize the <a class="el" href="a03496.html">BayesTree</a>, starting from the root.  <a href="a01596.html#a2b0857edd76f8d63eeee0ce9944e28d4">More...</a><br /></td></tr>
<tr class="separator:a2b0857edd76f8d63eeee0ce9944e28d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c4ce71a3fc1bf5ec8b6d7ddbee206b"><td class="memItemLeft" align="right" valign="top"><a id="a72c4ce71a3fc1bf5ec8b6d7ddbee206b" name="a72c4ce71a3fc1bf5ec8b6d7ddbee206b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>optimizeWildfireNonRecursive</b> (const ISAM2Clique::shared_ptr &amp;root, double threshold, const <a class="el" href="a02488.html">KeySet</a> &amp;keys, <a class="el" href="a04016.html">VectorValues</a> *delta)</td></tr>
<tr class="separator:a72c4ce71a3fc1bf5ec8b6d7ddbee206b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ceb9e5a5e864b96c529db67f55a873b"><td class="memTemplParams" colspan="2"><a id="a0ceb9e5a5e864b96c529db67f55a873b" name="a0ceb9e5a5e864b96c529db67f55a873b"></a>
template&lt;class S , class V , class W &gt; </td></tr>
<tr class="memitem:a0ceb9e5a5e864b96c529db67f55a873b"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lineSearch</b> (const S &amp;system, const V currentValues, const W &amp;gradient)</td></tr>
<tr class="memdesc:a0ceb9e5a5e864b96c529db67f55a873b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement the golden-section line search algorithm. <br /></td></tr>
<tr class="separator:a0ceb9e5a5e864b96c529db67f55a873b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc19854e0bfc1acadb00ff00a043cc17"><td class="memTemplParams" colspan="2">template&lt;class S , class V &gt; </td></tr>
<tr class="memitem:afc19854e0bfc1acadb00ff00a043cc17"><td class="memTemplItemLeft" align="right" valign="top">boost::tuple&lt; V, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#afc19854e0bfc1acadb00ff00a043cc17">nonlinearConjugateGradient</a> (const S &amp;system, const V &amp;initial, const <a class="el" href="a04496.html">NonlinearOptimizerParams</a> &amp;params, const bool singleIteration, const bool gradientDescent=false)</td></tr>
<tr class="memdesc:afc19854e0bfc1acadb00ff00a043cc17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement the nonlinear conjugate gradient method using the Polak-Ribiere formula suggested in <a href="http://en.wikipedia.org/wiki/Nonlinear_conjugate_gradient_method">http://en.wikipedia.org/wiki/Nonlinear_conjugate_gradient_method</a>.  <a href="a01596.html#afc19854e0bfc1acadb00ff00a043cc17">More...</a><br /></td></tr>
<tr class="separator:afc19854e0bfc1acadb00ff00a043cc17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3382482454c164c6f5817dcbe6f932b3"><td class="memItemLeft" align="right" valign="top"><a id="a3382482454c164c6f5817dcbe6f932b3" name="a3382482454c164c6f5817dcbe6f932b3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>checkConvergence</b> (double relativeErrorTreshold, double absoluteErrorTreshold, double errorThreshold, double currentError, double newError, <a class="el" href="a04496.html#a2b085d375ec6effa42e3deaaeab98694">NonlinearOptimizerParams::Verbosity</a> verbosity=NonlinearOptimizerParams::SILENT)</td></tr>
<tr class="memdesc:a3382482454c164c6f5817dcbe6f932b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the relative error decrease is less than relativeErrorTreshold, the absolute error decrease is less than absoluteErrorTreshold, <em>or</em> the error itself is less than errorThreshold. <br /></td></tr>
<tr class="separator:a3382482454c164c6f5817dcbe6f932b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f253c087f2bec9017b8be85040367aa"><td class="memItemLeft" align="right" valign="top"><a id="a5f253c087f2bec9017b8be85040367aa" name="a5f253c087f2bec9017b8be85040367aa"></a>
GTSAM_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><b>checkConvergence</b> (const <a class="el" href="a04496.html">NonlinearOptimizerParams</a> &amp;params, double currentError, double newError)</td></tr>
<tr class="separator:a5f253c087f2bec9017b8be85040367aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef971b2c69845e4fcce707306703c7b8"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#aef971b2c69845e4fcce707306703c7b8">findExampleDataFile</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:aef971b2c69845e4fcce707306703c7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the full path to an example dataset distributed with gtsam.  <a href="a01596.html#aef971b2c69845e4fcce707306703c7b8">More...</a><br /></td></tr>
<tr class="separator:aef971b2c69845e4fcce707306703c7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe09e573771fd72b08069353d537725"><td class="memItemLeft" align="right" valign="top"><a id="adbe09e573771fd72b08069353d537725" name="adbe09e573771fd72b08069353d537725"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>createRewrittenFileName</b> (const std::string &amp;name)</td></tr>
<tr class="memdesc:adbe09e573771fd72b08069353d537725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a temporary file name that needs to be ignored in .gitingnore for checking read-write oprations. <br /></td></tr>
<tr class="separator:adbe09e573771fd72b08069353d537725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b68182ddcb10f2319bf75681216dfc"><td class="memTemplParams" colspan="2"><a id="a74b68182ddcb10f2319bf75681216dfc" name="a74b68182ddcb10f2319bf75681216dfc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a74b68182ddcb10f2319bf75681216dfc"><td class="memTemplItemLeft" align="right" valign="top">map&lt; size_t, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parseToMap</b> (const string &amp;filename, Parser&lt; pair&lt; size_t, T &gt; &gt; parse, size_t maxIndex)</td></tr>
<tr class="separator:a74b68182ddcb10f2319bf75681216dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc0157e4790e3b03dc601d3e86c684d"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; <a class="el" href="a01596.html#a6ab764d13f9aaeafc2dc60763b05ec0e">IndexedPose</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#abfc0157e4790e3b03dc601d3e86c684d">parseVertexPose</a> (std::istream &amp;is, const std::string &amp;tag)</td></tr>
<tr class="memdesc:abfc0157e4790e3b03dc601d3e86c684d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse TORO/G2O vertex "id x y yaw".  <a href="a01596.html#abfc0157e4790e3b03dc601d3e86c684d">More...</a><br /></td></tr>
<tr class="separator:abfc0157e4790e3b03dc601d3e86c684d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f310889a1945b0684524b706045f615"><td class="memItemLeft" align="right" valign="top"><a id="a4f310889a1945b0684524b706045f615" name="a4f310889a1945b0684524b706045f615"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a4f310889a1945b0684524b706045f615"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; size_t, <a class="el" href="a03264.html">Pose2</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parseVariables&lt; Pose2 &gt;</b> (const std::string &amp;filename, size_t maxIndex)</td></tr>
<tr class="separator:a4f310889a1945b0684524b706045f615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961e0398bbfc2504c62fdaad70472418"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; IndexedLandmark &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a961e0398bbfc2504c62fdaad70472418">parseVertexLandmark</a> (std::istream &amp;is, const std::string &amp;tag)</td></tr>
<tr class="memdesc:a961e0398bbfc2504c62fdaad70472418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse G2O landmark vertex "id x y".  <a href="a01596.html#a961e0398bbfc2504c62fdaad70472418">More...</a><br /></td></tr>
<tr class="separator:a961e0398bbfc2504c62fdaad70472418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4b65f9a17045966d1e15a135869149"><td class="memItemLeft" align="right" valign="top"><a id="a3d4b65f9a17045966d1e15a135869149" name="a3d4b65f9a17045966d1e15a135869149"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a3d4b65f9a17045966d1e15a135869149"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; size_t, <a class="el" href="a01596.html#a6ede8384dee0353a0ce5fb54ea50c21d">Point2</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parseVariables&lt; Point2 &gt;</b> (const std::string &amp;filename, size_t maxIndex)</td></tr>
<tr class="separator:a3d4b65f9a17045966d1e15a135869149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8bb9db0893652e8b5e7b47782ec990"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; IndexedEdge &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#abc8bb9db0893652e8b5e7b47782ec990">parseEdge</a> (std::istream &amp;is, const std::string &amp;tag)</td></tr>
<tr class="memdesc:abc8bb9db0893652e8b5e7b47782ec990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse TORO/G2O edge "id1 id2 x y yaw".  <a href="a01596.html#abc8bb9db0893652e8b5e7b47782ec990">More...</a><br /></td></tr>
<tr class="separator:abc8bb9db0893652e8b5e7b47782ec990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02dbe8fc28b5cfdf24dfb1c668b8753"><td class="memItemLeft" align="right" valign="top"><a id="ad02dbe8fc28b5cfdf24dfb1c668b8753" name="ad02dbe8fc28b5cfdf24dfb1c668b8753"></a>
boost::shared_ptr&lt; <a class="el" href="a03972.html">Sampler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>createSampler</b> (const <a class="el" href="a01596.html#ab6e5a4884342656e0837ef07008ec03f">SharedNoiseModel</a> &amp;model)</td></tr>
<tr class="separator:ad02dbe8fc28b5cfdf24dfb1c668b8753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6094db7a7279c94e0c4b91372e292d18"><td class="memItemLeft" align="right" valign="top"><a id="a6094db7a7279c94e0c4b91372e292d18" name="a6094db7a7279c94e0c4b91372e292d18"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a6094db7a7279c94e0c4b91372e292d18"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a04632.html">BinaryMeasurement</a>&lt; <a class="el" href="a03264.html">Pose2</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parseMeasurements</b> (const std::string &amp;filename, const noiseModel::Diagonal::shared_ptr &amp;model, size_t maxIndex)</td></tr>
<tr class="separator:a6094db7a7279c94e0c4b91372e292d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8feed7da4b7baafd2fba6954879554c0"><td class="memItemLeft" align="right" valign="top"><a id="a8feed7da4b7baafd2fba6954879554c0" name="a8feed7da4b7baafd2fba6954879554c0"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a8feed7da4b7baafd2fba6954879554c0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a04632.html">BinaryMeasurement</a>&lt; <a class="el" href="a03320.html">Rot2</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parseMeasurements</b> (const std::string &amp;filename, const noiseModel::Diagonal::shared_ptr &amp;model, size_t maxIndex)</td></tr>
<tr class="separator:a8feed7da4b7baafd2fba6954879554c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea5b152b9592dda4da485251a44db51"><td class="memItemLeft" align="right" valign="top"><a id="a6ea5b152b9592dda4da485251a44db51" name="a6ea5b152b9592dda4da485251a44db51"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a6ea5b152b9592dda4da485251a44db51"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a04684.html">BetweenFactor</a>&lt; <a class="el" href="a03264.html">Pose2</a> &gt;::shared_ptr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parseFactors&lt; Pose2 &gt;</b> (const std::string &amp;filename, const noiseModel::Diagonal::shared_ptr &amp;model, size_t maxIndex)</td></tr>
<tr class="separator:a6ea5b152b9592dda4da485251a44db51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635ec096b94adc2b05f081cd07eb2c0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01596.html#abcc5d1ec05ddc954d5de28929acabbdf">GraphAndValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a635ec096b94adc2b05f081cd07eb2c0f">load2D</a> (const std::string &amp;filename, <a class="el" href="a01596.html#ab6e5a4884342656e0837ef07008ec03f">SharedNoiseModel</a> model=<a class="el" href="a01596.html#ab6e5a4884342656e0837ef07008ec03f">SharedNoiseModel</a>(), size_t maxIndex=0, bool addNoise=false, bool smart=true, <a class="el" href="a01596.html#a90552b70a2da9c74595cae4b05c2ce18">NoiseFormat</a> noiseFormat=<a class="el" href="a01596.html#a90552b70a2da9c74595cae4b05c2ce18a2f9067b8f5bd2d0dd38c49326a4c070e">NoiseFormatAUTO</a>, <a class="el" href="a01596.html#a8be373f34edc0a9d28b1bfab5dd62ba0">KernelFunctionType</a> kernelFunctionType=KernelFunctionTypeNONE)</td></tr>
<tr class="memdesc:a635ec096b94adc2b05f081cd07eb2c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load TORO/G2O style graph files.  <a href="a01596.html#a635ec096b94adc2b05f081cd07eb2c0f">More...</a><br /></td></tr>
<tr class="separator:a635ec096b94adc2b05f081cd07eb2c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f6cde1c018ea0f4ca3c7fc83123a14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01596.html#abcc5d1ec05ddc954d5de28929acabbdf">GraphAndValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a79f6cde1c018ea0f4ca3c7fc83123a14">load2D</a> (pair&lt; string, <a class="el" href="a01596.html#ab6e5a4884342656e0837ef07008ec03f">SharedNoiseModel</a> &gt; dataset, size_t maxIndex, bool addNoise, bool smart, <a class="el" href="a01596.html#a90552b70a2da9c74595cae4b05c2ce18">NoiseFormat</a> noiseFormat, <a class="el" href="a01596.html#a8be373f34edc0a9d28b1bfab5dd62ba0">KernelFunctionType</a> kernelFunctionType)</td></tr>
<tr class="memdesc:a79f6cde1c018ea0f4ca3c7fc83123a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load TORO 2D Graph.  <a href="a01596.html#a79f6cde1c018ea0f4ca3c7fc83123a14">More...</a><br /></td></tr>
<tr class="separator:a79f6cde1c018ea0f4ca3c7fc83123a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc118b53bf98ad0d0a33bdc107fbefc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01596.html#abcc5d1ec05ddc954d5de28929acabbdf">GraphAndValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#abc118b53bf98ad0d0a33bdc107fbefc8">load2D_robust</a> (const string &amp;filename, const noiseModel::Base::shared_ptr &amp;model, size_t maxIndex)</td></tr>
<tr class="separator:abc118b53bf98ad0d0a33bdc107fbefc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe516bc2d9ca4cc4530dd3b8460ce3d"><td class="memItemLeft" align="right" valign="top"><a id="acfe516bc2d9ca4cc4530dd3b8460ce3d" name="acfe516bc2d9ca4cc4530dd3b8460ce3d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>save2D</b> (const <a class="el" href="a04480.html">NonlinearFactorGraph</a> &amp;graph, const <a class="el" href="a04560.html">Values</a> &amp;config, const noiseModel::Diagonal::shared_ptr model, const std::string &amp;filename)</td></tr>
<tr class="memdesc:acfe516bc2d9ca4cc4530dd3b8460ce3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">save 2d graph <br /></td></tr>
<tr class="separator:acfe516bc2d9ca4cc4530dd3b8460ce3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d086efc70f4af31d3c3b00dde4f7c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01596.html#abcc5d1ec05ddc954d5de28929acabbdf">GraphAndValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a71d086efc70f4af31d3c3b00dde4f7c0">readG2o</a> (const std::string &amp;g2oFile, const bool is3D=false, <a class="el" href="a01596.html#a8be373f34edc0a9d28b1bfab5dd62ba0">KernelFunctionType</a> kernelFunctionType=KernelFunctionTypeNONE)</td></tr>
<tr class="memdesc:a71d086efc70f4af31d3c3b00dde4f7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function parses a g2o file and stores the measurements into a <a class="el" href="a04480.html" title="A non-linear factor graph is a graph of non-Gaussian, i.e.">NonlinearFactorGraph</a> and the initial guess in a <a class="el" href="a04560.html" title="A non-templated config holding any types of Manifold-group elements.">Values</a> structure.  <a href="a01596.html#a71d086efc70f4af31d3c3b00dde4f7c0">More...</a><br /></td></tr>
<tr class="separator:a71d086efc70f4af31d3c3b00dde4f7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bc584d72da3747666ac134a9490f92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a68bc584d72da3747666ac134a9490f92">writeG2o</a> (const <a class="el" href="a04480.html">NonlinearFactorGraph</a> &amp;graph, const <a class="el" href="a04560.html">Values</a> &amp;estimate, const std::string &amp;filename)</td></tr>
<tr class="memdesc:a68bc584d72da3747666ac134a9490f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes a g2o file from <a class="el" href="a04480.html" title="A non-linear factor graph is a graph of non-Gaussian, i.e.">NonlinearFactorGraph</a> and a <a class="el" href="a04560.html" title="A non-templated config holding any types of Manifold-group elements.">Values</a> structure.  <a href="a01596.html#a68bc584d72da3747666ac134a9490f92">More...</a><br /></td></tr>
<tr class="separator:a68bc584d72da3747666ac134a9490f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a75bf2429d5a10f8e9d083598f9c251"><td class="memItemLeft" align="right" valign="top"><a id="a7a75bf2429d5a10f8e9d083598f9c251" name="a7a75bf2429d5a10f8e9d083598f9c251"></a>
istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (istream &amp;is, Quaternion &amp;q)</td></tr>
<tr class="separator:a7a75bf2429d5a10f8e9d083598f9c251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a2e19a602fb4ad4f8458f6fe72fbcc"><td class="memItemLeft" align="right" valign="top"><a id="ad7a2e19a602fb4ad4f8458f6fe72fbcc" name="ad7a2e19a602fb4ad4f8458f6fe72fbcc"></a>
istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (istream &amp;is, <a class="el" href="a03336.html">Rot3</a> &amp;R)</td></tr>
<tr class="separator:ad7a2e19a602fb4ad4f8458f6fe72fbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c4a06300bf5ad83bcd0c82c4d670eb"><td class="memItemLeft" align="right" valign="top"><a id="a28c4a06300bf5ad83bcd0c82c4d670eb" name="a28c4a06300bf5ad83bcd0c82c4d670eb"></a>
boost::optional&lt; pair&lt; size_t, <a class="el" href="a03288.html">Pose3</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>parseVertexPose3</b> (istream &amp;is, const string &amp;tag)</td></tr>
<tr class="separator:a28c4a06300bf5ad83bcd0c82c4d670eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecf7c19b50c7783b814a5a3feb3a72c"><td class="memItemLeft" align="right" valign="top"><a id="adecf7c19b50c7783b814a5a3feb3a72c" name="adecf7c19b50c7783b814a5a3feb3a72c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:adecf7c19b50c7783b814a5a3feb3a72c"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; size_t, <a class="el" href="a03288.html">Pose3</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parseVariables&lt; Pose3 &gt;</b> (const std::string &amp;filename, size_t maxIndex)</td></tr>
<tr class="separator:adecf7c19b50c7783b814a5a3feb3a72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de0fbf6364c3934fc4afd0b0afa858c"><td class="memItemLeft" align="right" valign="top"><a id="a4de0fbf6364c3934fc4afd0b0afa858c" name="a4de0fbf6364c3934fc4afd0b0afa858c"></a>
boost::optional&lt; pair&lt; size_t, <a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>parseVertexPoint3</b> (istream &amp;is, const string &amp;tag)</td></tr>
<tr class="separator:a4de0fbf6364c3934fc4afd0b0afa858c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44932b0c82b50b67c2436e680ceea2f0"><td class="memItemLeft" align="right" valign="top"><a id="a44932b0c82b50b67c2436e680ceea2f0" name="a44932b0c82b50b67c2436e680ceea2f0"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a44932b0c82b50b67c2436e680ceea2f0"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; size_t, <a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parseVariables&lt; Point3 &gt;</b> (const std::string &amp;filename, size_t maxIndex)</td></tr>
<tr class="separator:a44932b0c82b50b67c2436e680ceea2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c8b3b55a130e4156fbfb0c5e21ea08"><td class="memItemLeft" align="right" valign="top"><a id="a44c8b3b55a130e4156fbfb0c5e21ea08" name="a44c8b3b55a130e4156fbfb0c5e21ea08"></a>
istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (istream &amp;is, Matrix6 &amp;m)</td></tr>
<tr class="separator:a44c8b3b55a130e4156fbfb0c5e21ea08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f84f0febd71ed8177541e6d9fa38e2"><td class="memItemLeft" align="right" valign="top"><a id="ad8f84f0febd71ed8177541e6d9fa38e2" name="ad8f84f0febd71ed8177541e6d9fa38e2"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad8f84f0febd71ed8177541e6d9fa38e2"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a04632.html">BinaryMeasurement</a>&lt; <a class="el" href="a03288.html">Pose3</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parseMeasurements</b> (const std::string &amp;filename, const noiseModel::Diagonal::shared_ptr &amp;model, size_t maxIndex)</td></tr>
<tr class="separator:ad8f84f0febd71ed8177541e6d9fa38e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b28d49f960263e1b917d6c728823f2"><td class="memItemLeft" align="right" valign="top"><a id="ae5b28d49f960263e1b917d6c728823f2" name="ae5b28d49f960263e1b917d6c728823f2"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae5b28d49f960263e1b917d6c728823f2"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a04632.html">BinaryMeasurement</a>&lt; <a class="el" href="a03336.html">Rot3</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parseMeasurements</b> (const std::string &amp;filename, const noiseModel::Diagonal::shared_ptr &amp;model, size_t maxIndex)</td></tr>
<tr class="separator:ae5b28d49f960263e1b917d6c728823f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7621e1421e7ed3df249277b95940d826"><td class="memItemLeft" align="right" valign="top"><a id="a7621e1421e7ed3df249277b95940d826" name="a7621e1421e7ed3df249277b95940d826"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7621e1421e7ed3df249277b95940d826"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a04684.html">BetweenFactor</a>&lt; <a class="el" href="a03288.html">Pose3</a> &gt;::shared_ptr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parseFactors&lt; Pose3 &gt;</b> (const std::string &amp;filename, const noiseModel::Diagonal::shared_ptr &amp;model, size_t maxIndex)</td></tr>
<tr class="separator:a7621e1421e7ed3df249277b95940d826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96511703a91071d7b2033976f9739c3"><td class="memItemLeft" align="right" valign="top"><a id="ac96511703a91071d7b2033976f9739c3" name="ac96511703a91071d7b2033976f9739c3"></a>
<a class="el" href="a01596.html#abcc5d1ec05ddc954d5de28929acabbdf">GraphAndValues</a>&#160;</td><td class="memItemRight" valign="bottom"><b>load3D</b> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:ac96511703a91071d7b2033976f9739c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load TORO 3D Graph. <br /></td></tr>
<tr class="separator:ac96511703a91071d7b2033976f9739c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7ce86bab3b1d18e912c7c61e0c8f02"><td class="memItemLeft" align="right" valign="top"><a id="a6e7ce86bab3b1d18e912c7c61e0c8f02" name="a6e7ce86bab3b1d18e912c7c61e0c8f02"></a>
<a class="el" href="a03336.html">Rot3</a>&#160;</td><td class="memItemRight" valign="bottom"><b>openGLFixedRotation</b> ()</td></tr>
<tr class="separator:a6e7ce86bab3b1d18e912c7c61e0c8f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6eca65dc0168a65f641961ca97924c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a03288.html">Pose3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#ade6eca65dc0168a65f641961ca97924c">openGL2gtsam</a> (const <a class="el" href="a03336.html">Rot3</a> &amp;R, double tx, double ty, double tz)</td></tr>
<tr class="memdesc:ade6eca65dc0168a65f641961ca97924c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts an openGL camera pose to an GTSAM camera pose.  <a href="a01596.html#ade6eca65dc0168a65f641961ca97924c">More...</a><br /></td></tr>
<tr class="separator:ade6eca65dc0168a65f641961ca97924c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff07ef70e6161c4d1d2bd7546ff91e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a03288.html">Pose3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#aaff07ef70e6161c4d1d2bd7546ff91e6">gtsam2openGL</a> (const <a class="el" href="a03336.html">Rot3</a> &amp;R, double tx, double ty, double tz)</td></tr>
<tr class="memdesc:aaff07ef70e6161c4d1d2bd7546ff91e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts a GTSAM camera pose to an openGL camera pose.  <a href="a01596.html#aaff07ef70e6161c4d1d2bd7546ff91e6">More...</a><br /></td></tr>
<tr class="separator:aaff07ef70e6161c4d1d2bd7546ff91e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad632ed56581bf174eef379bbe272a06a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a03288.html">Pose3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#ad632ed56581bf174eef379bbe272a06a">gtsam2openGL</a> (const <a class="el" href="a03288.html">Pose3</a> &amp;PoseGTSAM)</td></tr>
<tr class="memdesc:ad632ed56581bf174eef379bbe272a06a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts a GTSAM camera pose to an openGL camera pose.  <a href="a01596.html#ad632ed56581bf174eef379bbe272a06a">More...</a><br /></td></tr>
<tr class="separator:ad632ed56581bf174eef379bbe272a06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c2d071b98678ae281d0b48bee98b30"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a37c2d071b98678ae281d0b48bee98b30">readBundler</a> (const std::string &amp;filename, <a class="el" href="a04736.html">SfmData</a> &amp;data)</td></tr>
<tr class="memdesc:a37c2d071b98678ae281d0b48bee98b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function parses a bundler output file and stores the data into a <a class="el" href="a04736.html" title="Define the structure for SfM data.">SfmData</a> structure.  <a href="a01596.html#a37c2d071b98678ae281d0b48bee98b30">More...</a><br /></td></tr>
<tr class="separator:a37c2d071b98678ae281d0b48bee98b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af170fa38edc21cf9c26c2c6937388ec0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#af170fa38edc21cf9c26c2c6937388ec0">readBAL</a> (const std::string &amp;filename, <a class="el" href="a04736.html">SfmData</a> &amp;data)</td></tr>
<tr class="memdesc:af170fa38edc21cf9c26c2c6937388ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function parses a "Bundle Adjustment in the Large" (BAL) file and stores the data into a <a class="el" href="a04736.html" title="Define the structure for SfM data.">SfmData</a> structure.  <a href="a01596.html#af170fa38edc21cf9c26c2c6937388ec0">More...</a><br /></td></tr>
<tr class="separator:af170fa38edc21cf9c26c2c6937388ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710ec0322f4a2c0883841b58516b7a6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a04736.html">SfmData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a710ec0322f4a2c0883841b58516b7a6a">readBal</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a710ec0322f4a2c0883841b58516b7a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function parses a "Bundle Adjustment in the Large" (BAL) file and returns the data as a <a class="el" href="a04736.html" title="Define the structure for SfM data.">SfmData</a> structure.  <a href="a01596.html#a710ec0322f4a2c0883841b58516b7a6a">More...</a><br /></td></tr>
<tr class="separator:a710ec0322f4a2c0883841b58516b7a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6d4511beb8fd046f0d9f430d17d396"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#aea6d4511beb8fd046f0d9f430d17d396">writeBAL</a> (const std::string &amp;filename, <a class="el" href="a04736.html">SfmData</a> &amp;data)</td></tr>
<tr class="memdesc:aea6d4511beb8fd046f0d9f430d17d396"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes a "Bundle Adjustment in the Large" (BAL) file from a <a class="el" href="a04736.html" title="Define the structure for SfM data.">SfmData</a> structure.  <a href="a01596.html#aea6d4511beb8fd046f0d9f430d17d396">More...</a><br /></td></tr>
<tr class="separator:aea6d4511beb8fd046f0d9f430d17d396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a14a1609cd7dd26106cca1345ec958"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a71a14a1609cd7dd26106cca1345ec958">writeBALfromValues</a> (const std::string &amp;filename, const <a class="el" href="a04736.html">SfmData</a> &amp;data, <a class="el" href="a04560.html">Values</a> &amp;values)</td></tr>
<tr class="memdesc:a71a14a1609cd7dd26106cca1345ec958"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes a "Bundle Adjustment in the Large" (BAL) file from a <a class="el" href="a04736.html" title="Define the structure for SfM data.">SfmData</a> structure and a value structure (measurements are the same as the SfM input data, while camera poses and values are read from <a class="el" href="a04560.html" title="A non-templated config holding any types of Manifold-group elements.">Values</a>)  <a href="a01596.html#a71a14a1609cd7dd26106cca1345ec958">More...</a><br /></td></tr>
<tr class="separator:a71a14a1609cd7dd26106cca1345ec958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b55993353cbab0fde06b872783fe92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a04560.html">Values</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#ad8b55993353cbab0fde06b872783fe92">initialCamerasEstimate</a> (const <a class="el" href="a04736.html">SfmData</a> &amp;db)</td></tr>
<tr class="memdesc:ad8b55993353cbab0fde06b872783fe92"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates initial values for cameras from db.  <a href="a01596.html#ad8b55993353cbab0fde06b872783fe92">More...</a><br /></td></tr>
<tr class="separator:ad8b55993353cbab0fde06b872783fe92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba34ed4a103d9057536ee5cac27cfdef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a04560.html">Values</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#aba34ed4a103d9057536ee5cac27cfdef">initialCamerasAndPointsEstimate</a> (const <a class="el" href="a04736.html">SfmData</a> &amp;db)</td></tr>
<tr class="memdesc:aba34ed4a103d9057536ee5cac27cfdef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates initial values for cameras and points from db.  <a href="a01596.html#aba34ed4a103d9057536ee5cac27cfdef">More...</a><br /></td></tr>
<tr class="separator:aba34ed4a103d9057536ee5cac27cfdef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47e1c5b64fcd59a58c53ab54e5e2bbb"><td class="memItemLeft" align="right" valign="top"><a id="af47e1c5b64fcd59a58c53ab54e5e2bbb" name="af47e1c5b64fcd59a58c53ab54e5e2bbb"></a>
BetweenFactorPose2s&#160;</td><td class="memItemRight" valign="bottom"><b>parse2DFactors</b> (const std::string &amp;filename, const noiseModel::Diagonal::shared_ptr &amp;model, size_t maxIndex)</td></tr>
<tr class="separator:af47e1c5b64fcd59a58c53ab54e5e2bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c044931f2e01bfbe53b558060a4acca"><td class="memItemLeft" align="right" valign="top"><a id="a2c044931f2e01bfbe53b558060a4acca" name="a2c044931f2e01bfbe53b558060a4acca"></a>
BetweenFactorPose3s&#160;</td><td class="memItemRight" valign="bottom"><b>parse3DFactors</b> (const std::string &amp;filename, const noiseModel::Diagonal::shared_ptr &amp;model, size_t maxIndex)</td></tr>
<tr class="separator:a2c044931f2e01bfbe53b558060a4acca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683ab6a83b5b3e508e734a7089986838"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a683ab6a83b5b3e508e734a7089986838"><td class="memTemplItemLeft" align="right" valign="top">GTSAM_EXPORT std::map&lt; size_t, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a683ab6a83b5b3e508e734a7089986838">parseVariables</a> (const std::string &amp;filename, size_t maxIndex=0)</td></tr>
<tr class="memdesc:a683ab6a83b5b3e508e734a7089986838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse variables in a line-based text format (like g2o) into a map.  <a href="a01596.html#a683ab6a83b5b3e508e734a7089986838">More...</a><br /></td></tr>
<tr class="separator:a683ab6a83b5b3e508e734a7089986838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb4817b97658f00e426b753c52361ed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6eb4817b97658f00e426b753c52361ed"><td class="memTemplItemLeft" align="right" valign="top">GTSAM_EXPORT std::vector&lt; <a class="el" href="a04632.html">BinaryMeasurement</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a6eb4817b97658f00e426b753c52361ed">parseMeasurements</a> (const std::string &amp;filename, const noiseModel::Diagonal::shared_ptr &amp;model=nullptr, size_t maxIndex=0)</td></tr>
<tr class="memdesc:a6eb4817b97658f00e426b753c52361ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse binary measurements in a line-based text format (like g2o) into a vector.  <a href="a01596.html#a6eb4817b97658f00e426b753c52361ed">More...</a><br /></td></tr>
<tr class="separator:a6eb4817b97658f00e426b753c52361ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2136a163e31faaefe2db498a9b9b43"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a2136a163e31faaefe2db498a9b9b43"><td class="memTemplItemLeft" align="right" valign="top">GTSAM_EXPORT std::vector&lt; typename <a class="el" href="a04684.html">BetweenFactor</a>&lt; T &gt;::shared_ptr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a8a2136a163e31faaefe2db498a9b9b43">parseFactors</a> (const std::string &amp;filename, const noiseModel::Diagonal::shared_ptr &amp;model=nullptr, size_t maxIndex=0)</td></tr>
<tr class="memdesc:a8a2136a163e31faaefe2db498a9b9b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse BetweenFactors in a line-based text format (like g2o) into a vector of shared pointers.  <a href="a01596.html#a8a2136a163e31faaefe2db498a9b9b43">More...</a><br /></td></tr>
<tr class="separator:a8a2136a163e31faaefe2db498a9b9b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8d49b13ccc0e007a5e7572286d5854"><td class="memItemLeft" align="right" valign="top">GTSAM_EXPORT <a class="el" href="a01596.html#abcc5d1ec05ddc954d5de28929acabbdf">GraphAndValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a6f8d49b13ccc0e007a5e7572286d5854">load2D</a> (std::pair&lt; std::string, <a class="el" href="a01596.html#ab6e5a4884342656e0837ef07008ec03f">SharedNoiseModel</a> &gt; dataset, size_t maxIndex=0, bool addNoise=false, bool smart=true, <a class="el" href="a01596.html#a90552b70a2da9c74595cae4b05c2ce18">NoiseFormat</a> noiseFormat=<a class="el" href="a01596.html#a90552b70a2da9c74595cae4b05c2ce18a2f9067b8f5bd2d0dd38c49326a4c070e">NoiseFormatAUTO</a>, <a class="el" href="a01596.html#a8be373f34edc0a9d28b1bfab5dd62ba0">KernelFunctionType</a> kernelFunctionType=KernelFunctionTypeNONE)</td></tr>
<tr class="memdesc:a6f8d49b13ccc0e007a5e7572286d5854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load TORO 2D Graph.  <a href="a01596.html#a6f8d49b13ccc0e007a5e7572286d5854">More...</a><br /></td></tr>
<tr class="separator:a6f8d49b13ccc0e007a5e7572286d5854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276c80b1ec28143983d2fad31027e04d"><td class="memItemLeft" align="right" valign="top"><a id="a276c80b1ec28143983d2fad31027e04d" name="a276c80b1ec28143983d2fad31027e04d"></a>
<a class="el" href="a04240.html">Point2_</a>&#160;</td><td class="memItemRight" valign="bottom"><b>transformTo</b> (const <a class="el" href="a04240.html">Pose2_</a> &amp;x, const <a class="el" href="a04240.html">Point2_</a> &amp;p)</td></tr>
<tr class="separator:a276c80b1ec28143983d2fad31027e04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79776fe9ae8521cd5f1664c5883e370"><td class="memItemLeft" align="right" valign="top"><a id="af79776fe9ae8521cd5f1664c5883e370" name="af79776fe9ae8521cd5f1664c5883e370"></a>
<a class="el" href="a04240.html">Point3_</a>&#160;</td><td class="memItemRight" valign="bottom"><b>transformTo</b> (const <a class="el" href="a04240.html">Pose3_</a> &amp;x, const <a class="el" href="a04240.html">Point3_</a> &amp;p)</td></tr>
<tr class="separator:af79776fe9ae8521cd5f1664c5883e370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cca0fed5cba32e15f07f9ab3b689613"><td class="memItemLeft" align="right" valign="top"><a id="a8cca0fed5cba32e15f07f9ab3b689613" name="a8cca0fed5cba32e15f07f9ab3b689613"></a>
<a class="el" href="a04240.html">Point3_</a>&#160;</td><td class="memItemRight" valign="bottom"><b>transformFrom</b> (const <a class="el" href="a04240.html">Pose3_</a> &amp;x, const <a class="el" href="a04240.html">Point3_</a> &amp;p)</td></tr>
<tr class="separator:a8cca0fed5cba32e15f07f9ab3b689613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3635034b6c11f0974357275cc53563"><td class="memItemLeft" align="right" valign="top"><a id="aed3635034b6c11f0974357275cc53563" name="aed3635034b6c11f0974357275cc53563"></a>
<a class="el" href="a04240.html">Line3_</a>&#160;</td><td class="memItemRight" valign="bottom"><b>transformTo</b> (const <a class="el" href="a04240.html">Pose3_</a> &amp;wTc, const <a class="el" href="a04240.html">Line3_</a> &amp;wL)</td></tr>
<tr class="separator:aed3635034b6c11f0974357275cc53563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d65cff8a7ca6b614e5012f7fec79ad0"><td class="memItemLeft" align="right" valign="top"><a id="a9d65cff8a7ca6b614e5012f7fec79ad0" name="a9d65cff8a7ca6b614e5012f7fec79ad0"></a>
<a class="el" href="a04240.html">Point3_</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cross</b> (const <a class="el" href="a04240.html">Point3_</a> &amp;a, const <a class="el" href="a04240.html">Point3_</a> &amp;b)</td></tr>
<tr class="separator:a9d65cff8a7ca6b614e5012f7fec79ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d25ff1f0fd78c28e1fc43a9da90c5a0"><td class="memItemLeft" align="right" valign="top"><a id="a2d25ff1f0fd78c28e1fc43a9da90c5a0" name="a2d25ff1f0fd78c28e1fc43a9da90c5a0"></a>
<a class="el" href="a04240.html">Double_</a>&#160;</td><td class="memItemRight" valign="bottom"><b>dot</b> (const <a class="el" href="a04240.html">Point3_</a> &amp;a, const <a class="el" href="a04240.html">Point3_</a> &amp;b)</td></tr>
<tr class="separator:a2d25ff1f0fd78c28e1fc43a9da90c5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46adf56065b0dd404831df11e8b6da9a"><td class="memItemLeft" align="right" valign="top"><a id="a46adf56065b0dd404831df11e8b6da9a" name="a46adf56065b0dd404831df11e8b6da9a"></a>
<a class="el" href="a04240.html">Rot3_</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rotation</b> (const <a class="el" href="a04240.html">Pose3_</a> &amp;pose)</td></tr>
<tr class="separator:a46adf56065b0dd404831df11e8b6da9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf045e8a920b6a7000e2560ea491f588"><td class="memItemLeft" align="right" valign="top"><a id="abf045e8a920b6a7000e2560ea491f588" name="abf045e8a920b6a7000e2560ea491f588"></a>
<a class="el" href="a04240.html">Point3_</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rotate</b> (const <a class="el" href="a04240.html">Rot3_</a> &amp;x, const <a class="el" href="a04240.html">Point3_</a> &amp;p)</td></tr>
<tr class="separator:abf045e8a920b6a7000e2560ea491f588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba63d1d99fca5f82677c97bb72e3f90"><td class="memItemLeft" align="right" valign="top"><a id="adba63d1d99fca5f82677c97bb72e3f90" name="adba63d1d99fca5f82677c97bb72e3f90"></a>
<a class="el" href="a04240.html">Unit3_</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rotate</b> (const <a class="el" href="a04240.html">Rot3_</a> &amp;x, const <a class="el" href="a04240.html">Unit3_</a> &amp;p)</td></tr>
<tr class="separator:adba63d1d99fca5f82677c97bb72e3f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b20e8c13e40d0c34cb05d3e1eb1a4c0"><td class="memItemLeft" align="right" valign="top"><a id="a6b20e8c13e40d0c34cb05d3e1eb1a4c0" name="a6b20e8c13e40d0c34cb05d3e1eb1a4c0"></a>
<a class="el" href="a04240.html">Point3_</a>&#160;</td><td class="memItemRight" valign="bottom"><b>unrotate</b> (const <a class="el" href="a04240.html">Rot3_</a> &amp;x, const <a class="el" href="a04240.html">Point3_</a> &amp;p)</td></tr>
<tr class="separator:a6b20e8c13e40d0c34cb05d3e1eb1a4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c13441b5b57ebc76c81981db8b6a82"><td class="memItemLeft" align="right" valign="top"><a id="a25c13441b5b57ebc76c81981db8b6a82" name="a25c13441b5b57ebc76c81981db8b6a82"></a>
<a class="el" href="a04240.html">Unit3_</a>&#160;</td><td class="memItemRight" valign="bottom"><b>unrotate</b> (const <a class="el" href="a04240.html">Rot3_</a> &amp;x, const <a class="el" href="a04240.html">Unit3_</a> &amp;p)</td></tr>
<tr class="separator:a25c13441b5b57ebc76c81981db8b6a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0024081af88e1b3cc0820c65ad6afd4"><td class="memItemLeft" align="right" valign="top"><a id="ad0024081af88e1b3cc0820c65ad6afd4" name="ad0024081af88e1b3cc0820c65ad6afd4"></a>
<a class="el" href="a04240.html">Point2_</a>&#160;</td><td class="memItemRight" valign="bottom"><b>project</b> (const <a class="el" href="a04240.html">Point3_</a> &amp;p_cam)</td></tr>
<tr class="memdesc:ad0024081af88e1b3cc0820c65ad6afd4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a04240.html" title="Expression class that supports automatic differentiation.">Expression</a> version of <a class="el" href="a03132.html#a1f8c70f7b2535d87c175fa62be7df074" title="Project from 3D point in camera coordinates into image Does not throw a CheiralityException,...">PinholeBase::Project</a>. <br /></td></tr>
<tr class="separator:ad0024081af88e1b3cc0820c65ad6afd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c19ca65c3e7185af5c613b2c60c12a2"><td class="memItemLeft" align="right" valign="top"><a id="a6c19ca65c3e7185af5c613b2c60c12a2" name="a6c19ca65c3e7185af5c613b2c60c12a2"></a>
<a class="el" href="a04240.html">Point2_</a>&#160;</td><td class="memItemRight" valign="bottom"><b>project</b> (const <a class="el" href="a04240.html">Unit3_</a> &amp;p_cam)</td></tr>
<tr class="separator:a6c19ca65c3e7185af5c613b2c60c12a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4bc67d7efc2c9bee09dab4104e18d3"><td class="memTemplParams" colspan="2"><a id="a4e4bc67d7efc2c9bee09dab4104e18d3" name="a4e4bc67d7efc2c9bee09dab4104e18d3"></a>
template&lt;class CAMERA , class POINT &gt; </td></tr>
<tr class="memitem:a4e4bc67d7efc2c9bee09dab4104e18d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a04240.html">Point2_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>project2</b> (const <a class="el" href="a04240.html">Expression</a>&lt; CAMERA &gt; &amp;camera_, const <a class="el" href="a04240.html">Expression</a>&lt; POINT &gt; &amp;p_)</td></tr>
<tr class="separator:a4e4bc67d7efc2c9bee09dab4104e18d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676b20d9cd98f2f0931a6ab68e7b68d3"><td class="memTemplParams" colspan="2"><a id="a676b20d9cd98f2f0931a6ab68e7b68d3" name="a676b20d9cd98f2f0931a6ab68e7b68d3"></a>
template&lt;class CALIBRATION , class POINT &gt; </td></tr>
<tr class="memitem:a676b20d9cd98f2f0931a6ab68e7b68d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a04240.html">Point2_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>project3</b> (const <a class="el" href="a04240.html">Pose3_</a> &amp;x, const <a class="el" href="a04240.html">Expression</a>&lt; POINT &gt; &amp;p, const <a class="el" href="a04240.html">Expression</a>&lt; CALIBRATION &gt; &amp;K)</td></tr>
<tr class="separator:a676b20d9cd98f2f0931a6ab68e7b68d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264b3896f0d66970fe7ef7eee3b4d66b"><td class="memTemplParams" colspan="2"><a id="a264b3896f0d66970fe7ef7eee3b4d66b" name="a264b3896f0d66970fe7ef7eee3b4d66b"></a>
template&lt;class CALIBRATION &gt; </td></tr>
<tr class="memitem:a264b3896f0d66970fe7ef7eee3b4d66b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a04240.html">Point2_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>uncalibrate</b> (const <a class="el" href="a04240.html">Expression</a>&lt; CALIBRATION &gt; &amp;K, const <a class="el" href="a04240.html">Point2_</a> &amp;xy_hat)</td></tr>
<tr class="separator:a264b3896f0d66970fe7ef7eee3b4d66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af6e019faaedfddc234925b2e50ad2b"><td class="memTemplParams" colspan="2"><a id="a1af6e019faaedfddc234925b2e50ad2b" name="a1af6e019faaedfddc234925b2e50ad2b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1af6e019faaedfddc234925b2e50ad2b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a04240.html">gtsam::Expression</a>&lt; typename <a class="el" href="a02444.html">gtsam::traits</a>&lt; T &gt;::TangentVector &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>logmap</b> (const <a class="el" href="a04240.html">gtsam::Expression</a>&lt; T &gt; &amp;x1, const <a class="el" href="a04240.html">gtsam::Expression</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="memdesc:a1af6e019faaedfddc234925b2e50ad2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">logmap <br /></td></tr>
<tr class="separator:a1af6e019faaedfddc234925b2e50ad2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43e7fd7c2b86873458a91ddafc506e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01596.html#ab6e5a4884342656e0837ef07008ec03f">SharedNoiseModel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#aa43e7fd7c2b86873458a91ddafc506e4">ConvertNoiseModel</a> (const <a class="el" href="a01596.html#ab6e5a4884342656e0837ef07008ec03f">SharedNoiseModel</a> &amp;model, size_t n, bool defaultToUnit=true)</td></tr>
<tr class="memdesc:aa43e7fd7c2b86873458a91ddafc506e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">When creating (any) <a class="el" href="a04768.html" title="FrobeniusFactor calculates the Frobenius norm between rotation matrices.">FrobeniusFactor</a> we can convert a Rot/Pose <a class="el" href="a04684.html">BetweenFactor</a> noise model into a n-dimensional isotropic noise model used to weight the Frobenius norm.  <a href="a01596.html#aa43e7fd7c2b86873458a91ddafc506e4">More...</a><br /></td></tr>
<tr class="separator:aa43e7fd7c2b86873458a91ddafc506e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79840dc5c03098113b9d68a7cda8b1ca"><td class="memTemplParams" colspan="2"><a id="a79840dc5c03098113b9d68a7cda8b1ca" name="a79840dc5c03098113b9d68a7cda8b1ca"></a>
template&lt;class T , class ALLOC &gt; </td></tr>
<tr class="memitem:a79840dc5c03098113b9d68a7cda8b1ca"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FindKarcherMeanImpl</b> (const vector&lt; T, ALLOC &gt; &amp;rotations)</td></tr>
<tr class="separator:a79840dc5c03098113b9d68a7cda8b1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad055d8f740e8411469cfccf8cd242a6b"><td class="memTemplParams" colspan="2"><a id="ad055d8f740e8411469cfccf8cd242a6b" name="ad055d8f740e8411469cfccf8cd242a6b"></a>
template&lt;class T , typename  = typename std::enable_if&lt; std::is_same&lt;gtsam::Rot3, T&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:ad055d8f740e8411469cfccf8cd242a6b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FindKarcherMean</b> (const std::vector&lt; T &gt; &amp;rotations)</td></tr>
<tr class="separator:ad055d8f740e8411469cfccf8cd242a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fa43a05d8b4a5504e79d7fae639b9b"><td class="memTemplParams" colspan="2"><a id="ad7fa43a05d8b4a5504e79d7fae639b9b" name="ad7fa43a05d8b4a5504e79d7fae639b9b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad7fa43a05d8b4a5504e79d7fae639b9b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FindKarcherMean</b> (const std::vector&lt; T, Eigen::aligned_allocator&lt; T &gt; &gt; &amp;rotations)</td></tr>
<tr class="memdesc:ad7fa43a05d8b4a5504e79d7fae639b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize for the Karcher mean, minimizing the geodesic distance to each of the given rotations, by constructing a factor graph out of simple PriorFactors. <br /></td></tr>
<tr class="separator:ad7fa43a05d8b4a5504e79d7fae639b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2628c512344b14db4bb1551caccc94"><td class="memTemplParams" colspan="2"><a id="a3c2628c512344b14db4bb1551caccc94" name="a3c2628c512344b14db4bb1551caccc94"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3c2628c512344b14db4bb1551caccc94"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FindKarcherMean</b> (std::initializer_list&lt; T &gt; &amp;&amp;rotations)</td></tr>
<tr class="separator:a3c2628c512344b14db4bb1551caccc94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d640f59e5d39a1165069a3841cc5d1"><td class="memTemplParams" colspan="2">template&lt;class T , class P &gt; </td></tr>
<tr class="memitem:a80d640f59e5d39a1165069a3841cc5d1"><td class="memTemplItemLeft" align="right" valign="top">P&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a80d640f59e5d39a1165069a3841cc5d1">transform_point</a> (const T &amp;<a class="el" href="a01596.html#aa2e36d7ab63000feddaeb61bbfcf2db1">trans</a>, const P &amp;global, boost::optional&lt; Matrix &amp; &gt; Dtrans, boost::optional&lt; Matrix &amp; &gt; Dglobal)</td></tr>
<tr class="memdesc:a80d640f59e5d39a1165069a3841cc5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform function that must be specialized specific domains.  <a href="a01596.html#a80d640f59e5d39a1165069a3841cc5d1">More...</a><br /></td></tr>
<tr class="separator:a80d640f59e5d39a1165069a3841cc5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659f20993995258b1405737e375efd10"><td class="memItemLeft" align="right" valign="top">std::pair&lt; boost::shared_ptr&lt; <a class="el" href="a04932.html">SymbolicConditional</a> &gt;, boost::shared_ptr&lt; <a class="el" href="a04948.html">SymbolicFactor</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01596.html#a659f20993995258b1405737e375efd10">EliminateSymbolic</a> (const <a class="el" href="a04960.html">SymbolicFactorGraph</a> &amp;factors, const <a class="el" href="a03632.html">Ordering</a> &amp;keys)</td></tr>
<tr class="memdesc:a659f20993995258b1405737e375efd10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense elimination function for symbolic factors.  <a href="a01596.html#a659f20993995258b1405737e375efd10">More...</a><br /></td></tr>
<tr class="separator:a659f20993995258b1405737e375efd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be309f741b77e5406429e41f666aa5a"><td class="memTemplParams" colspan="2">template&lt;class PROBLEM &gt; </td></tr>
<tr class="memitem:a9be309f741b77e5406429e41f666aa5a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a9be309f741b77e5406429e41f666aa5a">maxKey</a> (const PROBLEM &amp;problem)</td></tr>
<tr class="memdesc:a9be309f741b77e5406429e41f666aa5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the max key in a problem.  <a href="a01596.html#a9be309f741b77e5406429e41f666aa5a">More...</a><br /></td></tr>
<tr class="separator:a9be309f741b77e5406429e41f666aa5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1c3505336642a14ef72e3d9187d918"><td class="memTemplParams" colspan="2"><a id="aff1c3505336642a14ef72e3d9187d918" name="aff1c3505336642a14ef72e3d9187d918"></a>
template&lt;class LinearGraph &gt; </td></tr>
<tr class="memitem:aff1c3505336642a14ef72e3d9187d918"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01596.html#a56e7423b122a2ac2a9ba1a07546516a5">KeyDimMap</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>collectKeyDim</b> (const LinearGraph &amp;linearGraph)</td></tr>
<tr class="separator:aff1c3505336642a14ef72e3d9187d918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be3fed4ef4188156a49c5fa0525487e"><td class="memItemLeft" align="right" valign="top"><a id="a8be3fed4ef4188156a49c5fa0525487e" name="a8be3fed4ef4188156a49c5fa0525487e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>synchronize</b> (<a class="el" href="a05160.html">ConcurrentFilter</a> &amp;filter, <a class="el" href="a05164.html">ConcurrentSmoother</a> &amp;smoother)</td></tr>
<tr class="separator:a8be3fed4ef4188156a49c5fa0525487e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6048a17810a0646ca0020bee393021f0"><td class="memItemLeft" align="right" valign="top"><a id="a6048a17810a0646ca0020bee393021f0" name="a6048a17810a0646ca0020bee393021f0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>recursiveMarkAffectedKeys</b> (const <a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a> &amp;key, const ISAM2Clique::shared_ptr &amp;clique, std::set&lt; <a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a> &gt; &amp;additionalKeys)</td></tr>
<tr class="separator:a6048a17810a0646ca0020bee393021f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0241b0d9d3b7b4ca3000ff59f8b13319"><td class="memItemLeft" align="right" valign="top"><a id="a0241b0d9d3b7b4ca3000ff59f8b13319" name="a0241b0d9d3b7b4ca3000ff59f8b13319"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>serializeGraph</b> (const <a class="el" href="a04480.html">NonlinearFactorGraph</a> &amp;graph)</td></tr>
<tr class="separator:a0241b0d9d3b7b4ca3000ff59f8b13319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddb6380c5179469bf6f7f81f4110cde"><td class="memItemLeft" align="right" valign="top"><a id="a9ddb6380c5179469bf6f7f81f4110cde" name="a9ddb6380c5179469bf6f7f81f4110cde"></a>
NonlinearFactorGraph::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>deserializeGraph</b> (const std::string &amp;serialized_graph)</td></tr>
<tr class="separator:a9ddb6380c5179469bf6f7f81f4110cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa95ece4b584014e906d281cdfc961b"><td class="memItemLeft" align="right" valign="top"><a id="a1fa95ece4b584014e906d281cdfc961b" name="a1fa95ece4b584014e906d281cdfc961b"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>serializeGraphXML</b> (const <a class="el" href="a04480.html">NonlinearFactorGraph</a> &amp;graph, const std::string &amp;name=&quot;graph&quot;)</td></tr>
<tr class="separator:a1fa95ece4b584014e906d281cdfc961b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6bcf6382d6e5c49bc08953f06bfddb"><td class="memItemLeft" align="right" valign="top"><a id="a9a6bcf6382d6e5c49bc08953f06bfddb" name="a9a6bcf6382d6e5c49bc08953f06bfddb"></a>
NonlinearFactorGraph::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>deserializeGraphXML</b> (const std::string &amp;serialized_graph, const std::string &amp;name=&quot;graph&quot;)</td></tr>
<tr class="separator:a9a6bcf6382d6e5c49bc08953f06bfddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1739413606cab6841db33bbe0be327e"><td class="memItemLeft" align="right" valign="top"><a id="ae1739413606cab6841db33bbe0be327e" name="ae1739413606cab6841db33bbe0be327e"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>serializeValues</b> (const <a class="el" href="a04560.html">Values</a> &amp;values)</td></tr>
<tr class="separator:ae1739413606cab6841db33bbe0be327e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020e475d33dd1a8d0a758f54e702617f"><td class="memItemLeft" align="right" valign="top"><a id="a020e475d33dd1a8d0a758f54e702617f" name="a020e475d33dd1a8d0a758f54e702617f"></a>
<a class="el" href="a04560.html#a5b2f07b6054d9ea06b28876a057938d1">Values::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>deserializeValues</b> (const std::string &amp;serialized_values)</td></tr>
<tr class="separator:a020e475d33dd1a8d0a758f54e702617f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7943c86d6c78d2d7fe32ca720ce72f76"><td class="memItemLeft" align="right" valign="top"><a id="a7943c86d6c78d2d7fe32ca720ce72f76" name="a7943c86d6c78d2d7fe32ca720ce72f76"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>serializeValuesXML</b> (const <a class="el" href="a04560.html">Values</a> &amp;values, const std::string &amp;name=&quot;values&quot;)</td></tr>
<tr class="separator:a7943c86d6c78d2d7fe32ca720ce72f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf8119841c07ae949a6c1f95b352421"><td class="memItemLeft" align="right" valign="top"><a id="acbf8119841c07ae949a6c1f95b352421" name="acbf8119841c07ae949a6c1f95b352421"></a>
<a class="el" href="a04560.html#a5b2f07b6054d9ea06b28876a057938d1">Values::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>deserializeValuesXML</b> (const std::string &amp;serialized_values, const std::string &amp;name=&quot;values&quot;)</td></tr>
<tr class="separator:acbf8119841c07ae949a6c1f95b352421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eaad05a0c7085834101f0f266467f90"><td class="memItemLeft" align="right" valign="top"><a id="a2eaad05a0c7085834101f0f266467f90" name="a2eaad05a0c7085834101f0f266467f90"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>serializeGraphToFile</b> (const <a class="el" href="a04480.html">NonlinearFactorGraph</a> &amp;graph, const std::string &amp;fname)</td></tr>
<tr class="separator:a2eaad05a0c7085834101f0f266467f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e32bc8adad128856f13b720e2e039c8"><td class="memItemLeft" align="right" valign="top"><a id="a5e32bc8adad128856f13b720e2e039c8" name="a5e32bc8adad128856f13b720e2e039c8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>serializeGraphToXMLFile</b> (const <a class="el" href="a04480.html">NonlinearFactorGraph</a> &amp;graph, const std::string &amp;fname, const std::string &amp;name=&quot;graph&quot;)</td></tr>
<tr class="separator:a5e32bc8adad128856f13b720e2e039c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad71dc6650b070b775eb06bf2397de8bf"><td class="memItemLeft" align="right" valign="top"><a id="ad71dc6650b070b775eb06bf2397de8bf" name="ad71dc6650b070b775eb06bf2397de8bf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>serializeValuesToFile</b> (const <a class="el" href="a04560.html">Values</a> &amp;values, const std::string &amp;fname)</td></tr>
<tr class="separator:ad71dc6650b070b775eb06bf2397de8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac515f6d0baf5a916815c03364105edd0"><td class="memItemLeft" align="right" valign="top"><a id="ac515f6d0baf5a916815c03364105edd0" name="ac515f6d0baf5a916815c03364105edd0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>serializeValuesToXMLFile</b> (const <a class="el" href="a04560.html">Values</a> &amp;values, const std::string &amp;fname, const std::string &amp;name=&quot;values&quot;)</td></tr>
<tr class="separator:ac515f6d0baf5a916815c03364105edd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b948254951cd6c18af87ad9925db9b"><td class="memItemLeft" align="right" valign="top"><a id="ab6b948254951cd6c18af87ad9925db9b" name="ab6b948254951cd6c18af87ad9925db9b"></a>
NonlinearFactorGraph::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>deserializeGraphFromFile</b> (const std::string &amp;fname)</td></tr>
<tr class="separator:ab6b948254951cd6c18af87ad9925db9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e120487b3bc94b3f2a4b1e10737ba3"><td class="memItemLeft" align="right" valign="top"><a id="a87e120487b3bc94b3f2a4b1e10737ba3" name="a87e120487b3bc94b3f2a4b1e10737ba3"></a>
NonlinearFactorGraph::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>deserializeGraphFromXMLFile</b> (const std::string &amp;fname, const std::string &amp;name=&quot;graph&quot;)</td></tr>
<tr class="separator:a87e120487b3bc94b3f2a4b1e10737ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8eedc91689948b52e31db3433f8bf9e"><td class="memItemLeft" align="right" valign="top"><a id="ae8eedc91689948b52e31db3433f8bf9e" name="ae8eedc91689948b52e31db3433f8bf9e"></a>
<a class="el" href="a04560.html#a5b2f07b6054d9ea06b28876a057938d1">Values::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>deserializeValuesFromFile</b> (const std::string &amp;fname)</td></tr>
<tr class="separator:ae8eedc91689948b52e31db3433f8bf9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72cb4eef08e0078a9d9d7a2401d5ac09"><td class="memItemLeft" align="right" valign="top"><a id="a72cb4eef08e0078a9d9d7a2401d5ac09" name="a72cb4eef08e0078a9d9d7a2401d5ac09"></a>
<a class="el" href="a04560.html#a5b2f07b6054d9ea06b28876a057938d1">Values::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>deserializeValuesFromXMLFile</b> (const std::string &amp;fname, const std::string &amp;name=&quot;values&quot;)</td></tr>
<tr class="separator:a72cb4eef08e0078a9d9d7a2401d5ac09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3893277d250edd92b03ac9f3cdc0384c"><td class="memItemLeft" align="right" valign="top"><a id="a3893277d250edd92b03ac9f3cdc0384c" name="a3893277d250edd92b03ac9f3cdc0384c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>bound</b> (double a, double min, double max)</td></tr>
<tr class="separator:a3893277d250edd92b03ac9f3cdc0384c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Standard serialization</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Serialization in default compressed format </p>
</div></td></tr>
<tr class="memitem:a007080ca4741cc3d3d6a209b0ae3fe61"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a007080ca4741cc3d3d6a209b0ae3fe61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#a007080ca4741cc3d3d6a209b0ae3fe61">serializeToStream</a> (const T &amp;input, std::ostream &amp;out_archive_stream)</td></tr>
<tr class="separator:a007080ca4741cc3d3d6a209b0ae3fe61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab181d2a3de466fc0c87bd29501bbc7ab"><td class="memTemplParams" colspan="2"><a id="ab181d2a3de466fc0c87bd29501bbc7ab" name="ab181d2a3de466fc0c87bd29501bbc7ab"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab181d2a3de466fc0c87bd29501bbc7ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserializeFromStream</b> (std::istream &amp;in_archive_stream, T &amp;output)</td></tr>
<tr class="memdesc:ab181d2a3de466fc0c87bd29501bbc7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserializes from a stream <br /></td></tr>
<tr class="separator:ab181d2a3de466fc0c87bd29501bbc7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12c78301a9d2968afe5a1a14baa7e90"><td class="memTemplParams" colspan="2"><a id="aa12c78301a9d2968afe5a1a14baa7e90" name="aa12c78301a9d2968afe5a1a14baa7e90"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa12c78301a9d2968afe5a1a14baa7e90"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serializeToString</b> (const T &amp;input)</td></tr>
<tr class="memdesc:aa12c78301a9d2968afe5a1a14baa7e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">serializes to a string <br /></td></tr>
<tr class="separator:aa12c78301a9d2968afe5a1a14baa7e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262487af458d1f48dd7d3bc549caae00"><td class="memTemplParams" colspan="2"><a id="a262487af458d1f48dd7d3bc549caae00" name="a262487af458d1f48dd7d3bc549caae00"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a262487af458d1f48dd7d3bc549caae00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserializeFromString</b> (const std::string &amp;serialized, T &amp;output)</td></tr>
<tr class="memdesc:a262487af458d1f48dd7d3bc549caae00"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserializes from a string <br /></td></tr>
<tr class="separator:a262487af458d1f48dd7d3bc549caae00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3261c2d455f892dae1921f8c3a39267"><td class="memTemplParams" colspan="2"><a id="aa3261c2d455f892dae1921f8c3a39267" name="aa3261c2d455f892dae1921f8c3a39267"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa3261c2d455f892dae1921f8c3a39267"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serializeToFile</b> (const T &amp;input, const std::string &amp;filename)</td></tr>
<tr class="memdesc:aa3261c2d455f892dae1921f8c3a39267"><td class="mdescLeft">&#160;</td><td class="mdescRight">serializes to a file <br /></td></tr>
<tr class="separator:aa3261c2d455f892dae1921f8c3a39267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb4a71187706918faca3a11519b62f6"><td class="memTemplParams" colspan="2"><a id="adbb4a71187706918faca3a11519b62f6" name="adbb4a71187706918faca3a11519b62f6"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:adbb4a71187706918faca3a11519b62f6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserializeFromFile</b> (const std::string &amp;filename, T &amp;output)</td></tr>
<tr class="memdesc:adbb4a71187706918faca3a11519b62f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserializes from a file <br /></td></tr>
<tr class="separator:adbb4a71187706918faca3a11519b62f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332bad7d1e70d3c04ceca35adce7a134"><td class="memTemplParams" colspan="2"><a id="a332bad7d1e70d3c04ceca35adce7a134" name="a332bad7d1e70d3c04ceca35adce7a134"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a332bad7d1e70d3c04ceca35adce7a134"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serialize</b> (const T &amp;input)</td></tr>
<tr class="memdesc:a332bad7d1e70d3c04ceca35adce7a134"><td class="mdescLeft">&#160;</td><td class="mdescRight">serializes to a string <br /></td></tr>
<tr class="separator:a332bad7d1e70d3c04ceca35adce7a134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d516d0d98946341ad2766521011d1b"><td class="memTemplParams" colspan="2"><a id="aa4d516d0d98946341ad2766521011d1b" name="aa4d516d0d98946341ad2766521011d1b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa4d516d0d98946341ad2766521011d1b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserialize</b> (const std::string &amp;serialized, T &amp;output)</td></tr>
<tr class="memdesc:aa4d516d0d98946341ad2766521011d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserializes from a string <br /></td></tr>
<tr class="separator:aa4d516d0d98946341ad2766521011d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">XML Serialization</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Serialization to XML format with named structures </p>
</div></td></tr>
<tr class="memitem:ae2e939177cf58b42d7ed4c9856d536c5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae2e939177cf58b42d7ed4c9856d536c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#ae2e939177cf58b42d7ed4c9856d536c5">serializeToXMLStream</a> (const T &amp;input, std::ostream &amp;out_archive_stream, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="separator:ae2e939177cf58b42d7ed4c9856d536c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7ea177ef3e93af15a4a77c2bd7fa8b"><td class="memTemplParams" colspan="2"><a id="a8d7ea177ef3e93af15a4a77c2bd7fa8b" name="a8d7ea177ef3e93af15a4a77c2bd7fa8b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8d7ea177ef3e93af15a4a77c2bd7fa8b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserializeFromXMLStream</b> (std::istream &amp;in_archive_stream, T &amp;output, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="memdesc:a8d7ea177ef3e93af15a4a77c2bd7fa8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserializes from a stream in XML <br /></td></tr>
<tr class="separator:a8d7ea177ef3e93af15a4a77c2bd7fa8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c154fe5e35242e26af8286e77eea11"><td class="memTemplParams" colspan="2"><a id="a16c154fe5e35242e26af8286e77eea11" name="a16c154fe5e35242e26af8286e77eea11"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a16c154fe5e35242e26af8286e77eea11"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serializeToXMLString</b> (const T &amp;input, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="memdesc:a16c154fe5e35242e26af8286e77eea11"><td class="mdescLeft">&#160;</td><td class="mdescRight">serializes to a string in XML <br /></td></tr>
<tr class="separator:a16c154fe5e35242e26af8286e77eea11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2fe2bfc17737ff9ae1fb8b210604f0"><td class="memTemplParams" colspan="2"><a id="a5f2fe2bfc17737ff9ae1fb8b210604f0" name="a5f2fe2bfc17737ff9ae1fb8b210604f0"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5f2fe2bfc17737ff9ae1fb8b210604f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserializeFromXMLString</b> (const std::string &amp;serialized, T &amp;output, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="memdesc:a5f2fe2bfc17737ff9ae1fb8b210604f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserializes from a string in XML <br /></td></tr>
<tr class="separator:a5f2fe2bfc17737ff9ae1fb8b210604f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89449123a746480a1d668cecb5576708"><td class="memTemplParams" colspan="2"><a id="a89449123a746480a1d668cecb5576708" name="a89449123a746480a1d668cecb5576708"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a89449123a746480a1d668cecb5576708"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serializeToXMLFile</b> (const T &amp;input, const std::string &amp;filename, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="memdesc:a89449123a746480a1d668cecb5576708"><td class="mdescLeft">&#160;</td><td class="mdescRight">serializes to an XML file <br /></td></tr>
<tr class="separator:a89449123a746480a1d668cecb5576708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8faf2bb0a908ff484677bb2fcf707c"><td class="memTemplParams" colspan="2"><a id="a0d8faf2bb0a908ff484677bb2fcf707c" name="a0d8faf2bb0a908ff484677bb2fcf707c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a0d8faf2bb0a908ff484677bb2fcf707c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserializeFromXMLFile</b> (const std::string &amp;filename, T &amp;output, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="memdesc:a0d8faf2bb0a908ff484677bb2fcf707c"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserializes from an XML file <br /></td></tr>
<tr class="separator:a0d8faf2bb0a908ff484677bb2fcf707c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976ff7999fcc13ef602b6ece1b078bca"><td class="memTemplParams" colspan="2"><a id="a976ff7999fcc13ef602b6ece1b078bca" name="a976ff7999fcc13ef602b6ece1b078bca"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a976ff7999fcc13ef602b6ece1b078bca"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serializeXML</b> (const T &amp;input, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="memdesc:a976ff7999fcc13ef602b6ece1b078bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">serializes to a string in XML <br /></td></tr>
<tr class="separator:a976ff7999fcc13ef602b6ece1b078bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ab51b2e8f4cea69f72e06a5c136e85"><td class="memTemplParams" colspan="2"><a id="a85ab51b2e8f4cea69f72e06a5c136e85" name="a85ab51b2e8f4cea69f72e06a5c136e85"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a85ab51b2e8f4cea69f72e06a5c136e85"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserializeXML</b> (const std::string &amp;serialized, T &amp;output, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="memdesc:a85ab51b2e8f4cea69f72e06a5c136e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserializes from a string in XML <br /></td></tr>
<tr class="separator:a85ab51b2e8f4cea69f72e06a5c136e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Binary Serialization</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Serialization to binary format with named structures </p>
</div></td></tr>
<tr class="memitem:aa5d177a3bf16f9f5acf45ee62c816479"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa5d177a3bf16f9f5acf45ee62c816479"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01596.html#aa5d177a3bf16f9f5acf45ee62c816479">serializeToBinaryStream</a> (const T &amp;input, std::ostream &amp;out_archive_stream, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="separator:aa5d177a3bf16f9f5acf45ee62c816479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb16192d8ebe2532d8a69c9f2bf15b2"><td class="memTemplParams" colspan="2"><a id="a8eb16192d8ebe2532d8a69c9f2bf15b2" name="a8eb16192d8ebe2532d8a69c9f2bf15b2"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8eb16192d8ebe2532d8a69c9f2bf15b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserializeFromBinaryStream</b> (std::istream &amp;in_archive_stream, T &amp;output, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="memdesc:a8eb16192d8ebe2532d8a69c9f2bf15b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserializes from a stream in binary <br /></td></tr>
<tr class="separator:a8eb16192d8ebe2532d8a69c9f2bf15b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fad959f63f2eac1478c5ede7b9ae4db"><td class="memTemplParams" colspan="2"><a id="a7fad959f63f2eac1478c5ede7b9ae4db" name="a7fad959f63f2eac1478c5ede7b9ae4db"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7fad959f63f2eac1478c5ede7b9ae4db"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serializeToBinaryString</b> (const T &amp;input, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="memdesc:a7fad959f63f2eac1478c5ede7b9ae4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">serializes to a string in binary <br /></td></tr>
<tr class="separator:a7fad959f63f2eac1478c5ede7b9ae4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349b7ed4a67a8c3d80737e5383507bc4"><td class="memTemplParams" colspan="2"><a id="a349b7ed4a67a8c3d80737e5383507bc4" name="a349b7ed4a67a8c3d80737e5383507bc4"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a349b7ed4a67a8c3d80737e5383507bc4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserializeFromBinaryString</b> (const std::string &amp;serialized, T &amp;output, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="memdesc:a349b7ed4a67a8c3d80737e5383507bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserializes from a string in binary <br /></td></tr>
<tr class="separator:a349b7ed4a67a8c3d80737e5383507bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdff0a4b4fdf0e609aa62fb8d8b1dbba"><td class="memTemplParams" colspan="2"><a id="abdff0a4b4fdf0e609aa62fb8d8b1dbba" name="abdff0a4b4fdf0e609aa62fb8d8b1dbba"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:abdff0a4b4fdf0e609aa62fb8d8b1dbba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serializeToBinaryFile</b> (const T &amp;input, const std::string &amp;filename, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="memdesc:abdff0a4b4fdf0e609aa62fb8d8b1dbba"><td class="mdescLeft">&#160;</td><td class="mdescRight">serializes to a binary file <br /></td></tr>
<tr class="separator:abdff0a4b4fdf0e609aa62fb8d8b1dbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefeb77f2324e4bbfca2c8152c49a4565"><td class="memTemplParams" colspan="2"><a id="aefeb77f2324e4bbfca2c8152c49a4565" name="aefeb77f2324e4bbfca2c8152c49a4565"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aefeb77f2324e4bbfca2c8152c49a4565"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserializeFromBinaryFile</b> (const std::string &amp;filename, T &amp;output, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="memdesc:aefeb77f2324e4bbfca2c8152c49a4565"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserializes from a binary file <br /></td></tr>
<tr class="separator:aefeb77f2324e4bbfca2c8152c49a4565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb476c3e77878f7e0f70dd51871f48e7"><td class="memTemplParams" colspan="2"><a id="abb476c3e77878f7e0f70dd51871f48e7" name="abb476c3e77878f7e0f70dd51871f48e7"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:abb476c3e77878f7e0f70dd51871f48e7"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serializeBinary</b> (const T &amp;input, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="memdesc:abb476c3e77878f7e0f70dd51871f48e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">serializes to a string in binary <br /></td></tr>
<tr class="separator:abb476c3e77878f7e0f70dd51871f48e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c41958e57a4bc7361ab593011462fd"><td class="memTemplParams" colspan="2"><a id="a56c41958e57a4bc7361ab593011462fd" name="a56c41958e57a4bc7361ab593011462fd"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a56c41958e57a4bc7361ab593011462fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserializeBinary</b> (const std::string &amp;serialized, T &amp;output, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="memdesc:a56c41958e57a4bc7361ab593011462fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserializes from a string in binary <br /></td></tr>
<tr class="separator:a56c41958e57a4bc7361ab593011462fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">utility functions</div></td></tr>
<tr class="memitem:a0b1822ab82a2183082fd329798bd9a25"><td class="memItemLeft" align="right" valign="top"><a id="a0b1822ab82a2183082fd329798bd9a25" name="a0b1822ab82a2183082fd329798bd9a25"></a>
<a class="el" href="a04016.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><b>buildVectorValues</b> (const Vector &amp;v, const <a class="el" href="a03632.html">Ordering</a> &amp;ordering, const std::map&lt; <a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a>, size_t &gt; &amp;dimensions)</td></tr>
<tr class="memdesc:a0b1822ab82a2183082fd329798bd9a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="a04016.html" title="This class represents a collection of vector-valued variables associated each with a unique integer i...">VectorValues</a> from a Vector. <br /></td></tr>
<tr class="separator:a0b1822ab82a2183082fd329798bd9a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428bc7bf810a3606f1523ddaf041a32d"><td class="memItemLeft" align="right" valign="top"><a id="a428bc7bf810a3606f1523ddaf041a32d" name="a428bc7bf810a3606f1523ddaf041a32d"></a>
<a class="el" href="a04016.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><b>buildVectorValues</b> (const Vector &amp;v, const <a class="el" href="a03792.html">KeyInfo</a> &amp;keyInfo)</td></tr>
<tr class="memdesc:a428bc7bf810a3606f1523ddaf041a32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="a04016.html" title="This class represents a collection of vector-valued variables associated each with a unique integer i...">VectorValues</a> from a Vector and a <a class="el" href="a03792.html" title="Handy data structure for iterative solvers.">KeyInfo</a> class. <br /></td></tr>
<tr class="separator:a428bc7bf810a3606f1523ddaf041a32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab8b4f36c2129e113c3652c32d611fecb"><td class="memItemLeft" align="right" valign="top"><a id="ab8b4f36c2129e113c3652c32d611fecb" name="ab8b4f36c2129e113c3652c32d611fecb"></a>
GTSAM_EXPORT <a class="el" href="a02484.html">FastMap</a>&lt; std::string, <a class="el" href="a02716.html">ValueWithDefault</a>&lt; bool, false &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>debugFlags</b></td></tr>
<tr class="separator:ab8b4f36c2129e113c3652c32d611fecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f65fe9bad84fc584a482382ebc754d7"><td class="memItemLeft" align="right" valign="top"><a id="a8f65fe9bad84fc584a482382ebc754d7" name="a8f65fe9bad84fc584a482382ebc754d7"></a>
const G &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>b</b></td></tr>
<tr class="separator:a8f65fe9bad84fc584a482382ebc754d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e01ab7428d09a6c1eb42ee121fda6bc"><td class="memItemLeft" align="right" valign="top"><a id="a0e01ab7428d09a6c1eb42ee121fda6bc" name="a0e01ab7428d09a6c1eb42ee121fda6bc"></a>
const G double&#160;</td><td class="memItemRight" valign="bottom"><b>tol</b></td></tr>
<tr class="separator:a0e01ab7428d09a6c1eb42ee121fda6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeead65285e8834b340a8a7235cdaa986"><td class="memItemLeft" align="right" valign="top"><a id="aeead65285e8834b340a8a7235cdaa986" name="aeead65285e8834b340a8a7235cdaa986"></a>
template class GTSAM_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><b>Conditional&lt; DecisionTreeFactor, DiscreteConditional &gt;</b></td></tr>
<tr class="separator:aeead65285e8834b340a8a7235cdaa986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5602eb85d05df6cba60e47eebbd3636"><td class="memItemLeft" align="right" valign="top"><a id="ad5602eb85d05df6cba60e47eebbd3636" name="ad5602eb85d05df6cba60e47eebbd3636"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>logSqrt2PI</b> = log(std::sqrt(2.0 * M_PI))</td></tr>
<tr class="memdesc:ad5602eb85d05df6cba60e47eebbd3636"><td class="mdescLeft">&#160;</td><td class="mdescRight">constant needed below <br /></td></tr>
<tr class="separator:ad5602eb85d05df6cba60e47eebbd3636"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Global functions in a separate testing namespace. </p>
<p ><a class="el" href="a01160_source.html">triangulationFactor.h</a></p>
<p >This file supports creating continuous functions <code>f(x;p)</code> as a linear combination of <code>basis functions</code> such as the Fourier basis on SO(2) or a set of Chebyshev polynomials on [-1,1].</p>
<p >Matrix is a typedef in the gtsam namespace TODO: make a version to work with matlab wrapping we use the default &lt; double,col_major,unbounded_array&lt;double&gt; &gt;</p>
<p >These should not be used outside of tests, as they are just remappings of the original functions. We use these to avoid needing to do too much std::bind magic or writing a bunch of separate proxy functions.</p>
<p >Don't expect all classes to work for all of these functions.</p>
<p >In the expression <code>f(x;p)</code> the variable <code>x</code> is the continuous argument at which the function is evaluated, and <code>p</code> are the parameters which are coefficients of the different basis functions, e.g. p = [4; 3; 2] =&gt; 4 + 3x + 2x^2 for a polynomial. However, different parameterizations are also possible.</p>
<p >The <code><a class="el" href="a02812.html" title="CRTP Base class for function bases.">Basis</a></code> class below defines a number of functors that can be used to evaluate <code>f(x;p)</code> at a given <code>x</code>, and these functors also calculate the Jacobian of <code>f(x;p)</code> with respect to the parameters <code>p</code>. This is actually the most important calculation, as it will allow GTSAM to optimize over the parameters <code>p</code>.</p>
<p >This functionality is implemented using the <code>CRTP</code> or "Curiously recurring
  template pattern" C++ idiom, which is a meta-programming technique in which the derived class is passed as a template argument to <code><a class="el" href="a02812.html" title="CRTP Base class for function bases.">Basis</a>&lt;DERIVED&gt;</code>. The DERIVED class is assumed to satisfy a C++ concept, i.e., we expect it to define the following types and methods:</p>
<ul>
<li>type <code>Parameters</code>: the parameters <code>p</code> in f(x;p)</li>
<li><code>CalculateWeights(size_t N, double x, double a=default, double b=default)</code></li>
<li><code>DerivativeWeights(size_t N, double x, double a=default, double b=default)</code></li>
</ul>
<p >where <code>Weights</code> is an N*1 row vector which defines the basis values for the polynomial at the specified point <code>x</code>.</p>
<p >E.g. A Fourier series would give the following:</p><ul>
<li><code>CalculateWeights</code> -&gt; For N=5, the values for the bases: [1, cos(x), sin(x), cos(2x), sin(2x)]</li>
<li><code>DerivativeWeights</code> -&gt; For N=5, these are: [0, -sin(x), cos(x), -2sin(2x), 2cos(x)]</li>
</ul>
<p >Note that for a pseudo-spectral basis (as in <a class="el" href="a02884.html" title="Chebyshev Interpolation on Chebyshev points of the second kind Note that N here, the number of points...">Chebyshev2</a>), the weights are instead the values for the Barycentric interpolation formula, since the values at the polynomial points (e.g. Chebyshev points) define the bases.</p>
<dl class="section date"><dt>Date</dt><dd>March 2, 2014 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Frank Dellaert </dd></dl>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a99e63c90a8ac740d99716e73fe97e054" name="a99e63c90a8ac740d99716e73fe97e054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e63c90a8ac740d99716e73fe97e054">&#9670;&nbsp;</a></span>FactorIndices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef FastVector&lt; <a class="el" href="a01596.html#a19c53f2faabb0f4b4b78ce2f7168cc14">FactorIndex</a> &gt; <a class="el" href="a01596.html#a99e63c90a8ac740d99716e73fe97e054">gtsam::FactorIndices</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define collection types: </p>
<p >Define collection type: </p>

</div>
</div>
<a id="abcc5d1ec05ddc954d5de28929acabbdf" name="abcc5d1ec05ddc954d5de28929acabbdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc5d1ec05ddc954d5de28929acabbdf">&#9670;&nbsp;</a></span>GraphAndValues</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a01596.html#abcc5d1ec05ddc954d5de28929acabbdf">gtsam::GraphAndValues</a> = typedef std::pair&lt;NonlinearFactorGraph::shared_ptr, <a class="el" href="a04560.html#a5b2f07b6054d9ea06b28876a057938d1">Values::shared_ptr</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return type for load functions, which return a graph and initial values. </p>
<p >For landmarks, the <a class="el" href="a03640.html" title="Character and index key used to refer to variables.">gtsam::Symbol</a> L(index) is used to insert into the <a class="el" href="a04560.html" title="A non-templated config holding any types of Manifold-group elements.">Values</a>. Bearing-range measurements also refer to landmarks with L(index). </p>

</div>
</div>
<a id="a3a2e8c622e65623a6853c84073bdb4f2" name="a3a2e8c622e65623a6853c84073bdb4f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2e8c622e65623a6853c84073bdb4f2">&#9670;&nbsp;</a></span>PinholeCameraCal3_S2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a01596.html#a3a2e8c622e65623a6853c84073bdb4f2">gtsam::PinholeCameraCal3_S2</a> = typedef <a class="el" href="a03212.html">gtsam::PinholeCamera</a>&lt;<a class="el" href="a03052.html">gtsam::Cal3_S2</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenient aliases for Pinhole camera classes with different calibrations. </p>
<p >Also needed as forward declarations in the wrapper. </p>

</div>
</div>
<a id="ab6e5a4884342656e0837ef07008ec03f" name="ab6e5a4884342656e0837ef07008ec03f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6e5a4884342656e0837ef07008ec03f">&#9670;&nbsp;</a></span>SharedNoiseModel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef noiseModel::Base::shared_ptr <a class="el" href="a01596.html#ab6e5a4884342656e0837ef07008ec03f">gtsam::SharedNoiseModel</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Note, deliberately not in <a class="el" href="a01616.html" title="All noise models live in the noiseModel namespace.">noiseModel</a> namespace. </p>
<p >Deprecated. Only for compatibility with previous version. </p>

</div>
</div>
<a id="a52b9b28b076a8ae17d6d3d72ee1229c3" name="a52b9b28b076a8ae17d6d3d72ee1229c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b9b28b076a8ae17d6d3d72ee1229c3">&#9670;&nbsp;</a></span>SparseEigen</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::SparseMatrix&lt;double, Eigen::ColMajor, int&gt; <a class="el" href="a01596.html#a52b9b28b076a8ae17d6d3d72ee1229c3">gtsam::SparseEigen</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eigen-format sparse matrix. </p>
<p >Note: ColMajor is ~20% faster since InnerIndices must be sorted </p>

</div>
</div>
<a id="ad6ba0a40d5dd8936f4ca53f7bb3ef53b" name="ad6ba0a40d5dd8936f4ca53f7bb3ef53b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6ba0a40d5dd8936f4ca53f7bb3ef53b">&#9670;&nbsp;</a></span>Velocity3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Vector3 <a class="el" href="a01596.html#ad6ba0a40d5dd8936f4ca53f7bb3ef53b">gtsam::Velocity3</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Velocity is currently typedef'd to Vector3. </p>
<p >Syntactic sugar to clarify components. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="adf2020f3f6087064dde501c99794aac3" name="adf2020f3f6087064dde501c99794aac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf2020f3f6087064dde501c99794aac3">&#9670;&nbsp;</a></span>LinearizationMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a01596.html#adf2020f3f6087064dde501c99794aac3">gtsam::LinearizationMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SmartFactorParams: parameters and (linearization/degeneracy) modes for SmartProjection and SmartStereoProjection factors. </p>
<p >Linearization mode: what factor to linearize to </p>

</div>
</div>
<a id="a90552b70a2da9c74595cae4b05c2ce18" name="a90552b70a2da9c74595cae4b05c2ce18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90552b70a2da9c74595cae4b05c2ce18">&#9670;&nbsp;</a></span>NoiseFormat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a01596.html#a90552b70a2da9c74595cae4b05c2ce18">gtsam::NoiseFormat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates how noise parameters are stored in file. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a90552b70a2da9c74595cae4b05c2ce18ad0aaa5c51a45cb7c9151aae60a603209" name="a90552b70a2da9c74595cae4b05c2ce18ad0aaa5c51a45cb7c9151aae60a603209"></a>NoiseFormatG2O&#160;</td><td class="fielddoc"><p >Information matrix I11, I12, I13, I22, I23, I33. </p>
</td></tr>
<tr><td class="fieldname"><a id="a90552b70a2da9c74595cae4b05c2ce18a3790bc2c6f11cd7da84730b33173de5a" name="a90552b70a2da9c74595cae4b05c2ce18a3790bc2c6f11cd7da84730b33173de5a"></a>NoiseFormatTORO&#160;</td><td class="fielddoc"><p >Information matrix, but inf_ff inf_fs inf_ss inf_rr inf_fr inf_sr. </p>
</td></tr>
<tr><td class="fieldname"><a id="a90552b70a2da9c74595cae4b05c2ce18a1f8edeb25c58a249789556c686265a4c" name="a90552b70a2da9c74595cae4b05c2ce18a1f8edeb25c58a249789556c686265a4c"></a>NoiseFormatGRAPH&#160;</td><td class="fielddoc"><p >default: toro-style order, but covariance matrix ! </p>
</td></tr>
<tr><td class="fieldname"><a id="a90552b70a2da9c74595cae4b05c2ce18a5450a16f3522214ccdfa23c461e7d05a" name="a90552b70a2da9c74595cae4b05c2ce18a5450a16f3522214ccdfa23c461e7d05a"></a>NoiseFormatCOV&#160;</td><td class="fielddoc"><p >Covariance matrix C11, C12, C13, C22, C23, C33. </p>
</td></tr>
<tr><td class="fieldname"><a id="a90552b70a2da9c74595cae4b05c2ce18a2f9067b8f5bd2d0dd38c49326a4c070e" name="a90552b70a2da9c74595cae4b05c2ce18a2f9067b8f5bd2d0dd38c49326a4c070e"></a>NoiseFormatAUTO&#160;</td><td class="fielddoc"><p >Try to guess covariance matrix layout. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="add6d6575582314cc9b5dbdbe2a86374d" name="add6d6575582314cc9b5dbdbe2a86374d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6d6575582314cc9b5dbdbe2a86374d">&#9670;&nbsp;</a></span>assert_equal() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool gtsam::assert_equal </td>
          <td>(</td>
          <td class="paramtype">const boost::optional&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::optional&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>actual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparisons for boost.optional objects that checks whether objects exist before comparing their values. </p>
<p >First version allows for both to be boost::none, but the second, with expected given rather than optional</p>
<p >Concept requirement: V is testable </p>

</div>
</div>
<a id="a6bbdbded37ed58ebbabe6c16d66a61d9" name="a6bbdbded37ed58ebbabe6c16d66a61d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bbdbded37ed58ebbabe6c16d66a61d9">&#9670;&nbsp;</a></span>assert_equal() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool GTSAM_DEPRECATED gtsam::assert_equal </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>actual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Version of assert_equals to work with vectors. </p>
<dl class="deprecated"><dt><b><a class="el" href="a01583.html#_deprecated000002">Deprecated:</a></b></dt><dd>: use container equals instead </dd></dl>

</div>
</div>
<a id="ac3cf8e8e70cd696d9c789c31bc1e89a7" name="ac3cf8e8e70cd696d9c789c31bc1e89a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3cf8e8e70cd696d9c789c31bc1e89a7">&#9670;&nbsp;</a></span>assert_equal() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT bool gtsam::assert_equal </td>
          <td>(</td>
          <td class="paramtype">const SubVector &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SubVector &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same, prints if error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>Vector </td></tr>
    <tr><td class="paramname">vec2</td><td>Vector </td></tr>
    <tr><td class="paramname">tol</td><td>1e-9 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a id="a9f3ee662d25ffb8c04b4e35c4b02e90b" name="a9f3ee662d25ffb8c04b4e35c4b02e90b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3ee662d25ffb8c04b4e35c4b02e90b">&#9670;&nbsp;</a></span>assert_equal() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT bool gtsam::assert_equal </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same, prints if error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>Vector </td></tr>
    <tr><td class="paramname">vec2</td><td>Vector </td></tr>
    <tr><td class="paramname">tol</td><td>1e-9 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a id="a2ca3db47b15350977c1f03c5560ab332" name="a2ca3db47b15350977c1f03c5560ab332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ca3db47b15350977c1f03c5560ab332">&#9670;&nbsp;</a></span>assert_inequal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT bool gtsam::assert_inequal </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Not the same, prints if error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>Vector </td></tr>
    <tr><td class="paramname">vec2</td><td>Vector </td></tr>
    <tr><td class="paramname">tol</td><td>1e-9 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a id="a830c8c65902d7d0e763562e6c9357346" name="a830c8c65902d7d0e763562e6c9357346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a830c8c65902d7d0e763562e6c9357346">&#9670;&nbsp;</a></span>assert_print_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool gtsam::assert_print_equal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>actual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Capture print function output and compare against string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Optional string to pass to the <a class="el" href="a01596.html#a54fa43c89c5334314c8c75939dd5c2d7" title="print without optional string, must specify cout yourself">print()</a> method. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af55c9458246c733317a7dfad7f9f813a" name="af55c9458246c733317a7dfad7f9f813a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af55c9458246c733317a7dfad7f9f813a">&#9670;&nbsp;</a></span>axpy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V1 , class V2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GTSAM_DEPRECATED gtsam::axpy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V2 &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>BLAS Level 1 axpy: y &lt;- alpha*x + y. </p>
<dl class="deprecated"><dt><b><a class="el" href="a01583.html#_deprecated000004">Deprecated:</a></b></dt><dd>: use operators instead </dd></dl>

</div>
</div>
<a id="a0d998e1b770c9864946ddb031b1c4522" name="a0d998e1b770c9864946ddb031b1c4522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d998e1b770c9864946ddb031b1c4522">&#9670;&nbsp;</a></span>backSubstituteLower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Vector gtsam::backSubstituteLower </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unit</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>backSubstitute L*x=b </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>an lower triangular matrix </td></tr>
    <tr><td class="paramname">b</td><td>an RHS vector </td></tr>
    <tr><td class="paramname">unit,set</td><td>true if unit triangular </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the solution x of L*x=b </dd></dl>

</div>
</div>
<a id="a6c4876cbe85d5651a52eda0e97c60f2f" name="a6c4876cbe85d5651a52eda0e97c60f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4876cbe85d5651a52eda0e97c60f2f">&#9670;&nbsp;</a></span>backSubstituteUpper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Vector gtsam::backSubstituteUpper </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unit</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>backSubstitute U*x=b </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>an upper triangular matrix </td></tr>
    <tr><td class="paramname">b</td><td>an RHS vector </td></tr>
    <tr><td class="paramname">unit,set</td><td>true if unit triangular </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the solution x of U*x=b </dd></dl>

</div>
</div>
<a id="a8b0bf332d52b333dab2b20d763c8925b" name="a8b0bf332d52b333dab2b20d763c8925b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b0bf332d52b333dab2b20d763c8925b">&#9670;&nbsp;</a></span>backSubstituteUpper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Vector gtsam::backSubstituteUpper </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unit</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>backSubstitute x'*U=b' </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>an upper triangular matrix </td></tr>
    <tr><td class="paramname">b</td><td>an RHS vector </td></tr>
    <tr><td class="paramname">unit,set</td><td>true if unit triangular </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the solution x of x'*U=b' </dd></dl>

</div>
</div>
<a id="adbd55c711e6ceee791b595558eb3ec8a" name="adbd55c711e6ceee791b595558eb3ec8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd55c711e6ceee791b595558eb3ec8a">&#9670;&nbsp;</a></span>BCH()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T gtsam::BCH </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Three term approximation of the Baker-Campbell-Hausdorff formula In non-commutative Lie groups, when composing exp(Z) = exp(X)exp(Y) it is not true that Z = X+Y. </p>
<p >Instead, Z can be calculated using the BCH formula: Z = X + Y + [X,Y]/2 + [X-Y,[X,Y]]/12 - [Y,[X,[X,Y]]]/24 <a href="http://en.wikipedia.org/wiki/Baker-Campbell-Hausdorff_formula">http://en.wikipedia.org/wiki/Baker-Campbell-Hausdorff_formula</a> AGC: bracket() only appears in <a class="el" href="a03336.html">Rot3</a> tests, should this be used elsewhere? </p>

</div>
</div>
<a id="abd92914d0822d42584d46f31fb500048" name="abd92914d0822d42584d46f31fb500048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd92914d0822d42584d46f31fb500048">&#9670;&nbsp;</a></span>between_default()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Class gtsam::between_default </td>
          <td>(</td>
          <td class="paramtype">const Class &amp;&#160;</td>
          <td class="paramname"><em>l1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Class &amp;&#160;</td>
          <td class="paramname"><em>l2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These core global functions can be specialized by new Lie types for better performance. </p>
<p >Compute l0 s.t. l2=l1*l0 </p>

</div>
</div>
<a id="a9ac814fcc4484bce32e4616d69afb225" name="a9ac814fcc4484bce32e4616d69afb225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac814fcc4484bce32e4616d69afb225">&#9670;&nbsp;</a></span>calibrateJacobians()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cal , size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gtsam::calibrateJacobians </td>
          <td>(</td>
          <td class="paramtype">const Cal &amp;&#160;</td>
          <td class="paramname"><em>calibration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01596.html#a6ede8384dee0353a0ce5fb54ea50c21d">Point2</a> &amp;&#160;</td>
          <td class="paramname"><em>pn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02616.html">OptionalJacobian</a>&lt; 2, Dim &gt;&#160;</td>
          <td class="paramname"><em>Dcal</em> = <code>boost::none</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02616.html">OptionalJacobian</a>&lt; 2, 2 &gt;&#160;</td>
          <td class="paramname"><em>Dp</em> = <code>boost::none</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which makes use of the Implicit Function Theorem to compute the Jacobians of <code>calibrate</code> using <code>uncalibrate</code>. </p>
<p >This is useful when there are iterative operations in the <code>calibrate</code> function which make computing jacobians difficult.</p>
<p >Given f(pi, pn) = uncalibrate(pn) - pi, and g(pi) = calibrate, we can easily compute the Jacobians: df/pi = -I (pn and pi are independent args) Dp = -inv(H_uncal_pn) * df/pi = -inv(H_uncal_pn) * (-I) = inv(H_uncal_pn) Dcal = -inv(H_uncal_pn) * df/K = -inv(H_uncal_pn) * H_uncal_K</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Cal</td><td>Calibration model. </td></tr>
    <tr><td class="paramname">Dim</td><td>The number of parameters in the calibration model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Calibrated point. </td></tr>
    <tr><td class="paramname">Dcal</td><td>optional 2*p Jacobian wrpt <code>p</code> <a class="el" href="a03088.html">Cal3DS2</a> parameters. </td></tr>
    <tr><td class="paramname">Dp</td><td>optional 2*2 Jacobian wrpt intrinsic coordinates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec77610fa3e4905d142a72b2199158db" name="aec77610fa3e4905d142a72b2199158db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec77610fa3e4905d142a72b2199158db">&#9670;&nbsp;</a></span>cartesianProduct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="a02912.html">Assignment</a>&lt; L &gt; &gt; gtsam::cartesianProduct </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; L, size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Cartesian product consisting all possible configurations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>list of keys (label,cardinality) pairs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector list of all possible value assignments</dd></dl>
<p>This function returns a vector of <a class="el" href="a02912.html" title="An assignment from labels to value index (size_t).">Assignment</a> values for all possible (Cartesian product) configurations of set of Keys which are nothing but (Label,cardinality) pairs. This function should NOT be called for more than a small number of variables and cardinalities. E.g. For 6 variables with each having cardinalities 4, we get 4096 possible configurations!! </p>

</div>
</div>
<a id="aba542e2cd85f08b76f80a0871a4ea713" name="aba542e2cd85f08b76f80a0871a4ea713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba542e2cd85f08b76f80a0871a4ea713">&#9670;&nbsp;</a></span>cholesky_inverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Matrix gtsam::cholesky_inverse </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the inverse of a S.P.D. </p>
<p >matrix. Inversion is done via Cholesky decomposition. </p>

</div>
</div>
<a id="a747683f736c50bca16b3aab0e95b1b76" name="a747683f736c50bca16b3aab0e95b1b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747683f736c50bca16b3aab0e95b1b76">&#9670;&nbsp;</a></span>choleskyCareful()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::pair&lt; size_t, bool &gt; gtsam::choleskyCareful </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>ATA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Careful" Cholesky computes the positive square-root of a positive symmetric semi-definite matrix (i.e. </p>
<p >that may be rank-deficient). Unlike standard Cholesky, the square-root factor may have all-zero rows for free variables.</p>
<p >Additionally, this function returns the index of the row after the last non-zero row in the computed factor, so that it may be truncated to an upper-trapazoidal matrix.</p>
<p >The second element of the return value is <code>true</code> if the matrix was factored successfully, or <code>false</code> if it was non-positive-semidefinite (i.e. indefinite or negative-(semi-)definite.</p>
<p >Note that this returned index is the rank of the matrix if and only if all of the zero-rows of the factor occur after any non-zero rows. This is (always?) the case during elimination of a fully-constrained least-squares problem.</p>
<p >The optional order argument specifies the size of the square upper-left submatrix to operate on, ignoring the rest of the matrix. </p>

</div>
</div>
<a id="abe82fa6aceccfa2360cf314ab44f39ad" name="abe82fa6aceccfa2360cf314ab44f39ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe82fa6aceccfa2360cf314ab44f39ad">&#9670;&nbsp;</a></span>choleskyPartial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT bool gtsam::choleskyPartial </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>ABC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nFrontal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>topleft</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial Cholesky computes a factor [R S such that [R' 0 [R S = [A B 0 L] S' I] 0 L] B' C]. </p>
<p >The input to this function is the matrix ABC = [A B], and the parameter [B' C] nFrontal determines the split between A, B, and C, with A being of size nFrontal x nFrontal.</p>
<p >if non-zero, factorization proceeds in bottom-right corner starting at topleft</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the decomposition is successful, <code>false</code> if <code>A</code> was not positive-definite. </dd></dl>

</div>
</div>
<a id="a93d4e38a582b6f32fc4f301df10721d5" name="a93d4e38a582b6f32fc4f301df10721d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d4e38a582b6f32fc4f301df10721d5">&#9670;&nbsp;</a></span>circleCircleIntersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::list&lt; <a class="el" href="a01596.html#a6ede8384dee0353a0ce5fb54ea50c21d">Point2</a> &gt; gtsam::circleCircleIntersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01596.html#a6ede8384dee0353a0ce5fb54ea50c21d">Point2</a>&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01596.html#a6ede8384dee0353a0ce5fb54ea50c21d">Point2</a>&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intersect 2 circles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c1</td><td>center of first circle </td></tr>
    <tr><td class="paramname">r1</td><td>radius of first circle </td></tr>
    <tr><td class="paramname">c2</td><td>center of second circle </td></tr>
    <tr><td class="paramname">r2</td><td>radius of second circle </td></tr>
    <tr><td class="paramname">tol</td><td>absolute tolerance below which we consider touching circles </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of solutions (0,1, or 2). Identical circles will return empty list, as well. </dd></dl>

</div>
</div>
<a id="ad8b524ba6c9aed0d21a020999c9b5d88" name="ad8b524ba6c9aed0d21a020999c9b5d88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b524ba6c9aed0d21a020999c9b5d88">&#9670;&nbsp;</a></span>collect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Matrix gtsam::collect </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const Matrix * &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a matrix by concatenating Given a set of matrices: A1, A2, A3... If all matrices have the same size, specifying single matrix dimensions will avoid the lookup of dimensions </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrices</td><td>is a vector of matrices in the order to be collected </td></tr>
    <tr><td class="paramname">m</td><td>is the number of rows of a single matrix </td></tr>
    <tr><td class="paramname">n</td><td>is the number of columns of a single matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>combined matrix [A1 A2 A3] </dd></dl>

</div>
</div>
<a id="a559dba69e2854eb66e34222f60f55722" name="a559dba69e2854eb66e34222f60f55722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559dba69e2854eb66e34222f60f55722">&#9670;&nbsp;</a></span>column()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MATRIX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const MATRIX::ConstColXpr gtsam::column </td>
          <td>(</td>
          <td class="paramtype">const MATRIX &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a column view from a matrix that avoids a copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>matrix to extract column from </td></tr>
    <tr><td class="paramname">j</td><td>index of the column </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a const view of the matrix </dd></dl>

</div>
</div>
<a id="a6516ea957c3a22ddf429cefef1fe9486" name="a6516ea957c3a22ddf429cefef1fe9486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6516ea957c3a22ddf429cefef1fe9486">&#9670;&nbsp;</a></span>conjugateGradients()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S , class V , class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V gtsam::conjugateGradients </td>
          <td>(</td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>Ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a03680.html">ConjugateGradientParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>steepest</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method of conjugate gradients (CG) template "System" class S needs gradient(S,v), e=S*v, v=S^e "Vector" class V needs dot(v,v), -v, v+v, s*v "Vector" class E needs dot(v,v) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ab,the</td><td>"system" that needs to be solved, examples below </td></tr>
    <tr><td class="paramname">x</td><td>is the initial estimate </td></tr>
    <tr><td class="paramname">steepest</td><td>flag, if true does steepest descent, not CG </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa43e7fd7c2b86873458a91ddafc506e4" name="aa43e7fd7c2b86873458a91ddafc506e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43e7fd7c2b86873458a91ddafc506e4">&#9670;&nbsp;</a></span>ConvertNoiseModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a01596.html#ab6e5a4884342656e0837ef07008ec03f">SharedNoiseModel</a> gtsam::ConvertNoiseModel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01596.html#ab6e5a4884342656e0837ef07008ec03f">SharedNoiseModel</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>defaultToUnit</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When creating (any) <a class="el" href="a04768.html" title="FrobeniusFactor calculates the Frobenius norm between rotation matrices.">FrobeniusFactor</a> we can convert a Rot/Pose <a class="el" href="a04684.html">BetweenFactor</a> noise model into a n-dimensional isotropic noise model used to weight the Frobenius norm. </p>
<p >If the noise model passed is null we return a n-dimensional isotropic noise model with sigma=1.0. If not, we we check if the d-dimensional noise model on rotations is isotropic. If it is, we extend to 'n' dimensions, otherwise we throw an error. If the noise model is a robust error model, we use the sigmas of the underlying noise model.</p>
<p >If defaultToUnit == false throws an exception on unexepcted input. </p>

</div>
</div>
<a id="a51881c20dd5ecdd129cb993ea8374846" name="a51881c20dd5ecdd129cb993ea8374846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51881c20dd5ecdd129cb993ea8374846">&#9670;&nbsp;</a></span>createUnknowns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="a04240.html">Expression</a>&lt; T &gt; &gt; gtsam::createUnknowns </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an array of leaves. </p>
<p >Construct an array of unknown expressions with successive symbol keys Example: createUnknowns&lt;Pose2&gt;(3,'x') creates unknown expressions for x0,x1,x2. </p>

</div>
</div>
<a id="a86bf6ed2ffb0ecc42a7deb8922f4ca4f" name="a86bf6ed2ffb0ecc42a7deb8922f4ca4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86bf6ed2ffb0ecc42a7deb8922f4ca4f">&#9670;&nbsp;</a></span>cross()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a> gtsam::cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02616.html">OptionalJacobian</a>&lt; 3, 3 &gt;&#160;</td>
          <td class="paramname"><em>H_p</em> = <code>boost::none</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02616.html">OptionalJacobian</a>&lt; 3, 3 &gt;&#160;</td>
          <td class="paramname"><em>H_q</em> = <code>boost::none</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cross product </p>
<dl class="section return"><dt>Returns</dt><dd>this x q </dd></dl>

</div>
</div>
<a id="a0b97fc96e5f69236e81489c66d5b92ba" name="a0b97fc96e5f69236e81489c66d5b92ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b97fc96e5f69236e81489c66d5b92ba">&#9670;&nbsp;</a></span>demangle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string GTSAM_EXPORT gtsam::demangle </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pretty print <a class="el" href="a02740.html" title="This is the base class for any type to be stored in Values.">Value</a> type name. </p>
<p >Function to demangle type name of variable, e.g. demangle(typeid(x).name()) </p>

</div>
</div>
<a id="ab2c65f1a69009a306b6a5f9ef31dcee2" name="ab2c65f1a69009a306b6a5f9ef31dcee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2c65f1a69009a306b6a5f9ef31dcee2">&#9670;&nbsp;</a></span>DLT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT boost::tuple&lt; int, double, Vector &gt; gtsam::DLT </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rank_tol</em> = <code>1e-9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct linear transform algorithm that calls svd to find a vector v that minimizes the algebraic error A*v. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>of size m*n, where m&gt;=n (pad with zero rows if not!) Returns rank of A, minimum error (singular value), and corresponding eigenvector (column of V, with A=U*S*V') </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14844c96706dc362917e0d5e76d65fbe" name="a14844c96706dc362917e0d5e76d65fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14844c96706dc362917e0d5e76d65fbe">&#9670;&nbsp;</a></span>ediv_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Vector gtsam::ediv_ </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>elementwise division, but 0/0 = 0, not inf </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first vector </td></tr>
    <tr><td class="paramname">b</td><td>second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector [a(i)/b(i)] </dd></dl>

</div>
</div>
<a id="ab56c4bfa363f8c23c48eb078e9c84a9c" name="ab56c4bfa363f8c23c48eb078e9c84a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab56c4bfa363f8c23c48eb078e9c84a9c">&#9670;&nbsp;</a></span>EliminateQR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::pair&lt; boost::shared_ptr&lt; <a class="el" href="a03716.html">GaussianConditional</a> &gt;, boost::shared_ptr&lt; <a class="el" href="a03796.html">JacobianFactor</a> &gt; &gt; gtsam::EliminateQR </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a03744.html">GaussianFactorGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a03632.html">Ordering</a> &amp;&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply all factors and eliminate the given keys from the resulting factor using a QR variant that handles constraints (zero sigmas). </p>
<p >Computation happens in <a class="el" href="a03876.html#a69d56bbe0e3c68743c5e7f42340b6426" title="Apply appropriately weighted QR factorization to the system [A b] Q&#39; * [A b] = [R d] Dimensions: (r*m...">noiseModel::Gaussian::QR</a> Returns a conditional on those keys, and a new factor on the separator. </p>

</div>
</div>
<a id="a659f20993995258b1405737e375efd10" name="a659f20993995258b1405737e375efd10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659f20993995258b1405737e375efd10">&#9670;&nbsp;</a></span>EliminateSymbolic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::pair&lt; boost::shared_ptr&lt; <a class="el" href="a04932.html">SymbolicConditional</a> &gt;, boost::shared_ptr&lt; <a class="el" href="a04948.html">SymbolicFactor</a> &gt; &gt; gtsam::EliminateSymbolic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a04960.html">SymbolicFactorGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a03632.html">Ordering</a> &amp;&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dense elimination function for symbolic factors. </p>
<p >This is usually provided as an argument to one of the factor graph elimination functions (see <a class="el" href="a03532.html" title="EliminateableFactorGraph is a base class for factor graphs that contains elimination algorithms.">EliminateableFactorGraph</a>). The factor graph elimination functions do sparse variable elimination, and use this function to eliminate single variables or variable cliques. </p>

</div>
</div>
<a id="ab15462d8c16813d0a7a5b1f76a2f64b7" name="ab15462d8c16813d0a7a5b1f76a2f64b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15462d8c16813d0a7a5b1f76a2f64b7">&#9670;&nbsp;</a></span>expm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Matrix gtsam::expm </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>K</em> = <code>7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Numerical exponential map, naive approach, not industrial strength !!! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>matrix to exponentiate </td></tr>
    <tr><td class="paramname">K</td><td>number of iterations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3041816208c79ef76d3ef2e0991d90b2" name="a3041816208c79ef76d3ef2e0991d90b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3041816208c79ef76d3ef2e0991d90b2">&#9670;&nbsp;</a></span>expm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T gtsam::expm </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>K</em> = <code>7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exponential map given exponential coordinates class T needs a wedge&lt;&gt; function and a constructor from Matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>exponential coordinates, vector of size n @ return a T </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5a7c0a7422c38a0baa131c073e233ac" name="af5a7c0a7422c38a0baa131c073e233ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a7c0a7422c38a0baa131c073e233ac">&#9670;&nbsp;</a></span>expmap_default()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Class gtsam::expmap_default </td>
          <td>(</td>
          <td class="paramtype">const Class &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exponential map centered at l0, s.t. </p>
<p >exp(t,d) = t*exp(d) </p>

</div>
</div>
<a id="aef971b2c69845e4fcce707306703c7b8" name="aef971b2c69845e4fcce707306703c7b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef971b2c69845e4fcce707306703c7b8">&#9670;&nbsp;</a></span>findExampleDataFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::string gtsam::findExampleDataFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the full path to an example dataset distributed with gtsam. </p>
<p >The name may be specified with or without a file extension - if no extension is given, this function first looks for the .graph extension, then .txt. We first check the gtsam source tree for the file, followed by the installed example dataset location. Both the source tree and installed locations are obtained from CMake during compilation. </p><dl class="section return"><dt>Returns</dt><dd>The full path and filename to the requested dataset. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if no matching file could be found using the search process described above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae19c359190a379cba44bf818a2293f7c" name="ae19c359190a379cba44bf818a2293f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae19c359190a379cba44bf818a2293f7c">&#9670;&nbsp;</a></span>fpEqual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT bool gtsam::fpEqual </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_relative_also</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure we are not including a different version of Eigen in user code than while compiling gtsam, since it can lead to hard-to-understand runtime crashes. </p>
<p >Numerically stable function for comparing if floating point values are equal within epsilon tolerance. Used for vector and matrix comparison with C++11 compatible functions.</p>
<p >If either value is NaN or Inf, we check for both values to be NaN or Inf respectively for the comparison to be true. If one is NaN/Inf and the other is not, returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">check_relative_also</td><td>is a flag which toggles additional checking for relative error. This means that if either the absolute error or the relative error is within the tolerance, the result will be true. By default, the flag is true.</td></tr>
  </table>
  </dd>
</dl>
<p>Return true if two numbers are close wrt tol. </p>

</div>
</div>
<a id="ad632ed56581bf174eef379bbe272a06a" name="ad632ed56581bf174eef379bbe272a06a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad632ed56581bf174eef379bbe272a06a">&#9670;&nbsp;</a></span>gtsam2openGL() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a03288.html">Pose3</a> gtsam::gtsam2openGL </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a03288.html">Pose3</a> &amp;&#160;</td>
          <td class="paramname"><em>PoseGTSAM</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts a GTSAM camera pose to an openGL camera pose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PoseGTSAM</td><td>pose in GTSAM format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a03288.html">Pose3</a> in openGL format </dd></dl>

</div>
</div>
<a id="aaff07ef70e6161c4d1d2bd7546ff91e6" name="aaff07ef70e6161c4d1d2bd7546ff91e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff07ef70e6161c4d1d2bd7546ff91e6">&#9670;&nbsp;</a></span>gtsam2openGL() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a03288.html">Pose3</a> gtsam::gtsam2openGL </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a03336.html">Rot3</a> &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts a GTSAM camera pose to an openGL camera pose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>rotation in GTSAM </td></tr>
    <tr><td class="paramname">tx</td><td>x component of the translation in GTSAM </td></tr>
    <tr><td class="paramname">ty</td><td>y component of the translation in GTSAM </td></tr>
    <tr><td class="paramname">tz</td><td>z component of the translation in GTSAM </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a03288.html">Pose3</a> in openGL format </dd></dl>

</div>
</div>
<a id="a35c269c3243cab16a7475239a9c91021" name="a35c269c3243cab16a7475239a9c91021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c269c3243cab16a7475239a9c91021">&#9670;&nbsp;</a></span>hasConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT bool gtsam::hasConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a03744.html">GaussianFactorGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates whether linear factors have any constrained noise models. </p>
<dl class="section return"><dt>Returns</dt><dd>true if any factor is constrained. </dd></dl>

</div>
</div>
<a id="afb77eefc25dea0fb3e0fcc8f246b617a" name="afb77eefc25dea0fb3e0fcc8f246b617a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb77eefc25dea0fb3e0fcc8f246b617a">&#9670;&nbsp;</a></span>house()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::pair&lt; double, Vector &gt; gtsam::house </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>house(x,j) computes HouseHolder vector v and scaling factor beta from x, such that the corresponding Householder reflection zeroes out all but x. </p>
<p >(j), j is base 0. Golub &amp; Van Loan p 210. </p>

</div>
</div>
<a id="a7baa2f3184a444adce108633c0265e0c" name="a7baa2f3184a444adce108633c0265e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7baa2f3184a444adce108633c0265e0c">&#9670;&nbsp;</a></span>householder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT void gtsam::householder </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Householder tranformation, zeros below diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>number of columns to zero out below diagonal </td></tr>
    <tr><td class="paramname">A</td><td>matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nothing: in place !!! </dd></dl>

</div>
</div>
<a id="abdd1ab05e8ac90b340fbd8f3b322dc6d" name="abdd1ab05e8ac90b340fbd8f3b322dc6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd1ab05e8ac90b340fbd8f3b322dc6d">&#9670;&nbsp;</a></span>householder_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT void gtsam::householder_ </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_vectors</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Imperative version of Householder QR factorization, Golub &amp; Van Loan p 224 version with Householder vectors below diagonal, as in GVL. </p>
<p >Householder transformation, Householder vectors below diagonal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>number of columns to zero out below diagonal </td></tr>
    <tr><td class="paramname">A</td><td>matrix </td></tr>
    <tr><td class="paramname">copy_vectors</td><td>- true to copy Householder vectors below diagonal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nothing: in place !!! </dd></dl>

</div>
</div>
<a id="aba34ed4a103d9057536ee5cac27cfdef" name="aba34ed4a103d9057536ee5cac27cfdef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba34ed4a103d9057536ee5cac27cfdef">&#9670;&nbsp;</a></span>initialCamerasAndPointsEstimate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a04560.html">Values</a> gtsam::initialCamerasAndPointsEstimate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a04736.html">SfmData</a> &amp;&#160;</td>
          <td class="paramname"><em>db</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function creates initial values for cameras and points from db. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="a04736.html" title="Define the structure for SfM data.">SfmData</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a04560.html" title="A non-templated config holding any types of Manifold-group elements.">Values</a> </dd></dl>

</div>
</div>
<a id="ad8b55993353cbab0fde06b872783fe92" name="ad8b55993353cbab0fde06b872783fe92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b55993353cbab0fde06b872783fe92">&#9670;&nbsp;</a></span>initialCamerasEstimate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a04560.html">Values</a> gtsam::initialCamerasEstimate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a04736.html">SfmData</a> &amp;&#160;</td>
          <td class="paramname"><em>db</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function creates initial values for cameras from db. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="a04736.html" title="Define the structure for SfM data.">SfmData</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a04560.html" title="A non-templated config holding any types of Manifold-group elements.">Values</a> </dd></dl>

</div>
</div>
<a id="a7eec9339ab5a008a28ddfaa6b2c94611" name="a7eec9339ab5a008a28ddfaa6b2c94611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eec9339ab5a008a28ddfaa6b2c94611">&#9670;&nbsp;</a></span>inplace_QR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT void gtsam::inplace_QR </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QR factorization using Eigen's internal block QR algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>is the input matrix, and is the output </td></tr>
    <tr><td class="paramname">clear_below_diagonal</td><td>enables zeroing out below diagonal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1088fa2d1494e6a4123a6bc3f5c2d7e" name="ad1088fa2d1494e6a4123a6bc3f5c2d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1088fa2d1494e6a4123a6bc3f5c2d7e">&#9670;&nbsp;</a></span>insertSub()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived1 , typename Derived2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gtsam::insertSub </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixBase&lt; Derived1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>fullMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>subMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>insert a submatrix IN PLACE at a specified location in a larger matrix NOTE: there is no size checking </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fullMatrix</td><td>matrix to be updated </td></tr>
    <tr><td class="paramname">subMatrix</td><td>matrix to be inserted </td></tr>
    <tr><td class="paramname">i</td><td>is the row of the upper left corner insert location </td></tr>
    <tr><td class="paramname">j</td><td>is the column of the upper left corner insert location </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adaf06b04fa93b050e99bc3d571d85d53" name="adaf06b04fa93b050e99bc3d571d85d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf06b04fa93b050e99bc3d571d85d53">&#9670;&nbsp;</a></span>interpolate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T gtsam::interpolate </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="a02628.html">MakeOptionalJacobian</a>&lt; T, T &gt;::type&#160;</td>
          <td class="paramname"><em>Hx</em> = <code>boost::none</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="a02628.html">MakeOptionalJacobian</a>&lt; T, T &gt;::type&#160;</td>
          <td class="paramname"><em>Hy</em> = <code>boost::none</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linear interpolation between X and Y by coefficient t. </p>
<p >Typically t \in [0,1], but can also be used to extrapolate before pose X or after pose Y. </p>

</div>
</div>
<a id="a2ce44d31cae1eda44c2a86d32d92b935" name="a2ce44d31cae1eda44c2a86d32d92b935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce44d31cae1eda44c2a86d32d92b935">&#9670;&nbsp;</a></span>kroneckerProductIdentity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix gtsam::kroneckerProductIdentity </td>
          <td>(</td>
          <td class="paramtype">const Weights &amp;&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for computing the kronecker product of the 1*N Weight vector <code>w</code> with the MxM identity matrix <code>I</code> efficiently. </p>
<p >The main reason for this is so we don't need to use Eigen's Unsupported library.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>Size of the identity matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>The weights of the polynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mx(M*N) kronecker product [w(0)*I, w(1)*I, ..., w(N-1)*I] </dd></dl>

</div>
</div>
<a id="a2a0cfd7908b06491df49b6a9c9186775" name="a2a0cfd7908b06491df49b6a9c9186775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0cfd7908b06491df49b6a9c9186775">&#9670;&nbsp;</a></span>linear_dependent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT bool gtsam::linear_dependent </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check whether two vectors are linearly dependent </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>Vector </td></tr>
    <tr><td class="paramname">vec2</td><td>Vector </td></tr>
    <tr><td class="paramname">tol</td><td>1e-9 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a id="a794029fe8dfc03f67a8cb64ad05d47c9" name="a794029fe8dfc03f67a8cb64ad05d47c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794029fe8dfc03f67a8cb64ad05d47c9">&#9670;&nbsp;</a></span>linearExpression()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a04240.html">Expression</a>&lt; T &gt; gtsam::linearExpression </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; T(A)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a04240.html">Expression</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname"><em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, <a class="el" href="a02444.html">traits</a>&lt; T &gt;::dimension, <a class="el" href="a02444.html">traits</a>&lt; A &gt;::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>dTdA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an expression out of a linear function f:T-&gt;A with (constant) Jacobian dTdA TODO(frank): create a more efficient version like <a class="el" href="a04256.html" title="A ScalarMultiplyExpression is a specialization of Expression that multiplies with a scalar It optimiz...">ScalarMultiplyExpression</a>. </p>
<p >This version still does a malloc every linearize. </p>

</div>
</div>
<a id="a9753b4e62378151d30bf8af5e2fc1602" name="a9753b4e62378151d30bf8af5e2fc1602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9753b4e62378151d30bf8af5e2fc1602">&#9670;&nbsp;</a></span>linearizeNumerically()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a03796.html">JacobianFactor</a> gtsam::linearizeNumerically </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a04448.html">NoiseModelFactor</a> &amp;&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a04560.html">Values</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linearize a nonlinear factor using numerical differentiation The benefit of this method is that it does not need to know what types are involved to evaluate the factor. </p>
<p >If all the machinery of gtsam is working correctly, we should get the correct numerical derivatives out the other side. NOTE(frank): factors that have non vector-space measurements use between or LocalCoordinates to evaluate the error, and their derivatives will only be correct for near-zero errors. This is fixable but expensive, and does not matter in practice as most factors will sit near zero errors anyway. However, it means that below will only be exact for the correct measurement. </p>

</div>
</div>
<a id="a635ec096b94adc2b05f081cd07eb2c0f" name="a635ec096b94adc2b05f081cd07eb2c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a635ec096b94adc2b05f081cd07eb2c0f">&#9670;&nbsp;</a></span>load2D() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a01596.html#abcc5d1ec05ddc954d5de28929acabbdf">GraphAndValues</a> gtsam::load2D </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01596.html#ab6e5a4884342656e0837ef07008ec03f">SharedNoiseModel</a>&#160;</td>
          <td class="paramname"><em>model</em> = <code><a class="el" href="a01596.html#ab6e5a4884342656e0837ef07008ec03f">SharedNoiseModel</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxIndex</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addNoise</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>smart</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01596.html#a90552b70a2da9c74595cae4b05c2ce18">NoiseFormat</a>&#160;</td>
          <td class="paramname"><em>noiseFormat</em> = <code><a class="el" href="a01596.html#a90552b70a2da9c74595cae4b05c2ce18a2f9067b8f5bd2d0dd38c49326a4c070e">NoiseFormatAUTO</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01596.html#a8be373f34edc0a9d28b1bfab5dd62ba0">KernelFunctionType</a>&#160;</td>
          <td class="paramname"><em>kernelFunctionType</em> = <code>KernelFunctionTypeNONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load TORO/G2O style graph files. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td></td></tr>
    <tr><td class="paramname">model</td><td>optional noise model to use instead of one specified by file </td></tr>
    <tr><td class="paramname">maxIndex</td><td>if non-zero cut out vertices &gt;= maxIndex </td></tr>
    <tr><td class="paramname">addNoise</td><td>add noise to the edges </td></tr>
    <tr><td class="paramname">smart</td><td>try to reduce complexity of covariance to cheapest model </td></tr>
    <tr><td class="paramname">noiseFormat</td><td>how noise parameters are stored </td></tr>
    <tr><td class="paramname">kernelFunctionType</td><td>whether to wrap the noise model in a robust kernel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>graph and initial values </dd></dl>

</div>
</div>
<a id="a79f6cde1c018ea0f4ca3c7fc83123a14" name="a79f6cde1c018ea0f4ca3c7fc83123a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f6cde1c018ea0f4ca3c7fc83123a14">&#9670;&nbsp;</a></span>load2D() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01596.html#abcc5d1ec05ddc954d5de28929acabbdf">GraphAndValues</a> gtsam::load2D </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; std::string, <a class="el" href="a01596.html#ab6e5a4884342656e0837ef07008ec03f">SharedNoiseModel</a> &gt;&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxIndex</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addNoise</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>smart</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01596.html#a90552b70a2da9c74595cae4b05c2ce18">NoiseFormat</a>&#160;</td>
          <td class="paramname"><em>noiseFormat</em> = <code><a class="el" href="a01596.html#a90552b70a2da9c74595cae4b05c2ce18a2f9067b8f5bd2d0dd38c49326a4c070e">NoiseFormatAUTO</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01596.html#a8be373f34edc0a9d28b1bfab5dd62ba0">KernelFunctionType</a>&#160;</td>
          <td class="paramname"><em>kernelFunctionType</em> = <code>KernelFunctionTypeNONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load TORO 2D Graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataset/model</td><td>pair as constructed by [dataset] </td></tr>
    <tr><td class="paramname">maxIndex</td><td>if non-zero cut out vertices &gt;= maxIndex </td></tr>
    <tr><td class="paramname">addNoise</td><td>add noise to the edges </td></tr>
    <tr><td class="paramname">smart</td><td>try to reduce complexity of covariance to cheapest model </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f8d49b13ccc0e007a5e7572286d5854" name="a6f8d49b13ccc0e007a5e7572286d5854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8d49b13ccc0e007a5e7572286d5854">&#9670;&nbsp;</a></span>load2D() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a01596.html#abcc5d1ec05ddc954d5de28929acabbdf">GraphAndValues</a> gtsam::load2D </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; std::string, <a class="el" href="a01596.html#ab6e5a4884342656e0837ef07008ec03f">SharedNoiseModel</a> &gt;&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxIndex</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addNoise</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>smart</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01596.html#a90552b70a2da9c74595cae4b05c2ce18">NoiseFormat</a>&#160;</td>
          <td class="paramname"><em>noiseFormat</em> = <code><a class="el" href="a01596.html#a90552b70a2da9c74595cae4b05c2ce18a2f9067b8f5bd2d0dd38c49326a4c070e">NoiseFormatAUTO</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01596.html#a8be373f34edc0a9d28b1bfab5dd62ba0">KernelFunctionType</a>&#160;</td>
          <td class="paramname"><em>kernelFunctionType</em> = <code>KernelFunctionTypeNONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load TORO 2D Graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataset/model</td><td>pair as constructed by [dataset] </td></tr>
    <tr><td class="paramname">maxIndex</td><td>if non-zero cut out vertices &gt;= maxIndex </td></tr>
    <tr><td class="paramname">addNoise</td><td>add noise to the edges </td></tr>
    <tr><td class="paramname">smart</td><td>try to reduce complexity of covariance to cheapest model </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc118b53bf98ad0d0a33bdc107fbefc8" name="abc118b53bf98ad0d0a33bdc107fbefc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc118b53bf98ad0d0a33bdc107fbefc8">&#9670;&nbsp;</a></span>load2D_robust()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a01596.html#abcc5d1ec05ddc954d5de28929acabbdf">GraphAndValues</a> gtsam::load2D_robust </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const noiseModel::Base::shared_ptr &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="a01583.html#_deprecated000022">Deprecated:</a></b></dt><dd>load2D now allows for arbitrary models and wrapping a robust kernel </dd></dl>

</div>
</div>
<a id="a5c6ccec4a3ea452361c0956766bccef5" name="a5c6ccec4a3ea452361c0956766bccef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c6ccec4a3ea452361c0956766bccef5">&#9670;&nbsp;</a></span>logmap_default()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector gtsam::logmap_default </td>
          <td>(</td>
          <td class="paramtype">const Class &amp;&#160;</td>
          <td class="paramname"><em>l0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Class &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Log map centered at l0, s.t. </p>
<p >exp(l0,log(l0,lp)) = lp </p>

</div>
</div>
<a id="abcb9ece2bd206193ac40f118f1815c0e" name="abcb9ece2bd206193ac40f118f1815c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcb9ece2bd206193ac40f118f1815c0e">&#9670;&nbsp;</a></span>make_shared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01596.html#a47e06cd29f4e8a20a8a7842e4045845f">gtsam::enable_if_t</a>&lt; <a class="el" href="a02728.html">needs_eigen_aligned_allocator</a>&lt; T &gt;::value, boost::shared_ptr&lt; T &gt; &gt; gtsam::make_shared </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add our own <code>make_shared</code> as a layer of wrapping on <code>boost::make_shared</code> This solves the problem with the stock <code>make_shared</code> that custom alignment is not respected, causing SEGFAULTs at runtime, which is notoriously hard to debug. </p>
<h1><a class="anchor" id="autotoc_md0"></a>
Explanation</h1>
<p >The template <code><a class="el" href="a02728.html" title="A SFINAE trait to mark classes that need special alignment.">needs_eigen_aligned_allocator</a>&lt;T&gt;::value</code> will evaluate to <code>std::true_type</code> if the type alias <code>_eigen_aligned_allocator_trait = void</code> is present in a class, which is automatically added by the <code>GTSAM_MAKE_ALIGNED_OPERATOR_NEW</code> macro.</p>
<p >This function declaration will only be taken when the above condition is true, so if some object does not need to be aligned, <code><a class="el" href="a01596.html#abcb9ece2bd206193ac40f118f1815c0e" title="Add our own make_shared as a layer of wrapping on boost::make_shared This solves the problem with the...">gtsam::make_shared</a></code> will fall back to the next definition, which is a simple wrapper for <code>boost::make_shared</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of object being constructed </td></tr>
    <tr><td class="paramname">Args</td><td>Type of the arguments of the constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments of the constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The object created as a boost::shared_ptr&lt;T&gt; </dd></dl>

</div>
</div>
<a id="a9d2a0b16c9f78f20fc78fa39c7426242" name="a9d2a0b16c9f78f20fc78fa39c7426242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2a0b16c9f78f20fc78fa39c7426242">&#9670;&nbsp;</a></span>MakeFunctorizedFactor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R , typename FUNC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a04284.html">FunctorizedFactor</a>&lt; R, T &gt; gtsam::MakeFunctorizedFactor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const R &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01596.html#ab6e5a4884342656e0837ef07008ec03f">SharedNoiseModel</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FUNC&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to create a functorized factor. </p>
<p >Uses function template deduction to identify return type and functor type, so template list only needs the functor argument type. </p>

</div>
</div>
<a id="a313f0e290f370cff0b7e25024d1b8c6d" name="a313f0e290f370cff0b7e25024d1b8c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313f0e290f370cff0b7e25024d1b8c6d">&#9670;&nbsp;</a></span>MakeFunctorizedFactor2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename FUNC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a04292.html">FunctorizedFactor2</a>&lt; R, T1, T2 &gt; gtsam::MakeFunctorizedFactor2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a>&#160;</td>
          <td class="paramname"><em>key1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a>&#160;</td>
          <td class="paramname"><em>key2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const R &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01596.html#ab6e5a4884342656e0837ef07008ec03f">SharedNoiseModel</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FUNC&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to create a functorized factor. </p>
<p >Uses function template deduction to identify return type and functor type, so template list only needs the functor argument type. </p>

</div>
</div>
<a id="a9be309f741b77e5406429e41f666aa5a" name="a9be309f741b77e5406429e41f666aa5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be309f741b77e5406429e41f666aa5a">&#9670;&nbsp;</a></span>maxKey()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROBLEM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a> gtsam::maxKey </td>
          <td>(</td>
          <td class="paramtype">const PROBLEM &amp;&#160;</td>
          <td class="paramname"><em>problem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the max key in a problem. </p>
<p >Useful to determine unique keys for additional slack variables </p>

</div>
</div>
<a id="ae9a7dceb0a85c356062b55f6939b1419" name="ae9a7dceb0a85c356062b55f6939b1419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a7dceb0a85c356062b55f6939b1419">&#9670;&nbsp;</a></span>mrsymbol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a> gtsam::mrsymbol </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a symbol key from a character, label and index, i.e. </p>
<p >xA5. </p>

</div>
</div>
<a id="afc19854e0bfc1acadb00ff00a043cc17" name="afc19854e0bfc1acadb00ff00a043cc17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc19854e0bfc1acadb00ff00a043cc17">&#9670;&nbsp;</a></span>nonlinearConjugateGradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S , class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::tuple&lt; V, int &gt; gtsam::nonlinearConjugateGradient </td>
          <td>(</td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a04496.html">NonlinearOptimizerParams</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>singleIteration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>gradientDescent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implement the nonlinear conjugate gradient method using the Polak-Ribiere formula suggested in <a href="http://en.wikipedia.org/wiki/Nonlinear_conjugate_gradient_method">http://en.wikipedia.org/wiki/Nonlinear_conjugate_gradient_method</a>. </p>
<p >The S (system) class requires three member functions: error(state), gradient(state) and advance(state, step-size, direction). The V class denotes the state or the solution.</p>
<p >The last parameter is a switch between gradient-descent and conjugate gradient </p>

</div>
</div>
<a id="a581a9f8db043590096fbac682b8f6a93" name="a581a9f8db043590096fbac682b8f6a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a581a9f8db043590096fbac682b8f6a93">&#9670;&nbsp;</a></span>numericalDerivative11()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X , int N = traits&lt;X&gt;::dimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X &gt;::type gtsam::numericalDerivative11 </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; Y(const X &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>New-style numerical derivatives using manifold_traits. </p>
<p >Computes numerical derivative in argument 1 of unary function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>unary function yielding m-vector </td></tr>
    <tr><td class="paramname">x</td><td>n-dimensional value at which to evaluate h </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative Class Y is the output argument Class X is the input argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">int</td><td>N is the dimension of the X input value if variable dimension type but known at test time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing </dd></dl>

</div>
</div>
<a id="a157eb3b44dd4e38bbd66f3cc68a20e43" name="a157eb3b44dd4e38bbd66f3cc68a20e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a157eb3b44dd4e38bbd66f3cc68a20e43">&#9670;&nbsp;</a></span>numericalDerivative21()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X1 , class X2 , int N = traits&lt;X1&gt;::dimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X1 &gt;::type gtsam::numericalDerivative21 </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; Y(const X1 &amp;, const X2 &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 1 of binary function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>binary function yielding m-vector </td></tr>
    <tr><td class="paramname">x1</td><td>n-dimensional first argument value </td></tr>
    <tr><td class="paramname">x2</td><td>second argument value </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">int</td><td>N is the dimension of the X1 input value if variable dimension type but known at test time </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b0db4ac5f279b12fc91fab4cb40b1bf" name="a5b0db4ac5f279b12fc91fab4cb40b1bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b0db4ac5f279b12fc91fab4cb40b1bf">&#9670;&nbsp;</a></span>numericalDerivative22()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X1 , class X2 , int N = traits&lt;X2&gt;::dimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X2 &gt;::type gtsam::numericalDerivative22 </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; Y(const X1 &amp;, const X2 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 2 of binary function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>binary function yielding m-vector </td></tr>
    <tr><td class="paramname">x1</td><td>first argument value </td></tr>
    <tr><td class="paramname">x2</td><td>n-dimensional second argument value </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">int</td><td>N is the dimension of the X2 input value if variable dimension type but known at test time </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8f0264edaf78d503809c1e3152340ee" name="aa8f0264edaf78d503809c1e3152340ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f0264edaf78d503809c1e3152340ee">&#9670;&nbsp;</a></span>numericalDerivative31()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X1 , class X2 , class X3 , int N = traits&lt;X1&gt;::dimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X1 &gt;::type gtsam::numericalDerivative31 </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 1 of ternary function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>ternary function yielding m-vector </td></tr>
    <tr><td class="paramname">x1</td><td>n-dimensional first argument value </td></tr>
    <tr><td class="paramname">x2</td><td>second argument value </td></tr>
    <tr><td class="paramname">x3</td><td>third argument value </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing All classes Y,X1,X2,X3 need dim, expmap, logmap </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">int</td><td>N is the dimension of the X1 input value if variable dimension type but known at test time </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfbadc0ab0cd9386205b2737c5d0b727" name="acfbadc0ab0cd9386205b2737c5d0b727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfbadc0ab0cd9386205b2737c5d0b727">&#9670;&nbsp;</a></span>numericalDerivative32()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X1 , class X2 , class X3 , int N = traits&lt;X2&gt;::dimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X2 &gt;::type gtsam::numericalDerivative32 </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 2 of ternary function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>ternary function yielding m-vector </td></tr>
    <tr><td class="paramname">x1</td><td>n-dimensional first argument value </td></tr>
    <tr><td class="paramname">x2</td><td>second argument value </td></tr>
    <tr><td class="paramname">x3</td><td>third argument value </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing All classes Y,X1,X2,X3 need dim, expmap, logmap </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">int</td><td>N is the dimension of the X2 input value if variable dimension type but known at test time </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a526a422ea611724345affed8b71d9bac" name="a526a422ea611724345affed8b71d9bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526a422ea611724345affed8b71d9bac">&#9670;&nbsp;</a></span>numericalDerivative33()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X1 , class X2 , class X3 , int N = traits&lt;X3&gt;::dimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X3 &gt;::type gtsam::numericalDerivative33 </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 3 of ternary function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>ternary function yielding m-vector </td></tr>
    <tr><td class="paramname">x1</td><td>n-dimensional first argument value </td></tr>
    <tr><td class="paramname">x2</td><td>second argument value </td></tr>
    <tr><td class="paramname">x3</td><td>third argument value </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing All classes Y,X1,X2,X3 need dim, expmap, logmap </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">int</td><td>N is the dimension of the X3 input value if variable dimension type but known at test time </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b0937e08e79604ee6ab10fca6ffe65e" name="a3b0937e08e79604ee6ab10fca6ffe65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0937e08e79604ee6ab10fca6ffe65e">&#9670;&nbsp;</a></span>numericalDerivative41()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X1 , class X2 , class X3 , class X4 , int N = traits&lt;X1&gt;::dimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X1 &gt;::type gtsam::numericalDerivative41 </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X4 &amp;&#160;</td>
          <td class="paramname"><em>x4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 1 of 4-argument function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>quartic function yielding m-vector </td></tr>
    <tr><td class="paramname">x1</td><td>n-dimensional first argument value </td></tr>
    <tr><td class="paramname">x2</td><td>second argument value </td></tr>
    <tr><td class="paramname">x3</td><td>third argument value </td></tr>
    <tr><td class="paramname">x4</td><td>fourth argument value </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">int</td><td>N is the dimension of the X1 input value if variable dimension type but known at test time </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af40f61e8eff01acdb028ad33b8f3529b" name="af40f61e8eff01acdb028ad33b8f3529b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40f61e8eff01acdb028ad33b8f3529b">&#9670;&nbsp;</a></span>numericalDerivative42()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X1 , class X2 , class X3 , class X4 , int N = traits&lt;X2&gt;::dimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X2 &gt;::type gtsam::numericalDerivative42 </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X4 &amp;&#160;</td>
          <td class="paramname"><em>x4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 2 of 4-argument function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>quartic function yielding m-vector </td></tr>
    <tr><td class="paramname">x1</td><td>first argument value </td></tr>
    <tr><td class="paramname">x2</td><td>n-dimensional second argument value </td></tr>
    <tr><td class="paramname">x3</td><td>third argument value </td></tr>
    <tr><td class="paramname">x4</td><td>fourth argument value </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">int</td><td>N is the dimension of the X2 input value if variable dimension type but known at test time </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6846b5cc84c1d5a54a436121b27057e0" name="a6846b5cc84c1d5a54a436121b27057e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6846b5cc84c1d5a54a436121b27057e0">&#9670;&nbsp;</a></span>numericalDerivative43()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X1 , class X2 , class X3 , class X4 , int N = traits&lt;X3&gt;::dimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X3 &gt;::type gtsam::numericalDerivative43 </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X4 &amp;&#160;</td>
          <td class="paramname"><em>x4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 3 of 4-argument function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>quartic function yielding m-vector </td></tr>
    <tr><td class="paramname">x1</td><td>first argument value </td></tr>
    <tr><td class="paramname">x2</td><td>second argument value </td></tr>
    <tr><td class="paramname">x3</td><td>n-dimensional third argument value </td></tr>
    <tr><td class="paramname">x4</td><td>fourth argument value </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">int</td><td>N is the dimension of the X3 input value if variable dimension type but known at test time </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8061b20199f839b115512d95d058fcbf" name="a8061b20199f839b115512d95d058fcbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8061b20199f839b115512d95d058fcbf">&#9670;&nbsp;</a></span>numericalDerivative44()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X1 , class X2 , class X3 , class X4 , int N = traits&lt;X4&gt;::dimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X4 &gt;::type gtsam::numericalDerivative44 </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X4 &amp;&#160;</td>
          <td class="paramname"><em>x4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 4 of 4-argument function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>quartic function yielding m-vector </td></tr>
    <tr><td class="paramname">x1</td><td>first argument value </td></tr>
    <tr><td class="paramname">x2</td><td>second argument value </td></tr>
    <tr><td class="paramname">x3</td><td>third argument value </td></tr>
    <tr><td class="paramname">x4</td><td>n-dimensional fourth argument value </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">int</td><td>N is the dimension of the X4 input value if variable dimension type but known at test time </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a272af6f7139b76d085279060646e32d1" name="a272af6f7139b76d085279060646e32d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272af6f7139b76d085279060646e32d1">&#9670;&nbsp;</a></span>numericalDerivative51()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 , int N = traits&lt;X1&gt;::dimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X1 &gt;::type gtsam::numericalDerivative51 </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X4 &amp;&#160;</td>
          <td class="paramname"><em>x4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X5 &amp;&#160;</td>
          <td class="paramname"><em>x5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 1 of 5-argument function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>quintic function yielding m-vector </td></tr>
    <tr><td class="paramname">x1</td><td>n-dimensional first argument value </td></tr>
    <tr><td class="paramname">x2</td><td>second argument value </td></tr>
    <tr><td class="paramname">x3</td><td>third argument value </td></tr>
    <tr><td class="paramname">x4</td><td>fourth argument value </td></tr>
    <tr><td class="paramname">x5</td><td>fifth argument value </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">int</td><td>N is the dimension of the X1 input value if variable dimension type but known at test time </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a722e98babba795ce480f89527b572251" name="a722e98babba795ce480f89527b572251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722e98babba795ce480f89527b572251">&#9670;&nbsp;</a></span>numericalDerivative52()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 , int N = traits&lt;X2&gt;::dimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X2 &gt;::type gtsam::numericalDerivative52 </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X4 &amp;&#160;</td>
          <td class="paramname"><em>x4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X5 &amp;&#160;</td>
          <td class="paramname"><em>x5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 2 of 5-argument function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>quintic function yielding m-vector </td></tr>
    <tr><td class="paramname">x1</td><td>n-dimensional first argument value </td></tr>
    <tr><td class="paramname">x2</td><td>second argument value </td></tr>
    <tr><td class="paramname">x3</td><td>third argument value </td></tr>
    <tr><td class="paramname">x4</td><td>fourth argument value </td></tr>
    <tr><td class="paramname">x5</td><td>fifth argument value </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">int</td><td>N is the dimension of the X2 input value if variable dimension type but known at test time </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc2f741132522a6ce57d544a27a95855" name="acc2f741132522a6ce57d544a27a95855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2f741132522a6ce57d544a27a95855">&#9670;&nbsp;</a></span>numericalDerivative53()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 , int N = traits&lt;X3&gt;::dimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X3 &gt;::type gtsam::numericalDerivative53 </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X4 &amp;&#160;</td>
          <td class="paramname"><em>x4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X5 &amp;&#160;</td>
          <td class="paramname"><em>x5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 3 of 5-argument function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>quintic function yielding m-vector </td></tr>
    <tr><td class="paramname">x1</td><td>n-dimensional first argument value </td></tr>
    <tr><td class="paramname">x2</td><td>second argument value </td></tr>
    <tr><td class="paramname">x3</td><td>third argument value </td></tr>
    <tr><td class="paramname">x4</td><td>fourth argument value </td></tr>
    <tr><td class="paramname">x5</td><td>fifth argument value </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">int</td><td>N is the dimension of the X3 input value if variable dimension type but known at test time </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cf5181fc7bca1ef6a1070959de7b975" name="a2cf5181fc7bca1ef6a1070959de7b975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf5181fc7bca1ef6a1070959de7b975">&#9670;&nbsp;</a></span>numericalDerivative54()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 , int N = traits&lt;X4&gt;::dimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X4 &gt;::type gtsam::numericalDerivative54 </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X4 &amp;&#160;</td>
          <td class="paramname"><em>x4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X5 &amp;&#160;</td>
          <td class="paramname"><em>x5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 4 of 5-argument function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>quintic function yielding m-vector </td></tr>
    <tr><td class="paramname">x1</td><td>n-dimensional first argument value </td></tr>
    <tr><td class="paramname">x2</td><td>second argument value </td></tr>
    <tr><td class="paramname">x3</td><td>third argument value </td></tr>
    <tr><td class="paramname">x4</td><td>fourth argument value </td></tr>
    <tr><td class="paramname">x5</td><td>fifth argument value </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">int</td><td>N is the dimension of the X4 input value if variable dimension type but known at test time </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ca42a2fc87373c005299f3087995a97" name="a5ca42a2fc87373c005299f3087995a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca42a2fc87373c005299f3087995a97">&#9670;&nbsp;</a></span>numericalDerivative55()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 , int N = traits&lt;X5&gt;::dimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X5 &gt;::type gtsam::numericalDerivative55 </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X4 &amp;&#160;</td>
          <td class="paramname"><em>x4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X5 &amp;&#160;</td>
          <td class="paramname"><em>x5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 5 of 5-argument function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>quintic function yielding m-vector </td></tr>
    <tr><td class="paramname">x1</td><td>n-dimensional first argument value </td></tr>
    <tr><td class="paramname">x2</td><td>second argument value </td></tr>
    <tr><td class="paramname">x3</td><td>third argument value </td></tr>
    <tr><td class="paramname">x4</td><td>fourth argument value </td></tr>
    <tr><td class="paramname">x5</td><td>fifth argument value </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">int</td><td>N is the dimension of the X5 input value if variable dimension type but known at test time </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ca8a22de666bc39015da34f150df748" name="a0ca8a22de666bc39015da34f150df748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca8a22de666bc39015da34f150df748">&#9670;&nbsp;</a></span>numericalDerivative61()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 , class X6 , int N = traits&lt;X1&gt;::dimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X1 &gt;::type gtsam::numericalDerivative61 </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;, const X6 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X4 &amp;&#160;</td>
          <td class="paramname"><em>x4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X5 &amp;&#160;</td>
          <td class="paramname"><em>x5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X6 &amp;&#160;</td>
          <td class="paramname"><em>x6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 1 of 6-argument function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>quintic function yielding m-vector </td></tr>
    <tr><td class="paramname">x1</td><td>n-dimensional first argument value </td></tr>
    <tr><td class="paramname">x2</td><td>second argument value </td></tr>
    <tr><td class="paramname">x3</td><td>third argument value </td></tr>
    <tr><td class="paramname">x4</td><td>fourth argument value </td></tr>
    <tr><td class="paramname">x5</td><td>fifth argument value </td></tr>
    <tr><td class="paramname">x6</td><td>sixth argument value </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">int</td><td>N is the dimension of the X1 input value if variable dimension type but known at test time </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac224e2384e41171181b2dbc0f700cdc1" name="ac224e2384e41171181b2dbc0f700cdc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac224e2384e41171181b2dbc0f700cdc1">&#9670;&nbsp;</a></span>numericalDerivative62()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 , class X6 , int N = traits&lt;X2&gt;::dimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X2 &gt;::type gtsam::numericalDerivative62 </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;, const X6 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X4 &amp;&#160;</td>
          <td class="paramname"><em>x4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X5 &amp;&#160;</td>
          <td class="paramname"><em>x5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X6 &amp;&#160;</td>
          <td class="paramname"><em>x6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 2 of 6-argument function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>quintic function yielding m-vector </td></tr>
    <tr><td class="paramname">x1</td><td>n-dimensional first argument value </td></tr>
    <tr><td class="paramname">x2</td><td>second argument value </td></tr>
    <tr><td class="paramname">x3</td><td>third argument value </td></tr>
    <tr><td class="paramname">x4</td><td>fourth argument value </td></tr>
    <tr><td class="paramname">x5</td><td>fifth argument value </td></tr>
    <tr><td class="paramname">x6</td><td>sixth argument value </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">int</td><td>N is the dimension of the X2 input value if variable dimension type but known at test time </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15c46aa999886d4ccd06ab73fc02db31" name="a15c46aa999886d4ccd06ab73fc02db31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c46aa999886d4ccd06ab73fc02db31">&#9670;&nbsp;</a></span>numericalDerivative63()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 , class X6 , int N = traits&lt;X3&gt;::dimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X3 &gt;::type gtsam::numericalDerivative63 </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;, const X6 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X4 &amp;&#160;</td>
          <td class="paramname"><em>x4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X5 &amp;&#160;</td>
          <td class="paramname"><em>x5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X6 &amp;&#160;</td>
          <td class="paramname"><em>x6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 3 of 6-argument function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>quintic function yielding m-vector </td></tr>
    <tr><td class="paramname">x1</td><td>n-dimensional first argument value </td></tr>
    <tr><td class="paramname">x2</td><td>second argument value </td></tr>
    <tr><td class="paramname">x3</td><td>third argument value </td></tr>
    <tr><td class="paramname">x4</td><td>fourth argument value </td></tr>
    <tr><td class="paramname">x5</td><td>fifth argument value </td></tr>
    <tr><td class="paramname">x6</td><td>sixth argument value </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">int</td><td>N is the dimension of the X3 input value if variable dimension type but known at test time </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3eb3fef9c77920dfd9496e71a0bcf669" name="a3eb3fef9c77920dfd9496e71a0bcf669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb3fef9c77920dfd9496e71a0bcf669">&#9670;&nbsp;</a></span>numericalDerivative64()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 , class X6 , int N = traits&lt;X4&gt;::dimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X4 &gt;::type gtsam::numericalDerivative64 </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;, const X6 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X4 &amp;&#160;</td>
          <td class="paramname"><em>x4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X5 &amp;&#160;</td>
          <td class="paramname"><em>x5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X6 &amp;&#160;</td>
          <td class="paramname"><em>x6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 4 of 6-argument function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>quintic function yielding m-vector </td></tr>
    <tr><td class="paramname">x1</td><td>n-dimensional first argument value </td></tr>
    <tr><td class="paramname">x2</td><td>second argument value </td></tr>
    <tr><td class="paramname">x3</td><td>third argument value </td></tr>
    <tr><td class="paramname">x4</td><td>fourth argument value </td></tr>
    <tr><td class="paramname">x5</td><td>fifth argument value </td></tr>
    <tr><td class="paramname">x6</td><td>sixth argument value </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">int</td><td>N is the dimension of the X4 input value if variable dimension type but known at test time </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a799c83517a20a8e0b0b014f26b50f660" name="a799c83517a20a8e0b0b014f26b50f660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a799c83517a20a8e0b0b014f26b50f660">&#9670;&nbsp;</a></span>numericalDerivative65()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 , class X6 , int N = traits&lt;X5&gt;::dimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X5 &gt;::type gtsam::numericalDerivative65 </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;, const X6 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X4 &amp;&#160;</td>
          <td class="paramname"><em>x4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X5 &amp;&#160;</td>
          <td class="paramname"><em>x5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X6 &amp;&#160;</td>
          <td class="paramname"><em>x6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 5 of 6-argument function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>quintic function yielding m-vector </td></tr>
    <tr><td class="paramname">x1</td><td>n-dimensional first argument value </td></tr>
    <tr><td class="paramname">x2</td><td>second argument value </td></tr>
    <tr><td class="paramname">x3</td><td>third argument value </td></tr>
    <tr><td class="paramname">x4</td><td>fourth argument value </td></tr>
    <tr><td class="paramname">x5</td><td>fifth argument value </td></tr>
    <tr><td class="paramname">x6</td><td>sixth argument value </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">int</td><td>N is the dimension of the X5 input value if variable dimension type but known at test time </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e010b7f436124b9b421ba7dc438d987" name="a4e010b7f436124b9b421ba7dc438d987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e010b7f436124b9b421ba7dc438d987">&#9670;&nbsp;</a></span>numericalDerivative66()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X1 , class X2 , class X3 , class X4 , class X5 , class X6 , int N = traits&lt;X6&gt;::dimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; Y, X6 &gt;::type gtsam::numericalDerivative66 </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;, const X4 &amp;, const X5 &amp;, const X6 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X4 &amp;&#160;</td>
          <td class="paramname"><em>x4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X5 &amp;&#160;</td>
          <td class="paramname"><em>x5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X6 &amp;&#160;</td>
          <td class="paramname"><em>x6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 6 of 6-argument function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>quintic function yielding m-vector </td></tr>
    <tr><td class="paramname">x1</td><td>n-dimensional first argument value </td></tr>
    <tr><td class="paramname">x2</td><td>second argument value </td></tr>
    <tr><td class="paramname">x3</td><td>third argument value </td></tr>
    <tr><td class="paramname">x4</td><td>fourth argument value </td></tr>
    <tr><td class="paramname">x5</td><td>fifth argument value </td></tr>
    <tr><td class="paramname">x6</td><td>sixth argument value </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">int</td><td>N is the dimension of the X6 input value if variable dimension type but known at test time </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd8862271510196ec4e2d894f623942d" name="afd8862271510196ec4e2d894f623942d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd8862271510196ec4e2d894f623942d">&#9670;&nbsp;</a></span>numericalGradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , int N = traits&lt;X&gt;::dimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; double, N, 1 &gt; gtsam::numericalGradient </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; double(const X &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Numerically compute gradient of scalar function. </p>
<dl class="section return"><dt>Returns</dt><dd>n-dimensional gradient computed via central differencing Class X is the input argument The class X needs to have dim, expmap, logmap int N is the dimension of the X input value if variable dimension type but known at test time </dd></dl>

</div>
</div>
<a id="a11011d8e9bd69e486c9752875f710c18" name="a11011d8e9bd69e486c9752875f710c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11011d8e9bd69e486c9752875f710c18">&#9670;&nbsp;</a></span>numericalHessian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02608.html">internal::FixedSizeMatrix</a>&lt; X, X &gt;::type gtsam::numericalHessian </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; double(const X &amp;)&gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute numerical Hessian matrix. </p>
<p >Requires a single-argument Lie-&gt;scalar function. This is implemented simply as the derivative of the gradient. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function taking a Lie object as input and returning a scalar </td></tr>
    <tr><td class="paramname">x</td><td>The center point for computing the Hessian </td></tr>
    <tr><td class="paramname">delta</td><td>The numerical derivative step size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n*n Hessian matrix computed via central differencing </dd></dl>

</div>
</div>
<a id="ade6eca65dc0168a65f641961ca97924c" name="ade6eca65dc0168a65f641961ca97924c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade6eca65dc0168a65f641961ca97924c">&#9670;&nbsp;</a></span>openGL2gtsam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a03288.html">Pose3</a> gtsam::openGL2gtsam </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a03336.html">Rot3</a> &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts an openGL camera pose to an GTSAM camera pose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>rotation in openGL </td></tr>
    <tr><td class="paramname">tx</td><td>x component of the translation in openGL </td></tr>
    <tr><td class="paramname">ty</td><td>y component of the translation in openGL </td></tr>
    <tr><td class="paramname">tz</td><td>z component of the translation in openGL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a03288.html">Pose3</a> in GTSAM format </dd></dl>

</div>
</div>
<a id="a3db519caa1b7e43412c9a7e13acf8329" name="a3db519caa1b7e43412c9a7e13acf8329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db519caa1b7e43412c9a7e13acf8329">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a04240.html">Expression</a>&lt; T &gt; gtsam::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a04240.html">Expression</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>expression1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a04240.html">Expression</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>expression2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a product expression, assumes T::compose(T) -&gt; T. </p>
<p >Construct a product expression, assumes T::compose(T) -&gt; T Example: Expression&lt;Point2&gt; a(0), b(1), c = a*b;. </p>

</div>
</div>
<a id="a7d85957bab2d18cf56ab9aaf95a106de" name="a7d85957bab2d18cf56ab9aaf95a106de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d85957bab2d18cf56ab9aaf95a106de">&#9670;&nbsp;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::istream &amp; gtsam::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>inputStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>destinationMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a matrix from an input stream, such as a file. </p>
<p >Entries can be either tab-, space-, or comma-separated, similar to the format read by the MATLAB dlmread command. </p>

</div>
</div>
<a id="a4b0057879b0c5f323185452b0d1a4232" name="a4b0057879b0c5f323185452b0d1a4232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b0057879b0c5f323185452b0d1a4232">&#9670;&nbsp;</a></span>optimize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a> gtsam::optimize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a04480.html">NonlinearFactorGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a04560.html">Values</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a>&#160;</td>
          <td class="paramname"><em>landmarkKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimize for triangulation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>nonlinear factors for projection </td></tr>
    <tr><td class="paramname">values</td><td>initial values </td></tr>
    <tr><td class="paramname">landmarkKey</td><td>to refer to landmark </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>refined Point3 </dd></dl>

</div>
</div>
<a id="a2b0857edd76f8d63eeee0ce9944e28d4" name="a2b0857edd76f8d63eeee0ce9944e28d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0857edd76f8d63eeee0ce9944e28d4">&#9670;&nbsp;</a></span>optimizeWildfire()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t gtsam::optimizeWildfire </td>
          <td>(</td>
          <td class="paramtype">const ISAM2Clique::shared_ptr &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a02488.html">KeySet</a> &amp;&#160;</td>
          <td class="paramname"><em>replaced</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a04016.html">VectorValues</a> *&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimize the <a class="el" href="a03496.html">BayesTree</a>, starting from the root. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>The maximum change against the PREVIOUS delta for non-replaced variables that can be ignored, ie. the old delta entry is kept and recursive backsubstitution might eventually stop if none of the changed variables are contained in the subtree. </td></tr>
    <tr><td class="paramname">replaced</td><td>Needs to contain all variables that are contained in the top of the Bayes tree that has been redone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of variables that were solved for. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delta</td><td>The current solution, an offset from the linearization point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc8bb9db0893652e8b5e7b47782ec990" name="abc8bb9db0893652e8b5e7b47782ec990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8bb9db0893652e8b5e7b47782ec990">&#9670;&nbsp;</a></span>parseEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT boost::optional&lt; IndexedEdge &gt; gtsam::parseEdge </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse TORO/G2O edge "id1 id2 x y yaw". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>input stream </td></tr>
    <tr><td class="paramname">tag</td><td>string parsed from input stream, will only parse if edge type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a2136a163e31faaefe2db498a9b9b43" name="a8a2136a163e31faaefe2db498a9b9b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a2136a163e31faaefe2db498a9b9b43">&#9670;&nbsp;</a></span>parseFactors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::vector&lt; typename <a class="el" href="a04684.html">BetweenFactor</a>&lt; T &gt;::shared_ptr &gt; gtsam::parseFactors </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const noiseModel::Diagonal::shared_ptr &amp;&#160;</td>
          <td class="paramname"><em>model</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse BetweenFactors in a line-based text format (like g2o) into a vector of shared pointers. </p>
<p >Instantiated in .cpp T equal to <a class="el" href="a03264.html">Pose2</a> and <a class="el" href="a03288.html">Pose3</a>. </p>

</div>
</div>
<a id="a6eb4817b97658f00e426b753c52361ed" name="a6eb4817b97658f00e426b753c52361ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb4817b97658f00e426b753c52361ed">&#9670;&nbsp;</a></span>parseMeasurements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::vector&lt; <a class="el" href="a04632.html">BinaryMeasurement</a>&lt; T &gt; &gt; gtsam::parseMeasurements </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const noiseModel::Diagonal::shared_ptr &amp;&#160;</td>
          <td class="paramname"><em>model</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse binary measurements in a line-based text format (like g2o) into a vector. </p>
<p >Instantiated in .cpp for <a class="el" href="a03264.html">Pose2</a>, <a class="el" href="a03320.html">Rot2</a>, <a class="el" href="a03288.html">Pose3</a>, and <a class="el" href="a03336.html">Rot3</a>. The rotation versions parse poses and extract only the rotation part, using the marginal covariance as noise model. </p>

</div>
</div>
<a id="a683ab6a83b5b3e508e734a7089986838" name="a683ab6a83b5b3e508e734a7089986838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a683ab6a83b5b3e508e734a7089986838">&#9670;&nbsp;</a></span>parseVariables()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::map&lt; size_t, T &gt; gtsam::parseVariables </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse variables in a line-based text format (like g2o) into a map. </p>
<p >Instantiated in .cpp <a class="el" href="a03264.html">Pose2</a>, Point2, <a class="el" href="a03288.html">Pose3</a>, and Point3. Note the map keys are integer indices, <em>not</em> gtsam::Keys. This is is different below where landmarks will use L(index) symbols. </p>

</div>
</div>
<a id="a961e0398bbfc2504c62fdaad70472418" name="a961e0398bbfc2504c62fdaad70472418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961e0398bbfc2504c62fdaad70472418">&#9670;&nbsp;</a></span>parseVertexLandmark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT boost::optional&lt; IndexedLandmark &gt; gtsam::parseVertexLandmark </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse G2O landmark vertex "id x y". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>input stream </td></tr>
    <tr><td class="paramname">tag</td><td>string parsed from input stream, will only parse if vertex type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfc0157e4790e3b03dc601d3e86c684d" name="abfc0157e4790e3b03dc601d3e86c684d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc0157e4790e3b03dc601d3e86c684d">&#9670;&nbsp;</a></span>parseVertexPose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT boost::optional&lt; <a class="el" href="a01596.html#a6ab764d13f9aaeafc2dc60763b05ec0e">IndexedPose</a> &gt; gtsam::parseVertexPose </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse TORO/G2O vertex "id x y yaw". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>input stream </td></tr>
    <tr><td class="paramname">tag</td><td>string parsed from input stream, will only parse if vertex type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae67d0d86c4e55b175859967a70b36983" name="ae67d0d86c4e55b175859967a70b36983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67d0d86c4e55b175859967a70b36983">&#9670;&nbsp;</a></span>predecessorMap2Graph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G , class V , class KEY &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::tuple&lt; G, V, std::map&lt; KEY, V &gt; &gt; gtsam::predecessorMap2Graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a03576.html">PredecessorMap</a>&lt; KEY &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build takes a predecessor map, and builds a directed graph corresponding to the tree. </p>
<p >G = Graph type V = Vertex type </p>

</div>
</div>
<a id="ae32c295e2c40c1e85f146a8a6266eaa8" name="ae32c295e2c40c1e85f146a8a6266eaa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae32c295e2c40c1e85f146a8a6266eaa8">&#9670;&nbsp;</a></span>qr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::pair&lt; Matrix, Matrix &gt; gtsam::qr </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Householder QR factorization, Golub &amp; Van Loan p 224, explicit version <br  />
 </p>
<p >QR factorization, inefficient, best use imperative householder below m*n matrix -&gt; m*m Q, m*n R.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>a matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;Q,R&gt; rotation matrix Q, upper triangular R </dd></dl>

</div>
</div>
<a id="a710ec0322f4a2c0883841b58516b7a6a" name="a710ec0322f4a2c0883841b58516b7a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710ec0322f4a2c0883841b58516b7a6a">&#9670;&nbsp;</a></span>readBal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a04736.html">SfmData</a> gtsam::readBal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function parses a "Bundle Adjustment in the Large" (BAL) file and returns the data as a <a class="el" href="a04736.html" title="Define the structure for SfM data.">SfmData</a> structure. </p>
<p >Mainly used by wrapped code. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the BAL file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SfM structure where the data is stored. </dd></dl>

</div>
</div>
<a id="af170fa38edc21cf9c26c2c6937388ec0" name="af170fa38edc21cf9c26c2c6937388ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af170fa38edc21cf9c26c2c6937388ec0">&#9670;&nbsp;</a></span>readBAL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT bool gtsam::readBAL </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a04736.html">SfmData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function parses a "Bundle Adjustment in the Large" (BAL) file and stores the data into a <a class="el" href="a04736.html" title="Define the structure for SfM data.">SfmData</a> structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the BAL file </td></tr>
    <tr><td class="paramname">data</td><td>SfM structure where the data is stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the parsing was successful, false otherwise </dd></dl>

</div>
</div>
<a id="a37c2d071b98678ae281d0b48bee98b30" name="a37c2d071b98678ae281d0b48bee98b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c2d071b98678ae281d0b48bee98b30">&#9670;&nbsp;</a></span>readBundler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT bool gtsam::readBundler </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a04736.html">SfmData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function parses a bundler output file and stores the data into a <a class="el" href="a04736.html" title="Define the structure for SfM data.">SfmData</a> structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the bundler file </td></tr>
    <tr><td class="paramname">data</td><td>SfM structure where the data is stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the parsing was successful, false otherwise </dd></dl>

</div>
</div>
<a id="a71d086efc70f4af31d3c3b00dde4f7c0" name="a71d086efc70f4af31d3c3b00dde4f7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71d086efc70f4af31d3c3b00dde4f7c0">&#9670;&nbsp;</a></span>readG2o()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a01596.html#abcc5d1ec05ddc954d5de28929acabbdf">GraphAndValues</a> gtsam::readG2o </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>g2oFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is3D</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01596.html#a8be373f34edc0a9d28b1bfab5dd62ba0">KernelFunctionType</a>&#160;</td>
          <td class="paramname"><em>kernelFunctionType</em> = <code>KernelFunctionTypeNONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function parses a g2o file and stores the measurements into a <a class="el" href="a04480.html" title="A non-linear factor graph is a graph of non-Gaussian, i.e.">NonlinearFactorGraph</a> and the initial guess in a <a class="el" href="a04560.html" title="A non-templated config holding any types of Manifold-group elements.">Values</a> structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the g2o file\ </td></tr>
    <tr><td class="paramname">is3D</td><td>indicates if the file describes a 2D or 3D problem </td></tr>
    <tr><td class="paramname">kernelFunctionType</td><td>whether to wrap the noise model in a robust kernel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>graph and initial values </dd></dl>

</div>
</div>
<a id="a2754f325c8600303d627d9e8cf1f9949" name="a2754f325c8600303d627d9e8cf1f9949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2754f325c8600303d627d9e8cf1f9949">&#9670;&nbsp;</a></span>row()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MATRIX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const MATRIX::ConstRowXpr gtsam::row </td>
          <td>(</td>
          <td class="paramtype">const MATRIX &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a row view from a matrix that avoids a copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>matrix to extract row from </td></tr>
    <tr><td class="paramname">j</td><td>index of the row </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a const view of the matrix </dd></dl>

</div>
</div>
<a id="a5172b5b6d51bd5348c7e551e1376f60a" name="a5172b5b6d51bd5348c7e551e1376f60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5172b5b6d51bd5348c7e551e1376f60a">&#9670;&nbsp;</a></span>RQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::pair&lt; Matrix3, Vector3 &gt; gtsam::RQ </td>
          <td>(</td>
          <td class="paramtype">const Matrix3 &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02616.html">OptionalJacobian</a>&lt; 3, 9 &gt;&#160;</td>
          <td class="paramname"><em>H</em> = <code>boost::none</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>[RQ] receives a 3 by 3 matrix and returns an upper triangular matrix R and 3 rotation angles corresponding to the rotation matrix Q=Qz'*Qy'*Qx' such that A = R*Q = R*Qz'*Qy'*Qx'. </p>
<p >When A is a rotation matrix, R will be the identity and Q is a yaw-pitch-roll decomposition of A. The implementation uses Givens rotations and is based on Hartley-Zisserman. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>3 by 3 matrix A=RQ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an upper triangular matrix R </dd>
<dd>
a vector [thetax, thetay, thetaz] in radians. </dd></dl>

</div>
</div>
<a id="a9bf40203c6d7820aa6ddf23cdbbd770f" name="a9bf40203c6d7820aa6ddf23cdbbd770f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf40203c6d7820aa6ddf23cdbbd770f">&#9670;&nbsp;</a></span>scal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GTSAM_DEPRECATED gtsam::scal </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>BLAS Level 1 scal: x &lt;- alpha*x. </p>
<dl class="deprecated"><dt><b><a class="el" href="a01583.html#_deprecated000003">Deprecated:</a></b></dt><dd>: use operators instead </dd></dl>

</div>
</div>
<a id="aa5d177a3bf16f9f5acf45ee62c816479" name="aa5d177a3bf16f9f5acf45ee62c816479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d177a3bf16f9f5acf45ee62c816479">&#9670;&nbsp;</a></span>serializeToBinaryStream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gtsam::serializeToBinaryStream </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out_archive_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;data&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >serializes to a stream in binary </p>

</div>
</div>
<a id="a007080ca4741cc3d3d6a209b0ae3fe61" name="a007080ca4741cc3d3d6a209b0ae3fe61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a007080ca4741cc3d3d6a209b0ae3fe61">&#9670;&nbsp;</a></span>serializeToStream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gtsam::serializeToStream </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out_archive_stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >serializes to a stream </p>

</div>
</div>
<a id="ae2e939177cf58b42d7ed4c9856d536c5" name="ae2e939177cf58b42d7ed4c9856d536c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e939177cf58b42d7ed4c9856d536c5">&#9670;&nbsp;</a></span>serializeToXMLStream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gtsam::serializeToXMLStream </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out_archive_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;data&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >serializes to a stream in XML </p>

</div>
</div>
<a id="a97f108d19e52c83c331c55d35b23796e" name="a97f108d19e52c83c331c55d35b23796e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f108d19e52c83c331c55d35b23796e">&#9670;&nbsp;</a></span>skewSymmetric()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix3 gtsam::skewSymmetric </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>wx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>wy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>wz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>skew symmetric matrix returns this: 0 -wz wy wz 0 -wx -wy wx 0 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wx</td><td>3 dimensional vector </td></tr>
    <tr><td class="paramname">wy</td><td></td></tr>
    <tr><td class="paramname">wz</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 3*3 skew symmetric matrix </dd></dl>

</div>
</div>
<a id="ab3749ce0f63e205e55daa615aa1fd74a" name="ab3749ce0f63e205e55daa615aa1fd74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3749ce0f63e205e55daa615aa1fd74a">&#9670;&nbsp;</a></span>splitFactorGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; boost::shared_ptr&lt; <a class="el" href="a03744.html">GaussianFactorGraph</a> &gt;, boost::shared_ptr&lt; <a class="el" href="a03744.html">GaussianFactorGraph</a> &gt; &gt; gtsam::splitFactorGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a03744.html">GaussianFactorGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>factorGraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a03984.html">Subgraph</a> &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the graph into a subgraph and the remaining edges. </p>
<p >Note that the remaining factorgraph has null factors. </p>

</div>
</div>
<a id="a5c82884a356ddd09229a5283aed04df9" name="a5c82884a356ddd09229a5283aed04df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c82884a356ddd09229a5283aed04df9">&#9670;&nbsp;</a></span>stack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Matrix gtsam::stack </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrMatrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a matrix by stacking other matrices Given a set of matrices: A1, A2, A3... </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...</td><td>pointers to matrices to be stacked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>combined matrix [A1; A2; A3] </dd></dl>

</div>
</div>
<a id="aed4b2ca704ddd6530ea70122f883ac88" name="aed4b2ca704ddd6530ea70122f883ac88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4b2ca704ddd6530ea70122f883ac88">&#9670;&nbsp;</a></span>steepestDescent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Vector gtsam::steepestDescent </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a03680.html">ConjugateGradientParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convenience calls using matrices, will create <a class="el" href="a03776.html" title="Helper class encapsulating the combined system |Ax-b_|^2 Needed to run Conjugate Gradients on matrice...">System</a> class internally: </p>
<p >Method of steepest gradients, Matrix version </p>

</div>
</div>
<a id="a9ae1d9fe2ccad044fbb88b5c1d9e035a" name="a9ae1d9fe2ccad044fbb88b5c1d9e035a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae1d9fe2ccad044fbb88b5c1d9e035a">&#9670;&nbsp;</a></span>sub()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MATRIX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Block&lt; const MATRIX &gt; gtsam::sub </td>
          <td>(</td>
          <td class="paramtype">const MATRIX &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>extract submatrix, slice semantics, i.e. </p>
<p >range = [i1,i2[ excluding i2 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>matrix </td></tr>
    <tr><td class="paramname">i1</td><td>first row index </td></tr>
    <tr><td class="paramname">i2</td><td>last row index + 1 </td></tr>
    <tr><td class="paramname">j1</td><td>first col index </td></tr>
    <tr><td class="paramname">j2</td><td>last col index + 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>submatrix A(i1:i2-1,j1:j2-1) </dd></dl>

</div>
</div>
<a id="a8d7e46204d953f64a39445599dbd7eee" name="a8d7e46204d953f64a39445599dbd7eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7e46204d953f64a39445599dbd7eee">&#9670;&nbsp;</a></span>svd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT void gtsam::svd </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SVD computes economy SVD A=U*S*V'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>an m*n matrix </td></tr>
    <tr><td class="paramname">U</td><td>output argument: rotation matrix </td></tr>
    <tr><td class="paramname">S</td><td>output argument: sorted vector of singular values </td></tr>
    <tr><td class="paramname">V</td><td>output argument: rotation matrix if m &gt; n then U*S*V' = (m*n)*(n*n)*(n*n) if m &lt; n then U*S*V' = (m*m)*(m*m)*(m*n) Careful! The dimensions above reflect V', not V, which is n*m if m&lt;n. U is a basis in R^m, V is a basis in R^n You can just pass empty matrices U,V, and vector S, they will be re-allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3bfdb8456463015b2dda092a5805a745" name="a3bfdb8456463015b2dda092a5805a745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bfdb8456463015b2dda092a5805a745">&#9670;&nbsp;</a></span>symbol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a> gtsam::symbol </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a symbol key from a character and index, i.e. </p>
<p >x5. </p>

</div>
</div>
<a id="a8d21728e3da4cf1a96e1b6f87a97da47" name="a8d21728e3da4cf1a96e1b6f87a97da47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d21728e3da4cf1a96e1b6f87a97da47">&#9670;&nbsp;</a></span>topLeft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Matrix3 gtsam::topLeft </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a03396.html">SO4</a> &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02616.html">OptionalJacobian</a>&lt; 9, 6 &gt;&#160;</td>
          <td class="paramname"><em>H</em> = <code>boost::none</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Project to top-left 3*3 matrix. </p>
<p >Note this is <em>not</em> in general \in SO(3). </p>

</div>
</div>
<a id="a80d640f59e5d39a1165069a3841cc5d1" name="a80d640f59e5d39a1165069a3841cc5d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d640f59e5d39a1165069a3841cc5d1">&#9670;&nbsp;</a></span>transform_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">P gtsam::transform_point </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; Matrix &amp; &gt;&#160;</td>
          <td class="paramname"><em>Dtrans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; Matrix &amp; &gt;&#160;</td>
          <td class="paramname"><em>Dglobal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform function that must be specialized specific domains. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is a Transform type </td></tr>
    <tr><td class="paramname">P</td><td>is a point type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3eb48c80bef807e34d7189efdc8875cd" name="a3eb48c80bef807e34d7189efdc8875cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb48c80bef807e34d7189efdc8875cd">&#9670;&nbsp;</a></span>transformTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a03188.html">Line3</a> gtsam::transformTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a03288.html">Pose3</a> &amp;&#160;</td>
          <td class="paramname"><em>wTc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a03188.html">Line3</a> &amp;&#160;</td>
          <td class="paramname"><em>wL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02616.html">OptionalJacobian</a>&lt; 4, 6 &gt;&#160;</td>
          <td class="paramname"><em>Dpose</em> = <code>boost::none</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02616.html">OptionalJacobian</a>&lt; 4, 4 &gt;&#160;</td>
          <td class="paramname"><em>Dline</em> = <code>boost::none</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a line from world to camera frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wTc</td><td>- <a class="el" href="a03288.html">Pose3</a> of camera in world frame </td></tr>
    <tr><td class="paramname">wL</td><td>- <a class="el" href="a03188.html">Line3</a> in world frame </td></tr>
    <tr><td class="paramname">Dpose</td><td>- <a class="el" href="a02616.html" title="OptionalJacobian is an Eigen::Ref like class that can take be constructed using either a fixed size o...">OptionalJacobian</a> of transformed line with respect to p </td></tr>
    <tr><td class="paramname">Dline</td><td>- <a class="el" href="a02616.html" title="OptionalJacobian is an Eigen::Ref like class that can take be constructed using either a fixed size o...">OptionalJacobian</a> of transformed line with respect to l </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed line in camera frame </dd></dl>

</div>
</div>
<a id="aed2918ac0049316bf09f96879efca3b6" name="aed2918ac0049316bf09f96879efca3b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed2918ac0049316bf09f96879efca3b6">&#9670;&nbsp;</a></span>triangulateDLT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a> gtsam::triangulateDLT </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Matrix34, Eigen::aligned_allocator&lt; Matrix34 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point2Vector &amp;&#160;</td>
          <td class="paramname"><em>measurements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rank_tol</em> = <code>1e-9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DLT triangulation: See Hartley and Zisserman, 2nd Ed., page 312. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">projection_matrices</td><td>Projection matrices (K*P^-1) </td></tr>
    <tr><td class="paramname">measurements</td><td>2D measurements </td></tr>
    <tr><td class="paramname">rank_tol</td><td>SVD rank tolerance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Triangulated Point3 </dd></dl>

</div>
</div>
<a id="af378e231b519e8bb1f09f4aa13a38dca" name="af378e231b519e8bb1f09f4aa13a38dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af378e231b519e8bb1f09f4aa13a38dca">&#9670;&nbsp;</a></span>triangulateHomogeneousDLT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Vector4 gtsam::triangulateHomogeneousDLT </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Matrix34, Eigen::aligned_allocator&lt; Matrix34 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point2Vector &amp;&#160;</td>
          <td class="paramname"><em>measurements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rank_tol</em> = <code>1e-9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DLT triangulation: See Hartley and Zisserman, 2nd Ed., page 312. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">projection_matrices</td><td>Projection matrices (K*P^-1) </td></tr>
    <tr><td class="paramname">measurements</td><td>2D measurements </td></tr>
    <tr><td class="paramname">rank_tol</td><td>SVD rank tolerance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Triangulated point, in homogeneous coordinates </dd></dl>

</div>
</div>
<a id="a2fa35400ef37861ce74067b6a38884ba" name="a2fa35400ef37861ce74067b6a38884ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa35400ef37861ce74067b6a38884ba">&#9670;&nbsp;</a></span>triangulateNonlinear() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CAMERA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a> gtsam::triangulateNonlinear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a03152.html">CameraSet</a>&lt; CAMERA &gt; &amp;&#160;</td>
          <td class="paramname"><em>cameras</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename CAMERA::MeasurementVector &amp;&#160;</td>
          <td class="paramname"><em>measurements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a> &amp;&#160;</td>
          <td class="paramname"><em>initialEstimate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an initial estimate , refine a point using measurements in several cameras. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cameras</td><td>pinhole cameras (monocular or stereo) </td></tr>
    <tr><td class="paramname">measurements</td><td>2D measurements </td></tr>
    <tr><td class="paramname">initialEstimate</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>refined Point3 </dd></dl>

</div>
</div>
<a id="afd76f4999d5ac79b85c4271943e9251f" name="afd76f4999d5ac79b85c4271943e9251f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd76f4999d5ac79b85c4271943e9251f">&#9670;&nbsp;</a></span>triangulateNonlinear() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CALIBRATION &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a> gtsam::triangulateNonlinear </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a03288.html">Pose3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>poses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; CALIBRATION &gt;&#160;</td>
          <td class="paramname"><em>sharedCal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point2Vector &amp;&#160;</td>
          <td class="paramname"><em>measurements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a> &amp;&#160;</td>
          <td class="paramname"><em>initialEstimate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an initial estimate , refine a point using measurements in several cameras. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poses</td><td>Camera poses </td></tr>
    <tr><td class="paramname">sharedCal</td><td>shared pointer to single calibration object </td></tr>
    <tr><td class="paramname">measurements</td><td>2D measurements </td></tr>
    <tr><td class="paramname">initialEstimate</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>refined Point3 </dd></dl>

</div>
</div>
<a id="a0493526601a58e173f8c0646ed302739" name="a0493526601a58e173f8c0646ed302739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0493526601a58e173f8c0646ed302739">&#9670;&nbsp;</a></span>triangulatePoint3() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CAMERA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a> gtsam::triangulatePoint3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a03152.html">CameraSet</a>&lt; CAMERA &gt; &amp;&#160;</td>
          <td class="paramname"><em>cameras</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename CAMERA::MeasurementVector &amp;&#160;</td>
          <td class="paramname"><em>measurements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rank_tol</em> = <code>1e-9</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optimize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to triangulate 3D landmark point from an arbitrary number of poses (at least 2) using the DLT. </p>
<p >This function is similar to the one above, except that each camera has its own calibration. The function checks that the resulting point lies in front of all cameras, but has no other checks to verify the quality of the triangulation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cameras</td><td>pinhole cameras </td></tr>
    <tr><td class="paramname">measurements</td><td>A vector of camera measurements </td></tr>
    <tr><td class="paramname">rank_tol</td><td>rank tolerance, default 1e-9 </td></tr>
    <tr><td class="paramname">optimize</td><td>Flag to turn on nonlinear refinement of triangulation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a Point3 </dd></dl>

</div>
</div>
<a id="ae7b725c367246edb1beea32060fd50f7" name="ae7b725c367246edb1beea32060fd50f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b725c367246edb1beea32060fd50f7">&#9670;&nbsp;</a></span>triangulatePoint3() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CALIBRATION &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a> gtsam::triangulatePoint3 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a03288.html">Pose3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>poses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; CALIBRATION &gt;&#160;</td>
          <td class="paramname"><em>sharedCal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point2Vector &amp;&#160;</td>
          <td class="paramname"><em>measurements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rank_tol</em> = <code>1e-9</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optimize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to triangulate 3D landmark point from an arbitrary number of poses (at least 2) using the DLT. </p>
<p >The function checks that the resulting point lies in front of all cameras, but has no other checks to verify the quality of the triangulation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poses</td><td>A vector of camera poses </td></tr>
    <tr><td class="paramname">sharedCal</td><td>shared pointer to single calibration object </td></tr>
    <tr><td class="paramname">measurements</td><td>A vector of camera measurements </td></tr>
    <tr><td class="paramname">rank_tol</td><td>rank tolerance, default 1e-9 </td></tr>
    <tr><td class="paramname">optimize</td><td>Flag to turn on nonlinear refinement of triangulation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a Point3 </dd></dl>

</div>
</div>
<a id="afefb1a863211aa15c603fbac3541fc4b" name="afefb1a863211aa15c603fbac3541fc4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afefb1a863211aa15c603fbac3541fc4b">&#9670;&nbsp;</a></span>triangulationGraph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CAMERA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="a04480.html">NonlinearFactorGraph</a>, <a class="el" href="a04560.html">Values</a> &gt; gtsam::triangulationGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a03152.html">CameraSet</a>&lt; CAMERA &gt; &amp;&#160;</td>
          <td class="paramname"><em>cameras</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename CAMERA::MeasurementVector &amp;&#160;</td>
          <td class="paramname"><em>measurements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a>&#160;</td>
          <td class="paramname"><em>landmarkKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a> &amp;&#160;</td>
          <td class="paramname"><em>initialEstimate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a factor graph with projection factors from pinhole cameras (each camera has a pose and calibration) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cameras</td><td>pinhole cameras (monocular or stereo) </td></tr>
    <tr><td class="paramname">measurements</td><td>2D measurements </td></tr>
    <tr><td class="paramname">landmarkKey</td><td>to refer to landmark </td></tr>
    <tr><td class="paramname">initialEstimate</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>graph and initial values </dd></dl>

</div>
</div>
<a id="a3fb854935c3a0b73ba63adfb86a5c141" name="a3fb854935c3a0b73ba63adfb86a5c141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb854935c3a0b73ba63adfb86a5c141">&#9670;&nbsp;</a></span>triangulationGraph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CALIBRATION &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="a04480.html">NonlinearFactorGraph</a>, <a class="el" href="a04560.html">Values</a> &gt; gtsam::triangulationGraph </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a03288.html">Pose3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>poses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; CALIBRATION &gt;&#160;</td>
          <td class="paramname"><em>sharedCal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point2Vector &amp;&#160;</td>
          <td class="paramname"><em>measurements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01596.html#adad029f5f6ffce610428b5fe768b0df2">Key</a>&#160;</td>
          <td class="paramname"><em>landmarkKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01596.html#aaa8ed89fd60ea4601d9de63c4811525b">Point3</a> &amp;&#160;</td>
          <td class="paramname"><em>initialEstimate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a factor graph with projection factors from poses and one calibration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poses</td><td>Camera poses </td></tr>
    <tr><td class="paramname">sharedCal</td><td>shared pointer to single calibration object (monocular only!) </td></tr>
    <tr><td class="paramname">measurements</td><td>2D measurements </td></tr>
    <tr><td class="paramname">landmarkKey</td><td>to refer to landmark </td></tr>
    <tr><td class="paramname">initialEstimate</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>graph and initial values </dd></dl>

</div>
</div>
<a id="a24d3ad0252f91f0ec301593c45cf5af7" name="a24d3ad0252f91f0ec301593c45cf5af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d3ad0252f91f0ec301593c45cf5af7">&#9670;&nbsp;</a></span>vector_scale_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT void gtsam::vector_scale_inplace </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inf_mask</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>scales a matrix row or column by the values in a vector Arguments (Matrix, Vector) scales the columns, (Vector, Matrix) scales the rows </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inf_mask</td><td>when true, will not scale with a NaN or inf value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefb606eb24889c0f418acf1515a2c723" name="aefb606eb24889c0f418acf1515a2c723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb606eb24889c0f418acf1515a2c723">&#9670;&nbsp;</a></span>wedge&lt; Pose3 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix <a class="el" href="a01596.html#afe28b7f8e3592fb9f5cf9ebae09497ba">gtsam::wedge</a>&lt; <a class="el" href="a03288.html">Pose3</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>xi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>wedge for <a class="el" href="a03288.html">Pose3</a>: </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xi</td><td>6-dim twist (omega,v) where omega = 3D angular velocity v = 3D velocity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>xihat, 4*4 element of Lie algebra that can be exponentiated </dd></dl>

</div>
</div>
<a id="a60019a03f26b92c6b2a08e43d153d4c0" name="a60019a03f26b92c6b2a08e43d153d4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60019a03f26b92c6b2a08e43d153d4c0">&#9670;&nbsp;</a></span>weighted_eliminate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::list&lt; boost::tuple&lt; Vector, double, double &gt; &gt; gtsam::weighted_eliminate </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>sigmas</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Imperative algorithm for in-place full elimination with weights and constraint handling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>is a matrix to eliminate </td></tr>
    <tr><td class="paramname">b</td><td>is the rhs </td></tr>
    <tr><td class="paramname">sigmas</td><td>is a vector of the measurement standard deviation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of r vectors, d and sigma </dd></dl>

</div>
</div>
<a id="aca1c56d11a05464a7a5458dc32ccc777" name="aca1c56d11a05464a7a5458dc32ccc777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca1c56d11a05464a7a5458dc32ccc777">&#9670;&nbsp;</a></span>weightedPseudoinverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::pair&lt; Vector, double &gt; gtsam::weightedPseudoinverse </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weighted Householder solution vector, a.k.a., the pseudoinverse of the column NOTE: if any sigmas are zero (indicating a constraint) the pseudoinverse will be a selection vector, and the variance will be zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>is the first column of the matrix to solve </td></tr>
    <tr><td class="paramname">weights</td><td>is a vector of weights/precisions where w=1/(s*s) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of the pseudoinverse of v and the associated precision/weight </dd></dl>

</div>
</div>
<a id="aea6d4511beb8fd046f0d9f430d17d396" name="aea6d4511beb8fd046f0d9f430d17d396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6d4511beb8fd046f0d9f430d17d396">&#9670;&nbsp;</a></span>writeBAL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT bool gtsam::writeBAL </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a04736.html">SfmData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes a "Bundle Adjustment in the Large" (BAL) file from a <a class="el" href="a04736.html" title="Define the structure for SfM data.">SfmData</a> structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the BAL file to write </td></tr>
    <tr><td class="paramname">data</td><td>SfM structure where the data is stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the parsing was successful, false otherwise </dd></dl>

</div>
</div>
<a id="a71a14a1609cd7dd26106cca1345ec958" name="a71a14a1609cd7dd26106cca1345ec958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71a14a1609cd7dd26106cca1345ec958">&#9670;&nbsp;</a></span>writeBALfromValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT bool gtsam::writeBALfromValues </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a04736.html">SfmData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a04560.html">Values</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes a "Bundle Adjustment in the Large" (BAL) file from a <a class="el" href="a04736.html" title="Define the structure for SfM data.">SfmData</a> structure and a value structure (measurements are the same as the SfM input data, while camera poses and values are read from <a class="el" href="a04560.html" title="A non-templated config holding any types of Manifold-group elements.">Values</a>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the BAL file to write </td></tr>
    <tr><td class="paramname">data</td><td>SfM structure where the data is stored </td></tr>
    <tr><td class="paramname">values</td><td>structure where the graph values are stored (values can be either <a class="el" href="a03288.html">Pose3</a> or PinholeCamera&lt;Cal3Bundler&gt; for the cameras, and should be Point3 for the 3D points). Note that the current version assumes that the keys are "x1" for pose 1 (or "c1" for camera 1) and "l1" for landmark 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the parsing was successful, false otherwise </dd></dl>

</div>
</div>
<a id="a68bc584d72da3747666ac134a9490f92" name="a68bc584d72da3747666ac134a9490f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68bc584d72da3747666ac134a9490f92">&#9670;&nbsp;</a></span>writeG2o()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT void gtsam::writeG2o </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a04480.html">NonlinearFactorGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a04560.html">Values</a> &amp;&#160;</td>
          <td class="paramname"><em>estimate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes a g2o file from <a class="el" href="a04480.html" title="A non-linear factor graph is a graph of non-Gaussian, i.e.">NonlinearFactorGraph</a> and a <a class="el" href="a04560.html" title="A non-templated config holding any types of Manifold-group elements.">Values</a> structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the g2o file to write </td></tr>
    <tr><td class="paramname">graph</td><td><a class="el" href="a04440.html" title="Nonlinear factor base class.">NonlinearFactor</a> graph storing the measurements </td></tr>
    <tr><td class="paramname">estimate</td><td><a class="el" href="a04560.html" title="A non-templated config holding any types of Manifold-group elements.">Values</a></td></tr>
  </table>
  </dd>
</dl>
<p>Note:behavior change in PR #471: to be consistent with load2D and load3D, we write the <em>indices</em> to file and not the full Keys. This change really only affects landmarks, which get read as indices but stored in values with the symbol L(index). </p>

</div>
</div>
<a id="a57edf6ed7312f63d35f73233665c334d" name="a57edf6ed7312f63d35f73233665c334d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57edf6ed7312f63d35f73233665c334d">&#9670;&nbsp;</a></span>zeroBelowDiagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MATRIX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gtsam::zeroBelowDiagonal </td>
          <td>(</td>
          <td class="paramtype">MATRIX &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cols</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zeros all of the elements below the diagonal of a matrix, in place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>is a matrix, to be modified in place </td></tr>
    <tr><td class="paramname">cols</td><td>is the number of columns to zero, use zero for all columns </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a01596.html">gtsam</a></li>
    <li class="footer">Generated on Tue Jan 25 2022 13:36:45 for gtsam by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
