---
layout: page
date:   2019-05-22 07:30:00 -0400
title: "Factor Graphs and GTSAM"
categories: factor-graphs
---

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="GENERATOR" content="LyX 2.3.2" />
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Factor Graphs and GTSAM:A Hands-on Introduction</title>
<style type='text/css'>
/* LyX Provided Styles */
div.bibtexentry { margin-left: 2em; text-indent: -2em; }
span.bibtexlabel:before{ content: "["; }
span.bibtexlabel:after{ content: "] "; }

/* Layout-provided Styles */
h1.title {
font-size: x-large;
margin-bottom: 1ex;
text-align: center;

}
div.author {
font-size: large;
margin-top: 1.3ex;
margin-bottom: 0.7ex;
text-align: center;

}
div.date {
font-size: large;
margin-top: 0.9ex;
margin-bottom: 0.5ex;
text-align: center;

}
div.standard {
	margin-bottom: 2ex;
}
h2.section_ {
font-weight: bold;
font-size: x-large;
margin-top: 1.3ex;
margin-bottom: 0.7ex;
text-align: left;

}
div.plain_layout {
text-align: left;

}
h2.section {
font-weight: bold;
font-size: x-large;
margin-top: 1.3ex;
margin-bottom: 0.7ex;
text-align: left;

}
h3.subsection {
font-weight: bold;
font-size: large;
margin-top: 0.9ex;
margin-bottom: 0.5ex;
text-align: left;

}
ol.enumerate {
margin-top: 0.7ex;
margin-bottom: 0.7ex;
margin-left: 3ex;
text-align: left;

}
ul.itemize {
margin-top: 0.7ex;
margin-bottom: 0.7ex;
margin-left: 3ex;
text-align: left;

}
span.flex_url {
font-family: monospace;
}
div.toc {
  margin: 2em 0em;
  border-style: solid;
  border-width: 2px 0px;
  padding: 1em 0em;
}
h2.tochead { font-size: x-large; font-weight: bold; }
div.lyxtoc-0 {
  margin: 2em 0em 0em 0em;
  font-size: xx-large;
  font-weight: bold;
}
div.lyxtoc-1 {
  margin: 1em 0em 0em 0em;
  font-size: x-large;
  font-weight: bold;
}
div.lyxtoc-2 {
  margin: 0em 0.1em 0em 1em;
  font-size: large;
  font-weight: normal;
}
div.lyxtoc-3 { margin: 0em 0.1em 0em 0.5em; font-size: medium; }
div.lyxtoc-4 { margin: 0em 0.1em 0em 0.5em; }
div.lyxtoc-5 { margin: 0em 0.1em 0em 0.5em; }
div.lyxtoc-6 { margin: 0em 0.1em 0em 0.5em; }
a.tocentry {
  text-decoration: none;
  color: black;
}
a.tocentry:visited { color: black; }
div.float {
	border: 2px solid black;
	text-align: center;
}
div.float-caption {
	text-align: center;
	border: 2px solid black;
	padding: 1ex;
	/* padding-bottom: 15px; */
	margin: 1ex;
  display:block;
}
span.foot_label {
	vertical-align: super;
	font-size: smaller;
	font-weight: bold;
	text-decoration: underline;
}
div.foot {
	display: inline;
	font-size: small;
	font-weight: medium;
	font-family: serif;
	font-variant: normal;
	font-style: normal;
}
div.foot_inner { display: none; }
div.foot:hover div.foot_inner {
	display: block;
	border: 1px double black;
	margin: 0em 1em;
	padding: 1em;
}

/* Frank overrides */
.float-caption { display:block;}
.float-caption::before { content : '\A\A'; }

</style>
</head>
<body dir="auto">
<!-- <h1 class="title" id='magicparlabel-65361'>Factor Graphs and GTSAM:
<br />

A Hands-on Introduction</h1>
<div class="author" id='magicparlabel-65362'>Frank Dellaert
<br />

Technical Report number GT-RIM-CP&amp;R-2014-XXX</div>
<div class="date" id='magicparlabel-65363'>September 2014</div> -->

<p>This is an updated version of the 2012 tech-report <a href="http://borg.cc.gatech.edu/sites/edu.borg/files/downloads/gtsam.pdf">Factor Graphs
    and GTSAM: A Hands-on Introduction</a> by <a href="http://frank.dellaert.com">Frank Dellaert</a>. A more thorough introduction to the use of factor graphs in robotics is the 2017 article <a
    href="https://www.cc.gatech.edu/~dellaert/pubs/Dellaert17fnt.pdf">Factor graphs for robot perception</a> by Frank
  Dellaert and Michael Kaess.</p>

<h2 class="section_" id='magicparlabel-65365'>Overview</h2>

<div class="standard" id='magicparlabel-65367'><b>Factor graphs</b> are graphical models (<a href='#LyXCite-Koller09book'><span class="bib-abbrvciteauthor">Koller and Friedman</span>, <span class="bib-year">2009</span></a>) that are well suited to modeling complex estimation problems, such as Simultaneous Localization and Mapping (SLAM) or Structure from Motion (SFM). You might be familiar with another often used graphical model, Bayes networks, which are directed acyclic graphs. A <b>factor graph, </b>however, is a <em>bipartite</em> graph consisting of factors connected to variables. The <b>variables</b> represent the unknown random variables in the estimation problem, whereas the <b>factors</b> represent probabilistic constraints on those variables, derived from measurements or prior knowledge. In the following sections I will illustrate this with examples from both robotics and vision.</div>

<div class="standard" id='magicparlabel-65368'>The GTSAM toolbox (GTSAM stands for &ldquo;Georgia Tech Smoothing and Mapping&rdquo;) toolbox is a BSD-licensed C++ library based on factor graphs, developed at the Georgia Institute of Technology by myself, many of my students, and collaborators. It provides state of the art solutions to the SLAM and SFM problems, but can also be used to model and solve both simpler and more complex estimation problems. It also provides a MATLAB interface which allows for rapid prototype development, visualization, and user interaction.</div>

<div class="standard" id='magicparlabel-65369'>GTSAM exploits sparsity to be computationally efficient. Typically measurements only provide information on the relationship between a handful of variables, and hence the resulting factor graph will be sparsely connected. This is exploited by the algorithms implemented in GTSAM to reduce computational complexity. Even when graphs are too dense to be handled efficiently by direct methods, GTSAM provides iterative methods that are quite efficient regardless.</div>

<div class="standard" id='magicparlabel-65370'>You can download the latest version of GTSAM from our <a href="https://github.com/borglab/gtsam">Github repo</a>.</div>


<div class='toc'><h2 class='tochead section'>Table of Contents</h2>


<div class='lyxtoc-1'><div class='lyxtoc-2'><a href='#magicparlabel-65365' class='tocentry'>Overview</a>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-65377' class='tocentry'>1 Factor Graphs</a>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-65411' class='tocentry'>2 Modeling Robot Motion</a>


<div class='lyxtoc-3'><a href='#magicparlabel-65412' class='tocentry'>2.1 Modeling with Factor Graphs</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-65428' class='tocentry'>2.2 Creating a Factor Graph</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-65438' class='tocentry'>2.3 Factor Graphs versus Values</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-65443' class='tocentry'>2.4 Non-linear Optimization in GTSAM</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-65457' class='tocentry'>2.5 Full Posterior Inference</a>
</div>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-65467' class='tocentry'>3 Robot Localization</a>


<div class='lyxtoc-3'><a href='#magicparlabel-65468' class='tocentry'>3.1 Unary Measurement Factors</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-65484' class='tocentry'>3.2 Defining Custom Factors</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-65499' class='tocentry'>3.3 Using Custom Factors</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-65514' class='tocentry'>3.4 Full Posterior Inference</a>
</div>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-65549' class='tocentry'>4 PoseSLAM</a>


<div class='lyxtoc-3'><a href='#magicparlabel-65550' class='tocentry'>4.1 Loop Closure Constraints</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-65583' class='tocentry'>4.2 Using the MATLAB Interface</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-65612' class='tocentry'>4.3 Reading and Optimizing Pose Graphs </a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-65623' class='tocentry'>4.4 PoseSLAM in 3D</a>
</div>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-65635' class='tocentry'>5 Landmark-based SLAM</a>


<div class='lyxtoc-3'><a href='#magicparlabel-65636' class='tocentry'>5.1 Basics</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-65663' class='tocentry'>5.2 Of Keys and Symbols</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-65684' class='tocentry'>5.3 A Larger Example</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-65695' class='tocentry'>5.4 A Real-World Example</a>
</div>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-65707' class='tocentry'>6 Structure from Motion</a>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-65728' class='tocentry'>7 iSAM: Incremental Smoothing and Mapping</a>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-65738' class='tocentry'>8 More Applications</a>


<div class='lyxtoc-3'><a href='#magicparlabel-65754' class='tocentry'>8.1 Conjugate Gradient Optimization</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-65765' class='tocentry'>8.2 Visual Odometry</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-65767' class='tocentry'>8.3 Visual SLAM</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-65769' class='tocentry'>8.4 Fixed-lag Smoothing and Filtering </a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-65771' class='tocentry'>8.5 Discrete Variables and HMMs</a>
</div>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-65773' class='tocentry'>Acknowledgements</a>
</div>
</div>
</div>


<div class="standard" id='magicparlabel-65376'><br />
</div>
<h2 class="section" id='magicparlabel-65377'><span class="section_label">1</span> Factor Graphs</h2>
<div class="standard" id='magicparlabel-65378'>Let us start with a one-page primer on factor graphs, which in no way replaces the excellent and detailed reviews by <a href='#LyXCite-Kschischang01it'><span class="bib-abbrvciteauthor">Kschischang et al.</span></a> (<span class="bib-year">2001</span>) and <a href='#LyXCite-Loeliger04spm'><span class="bib-abbrvciteauthor">Loeliger</span></a> (<span class="bib-year">2004</span>). </div>


<div class='float-figure'><div class="plain_layout" style='text-align: center;' id='magicparlabel-65383'><img style='width:60%;' src='intro-images/2_Users_dellaert_git_github_doc_images_hmm.png' alt='image: 2_Users_dellaert_git_github_doc_images_hmm.png' />
<span class='float-caption-Standard float-caption float-caption-standard'>Figure 1:  <a id="fig_unrolledHMM" />
An HMM, unrolled over three time-steps, represented by a Bayes net. </span></div>
</div>


<div class="standard" id='magicparlabel-65388'> Figure <a href="#fig_unrolledHMM">1</a> shows the <b>Bayes network</b> for a hidden Markov model (HMM) over three time steps. In a Bayes net, each node is associated with a conditional density: the top Markov chain encodes the prior <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>P</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <msub>
    <mrow><mi>X</mi>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
   </msub>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math> and transition probabilities <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>P</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow>
    <msub>
     <mrow><mi>X</mi>
     </mrow>
     <mrow><mn>2</mn>
     </mrow>
    </msub><mo>|</mo>
    <msub>
     <mrow><mi>X</mi>
     </mrow>
     <mrow><mn>1</mn>
     </mrow>
    </msub>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>P</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow>
    <msub>
     <mrow><mi>X</mi>
     </mrow>
     <mrow><mn>3</mn>
     </mrow>
    </msub><mo>|</mo>
    <msub>
     <mrow><mi>X</mi>
     </mrow>
     <mrow><mn>2</mn>
     </mrow>
    </msub>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math>, whereas measurements <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>Z</mi>
   </mrow>
   <mrow><mi>t</mi>
   </mrow>
  </msub>
 </mrow></math> depend only on the state <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>X</mi>
   </mrow>
   <mrow><mi>t</mi>
   </mrow>
  </msub>
 </mrow></math>, modeled by conditional densities <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>P</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow>
    <msub>
     <mrow><mi>Z</mi>
     </mrow>
     <mrow><mi>t</mi>
     </mrow>
    </msub><mo>|</mo>
    <msub>
     <mrow><mi>X</mi>
     </mrow>
     <mrow><mi>t</mi>
     </mrow>
    </msub>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math>. Given known measurements <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>z</mi>
   </mrow>
   <mrow><mn>1</mn>
   </mrow>
  </msub>
 </mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>z</mi>
   </mrow>
   <mrow><mn>2</mn>
   </mrow>
  </msub>
 </mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>z</mi>
   </mrow>
   <mrow><mn>3</mn>
   </mrow>
  </msub>
 </mrow></math> we are interested in the hidden state sequence <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

  <mrow>
   <msub>
    <mrow><mi>X</mi>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
   </msub><mo>,</mo>
   <msub>
    <mrow><mi>X</mi>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msub><mo>,</mo>
   <msub>
    <mrow><mi>X</mi>
    </mrow>
    <mrow><mn>3</mn>
    </mrow>
   </msub>
  </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

 </mrow></math> that maximizes the posterior probability <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>P</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow>
    <msub>
     <mrow><mi>X</mi>
     </mrow>
     <mrow><mn>1</mn>
     </mrow>
    </msub><mo>,</mo>
    <msub>
     <mrow><mi>X</mi>
     </mrow>
     <mrow><mn>2</mn>
     </mrow>
    </msub><mo>,</mo>
    <msub>
     <mrow><mi>X</mi>
     </mrow>
     <mrow><mn>3</mn>
     </mrow>
    </msub><mo>|</mo>
    <msub>
     <mrow><mi>Z</mi>
     </mrow>
     <mrow><mn>1</mn>
     </mrow>
    </msub><mo>=</mo>
    <msub>
     <mrow><mi>z</mi>
     </mrow>
     <mrow><mn>1</mn>
     </mrow>
    </msub><mo>,</mo>
    <msub>
     <mrow><mi>Z</mi>
     </mrow>
     <mrow><mn>2</mn>
     </mrow>
    </msub><mo>=</mo>
    <msub>
     <mrow><mi>z</mi>
     </mrow>
     <mrow><mn>2</mn>
     </mrow>
    </msub><mo>,</mo>
    <msub>
     <mrow><mi>Z</mi>
     </mrow>
     <mrow><mn>3</mn>
     </mrow>
    </msub><mo>=</mo>
    <msub>
     <mrow><mi>z</mi>
     </mrow>
     <mrow><mn>3</mn>
     </mrow>
    </msub>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math>. Since the measurements <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>Z</mi>
   </mrow>
   <mrow><mn>1</mn>
   </mrow>
  </msub>
 </mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>Z</mi>
   </mrow>
   <mrow><mn>2</mn>
   </mrow>
  </msub>
 </mrow></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>Z</mi>
   </mrow>
   <mrow><mn>3</mn>
   </mrow>
  </msub>
 </mrow></math> are <em>known</em>, the posterior is proportional to the product of six <b>factors</b>, three of which derive from the the Markov chain, and three likelihood factors defined as <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>L</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow>
    <msub>
     <mrow><mi>X</mi>
     </mrow>
     <mrow><mi>t</mi>
     </mrow>
    </msub><mo>;</mo><mi>z</mi>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
<mo> &vprop; </mo><mi>P</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow>
    <msub>
     <mrow><mi>Z</mi>
     </mrow>
     <mrow><mi>t</mi>
     </mrow>
    </msub><mo>=</mo><mi>z</mi><mo>|</mo>
    <msub>
     <mrow><mi>X</mi>
     </mrow>
     <mrow><mi>t</mi>
     </mrow>
    </msub>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math>:<math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>P</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow>
    <msub>
     <mrow><mi>X</mi>
     </mrow>
     <mrow><mn>1</mn>
     </mrow>
    </msub><mo>,</mo>
    <msub>
     <mrow><mi>X</mi>
     </mrow>
     <mrow><mn>2</mn>
     </mrow>
    </msub><mo>,</mo>
    <msub>
     <mrow><mi>X</mi>
     </mrow>
     <mrow><mn>3</mn>
     </mrow>
    </msub><mo>|</mo>
    <msub>
     <mrow><mi>Z</mi>
     </mrow>
     <mrow><mn>1</mn>
     </mrow>
    </msub><mo>,</mo>
    <msub>
     <mrow><mi>Z</mi>
     </mrow>
     <mrow><mn>2</mn>
     </mrow>
    </msub><mo>,</mo>
    <msub>
     <mrow><mi>Z</mi>
     </mrow>
     <mrow><mn>3</mn>
     </mrow>
    </msub>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
<mo> &vprop; </mo><mi>P</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <msub>
    <mrow><mi>X</mi>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
   </msub>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
<mi>P</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow>
    <msub>
     <mrow><mi>X</mi>
     </mrow>
     <mrow><mn>2</mn>
     </mrow>
    </msub><mo>|</mo>
    <msub>
     <mrow><mi>X</mi>
     </mrow>
     <mrow><mn>1</mn>
     </mrow>
    </msub>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
<mi>P</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow>
    <msub>
     <mrow><mi>X</mi>
     </mrow>
     <mrow><mn>3</mn>
     </mrow>
    </msub><mo>|</mo>
    <msub>
     <mrow><mi>X</mi>
     </mrow>
     <mrow><mn>2</mn>
     </mrow>
    </msub>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
<mi>L</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow>
    <msub>
     <mrow><mi>X</mi>
     </mrow>
     <mrow><mn>1</mn>
     </mrow>
    </msub><mo>;</mo>
    <msub>
     <mrow><mi>z</mi>
     </mrow>
     <mrow><mn>1</mn>
     </mrow>
    </msub>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
<mi>L</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow>
    <msub>
     <mrow><mi>X</mi>
     </mrow>
     <mrow><mn>2</mn>
     </mrow>
    </msub><mo>;</mo>
    <msub>
     <mrow><mi>z</mi>
     </mrow>
     <mrow><mn>2</mn>
     </mrow>
    </msub>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
<mi>L</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow>
    <msub>
     <mrow><mi>X</mi>
     </mrow>
     <mrow><mn>3</mn>
     </mrow>
    </msub><mo>;</mo>
    <msub>
     <mrow><mi>z</mi>
     </mrow>
     <mrow><mn>3</mn>
     </mrow>
    </msub>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math></div>


<div class='float-figure'><div class="plain_layout" style='text-align: center;' id='magicparlabel-65401'><img style='width:60%;' src='intro-images/3_Users_dellaert_git_github_doc_images_hmm-FG.png' alt='image: 3_Users_dellaert_git_github_doc_images_hmm-FG.png' />
<span class='float-caption-Standard float-caption float-caption-standard'>Figure 2:  <a id="fig_HMM_FG" />
An HMM with observed measurements, unrolled over time, represented as a factor graph.</span></div>
</div>


<div class="standard" id='magicparlabel-65406'> This motivates a different graphical model, a <b>factor graph</b>, in which we only represent the unknown variables <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>X</mi>
   </mrow>
   <mrow><mn>1</mn>
   </mrow>
  </msub>
 </mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>X</mi>
   </mrow>
   <mrow><mn>2</mn>
   </mrow>
  </msub>
 </mrow></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>X</mi>
   </mrow>
   <mrow><mn>3</mn>
   </mrow>
  </msub>
 </mrow></math>, connected to factors that encode probabilistic information on them, as in Figure <a href="#fig_HMM_FG">2</a>. To do maximum a-posteriori (MAP) inference, we then maximize the product <math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>f</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow>
    <msub>
     <mrow><mi>X</mi>
     </mrow>
     <mrow><mn>1</mn>
     </mrow>
    </msub><mo>,</mo>
    <msub>
     <mrow><mi>X</mi>
     </mrow>
     <mrow><mn>2</mn>
     </mrow>
    </msub><mo>,</mo>
    <msub>
     <mrow><mi>X</mi>
     </mrow>
     <mrow><mn>3</mn>
     </mrow>
    </msub>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
<mo>=</mo><mo> &prod; </mo>
   <msub>
    <mrow><mi>f</mi>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <msub>
    <mrow>
     <mstyle mathvariant='script'><mi>X</mi>
     </mstyle>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math>i.e., the value of the factor graph. It should be clear from the figure that the connectivity of a factor graph encodes, for each factor <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>f</mi>
   </mrow>
   <mrow><mi>i</mi>
   </mrow>
  </msub>
 </mrow></math>, which subset of variables <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow>
    <mstyle mathvariant='script'><mi>X</mi>
    </mstyle>
   </mrow>
   <mrow><mi>i</mi>
   </mrow>
  </msub>
 </mrow></math> it depends on. In the examples below, we use factor graphs to model more complex MAP inference problems in robotics.</div>
<h2 class="section" id='magicparlabel-65411'><span class="section_label">2</span> <a id="sec_Robot_Localization" />
Modeling Robot Motion</h2>
<h3 class="subsection" id='magicparlabel-65412'><span class="subsection_label">2.1</span> Modeling with Factor Graphs</h3>
<div class="standard" id='magicparlabel-65413'>Before diving into a SLAM example, let us consider the simpler problem of modeling robot motion. This can be done with a <em>continuous</em> Markov chain, and provides a gentle introduction to GTSAM.</div>


<div class='float-figure'><div class="plain_layout" style='text-align: center;' id='magicparlabel-65418'><img style='width:80%;' src='intro-images/4_Users_dellaert_git_github_doc_images_FactorGraph.png' alt='image: 4_Users_dellaert_git_github_doc_images_FactorGraph.png' />
<span class='float-caption-Standard float-caption float-caption-standard'>Figure 3:  <a id="fig_OdometryFG" />
Factor graph for robot localization.</span></div>
</div>


<div class="standard" id='magicparlabel-65423'> The factor graph for a simple example is shown in Figure <a href="#fig_OdometryFG">3</a>. There are three variables <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>x</mi>
   </mrow>
   <mrow><mn>1</mn>
   </mrow>
  </msub>
 </mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>x</mi>
   </mrow>
   <mrow><mn>2</mn>
   </mrow>
  </msub>
 </mrow></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>x</mi>
   </mrow>
   <mrow><mn>3</mn>
   </mrow>
  </msub>
 </mrow></math> which represent the poses of the robot over time, rendered in the figure by the open-circle variable nodes. In this example, we have one <b>unary factor</b> <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>f</mi>
    </mrow>
    <mrow><mn>0</mn>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <msub>
    <mrow><mi>x</mi>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
   </msub>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math> on the first pose <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>x</mi>
   </mrow>
   <mrow><mn>1</mn>
   </mrow>
  </msub>
 </mrow></math> that encodes our prior knowledge about <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>x</mi>
   </mrow>
   <mrow><mn>1</mn>
   </mrow>
  </msub>
 </mrow></math>, and two <b>binary factors</b> that relate successive poses, respectively <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>f</mi>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow>
    <msub>
     <mrow><mi>x</mi>
     </mrow>
     <mrow><mn>1</mn>
     </mrow>
    </msub><mo>,</mo>
    <msub>
     <mrow><mi>x</mi>
     </mrow>
     <mrow><mn>2</mn>
     </mrow>
    </msub><mo>;</mo>
    <msub>
     <mrow><mi>o</mi>
     </mrow>
     <mrow><mn>1</mn>
     </mrow>
    </msub>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>f</mi>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow>
    <msub>
     <mrow><mi>x</mi>
     </mrow>
     <mrow><mn>2</mn>
     </mrow>
    </msub><mo>,</mo>
    <msub>
     <mrow><mi>x</mi>
     </mrow>
     <mrow><mn>3</mn>
     </mrow>
    </msub><mo>;</mo>
    <msub>
     <mrow><mi>o</mi>
     </mrow>
     <mrow><mn>2</mn>
     </mrow>
    </msub>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>o</mi>
   </mrow>
   <mrow><mn>1</mn>
   </mrow>
  </msub>
 </mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>o</mi>
   </mrow>
   <mrow><mn>2</mn>
   </mrow>
  </msub>
 </mrow></math> represent odometry measurements.</div>
<h3 class="subsection" id='magicparlabel-65428'><span class="subsection_label">2.2</span> Creating a Factor Graph</h3>
<div class="standard" id='magicparlabel-65429'>The following C++ code, included in GTSAM as an example, creates the factor graph in Figure <a href="#fig_OdometryFG">3</a>:</div>

<div class="standard" id='magicparlabel-65430'><pre>// Create an empty nonlinear factor graph
NonlinearFactorGraph graph;

// Add a Gaussian prior on pose x_1
Pose2 priorMean(0.0, 0.0, 0.0);
noiseModel::Diagonal::shared_ptr priorNoise =
  noiseModel::Diagonal::Sigmas(Vector3(0.3, 0.3, 0.1));
graph.add(PriorFactor&lt;Pose2&gt;(1, priorMean, priorNoise));

// Add two odometry factors
Pose2 odometry(2.0, 0.0, 0.0);
noiseModel::Diagonal::shared_ptr odometryNoise =
  noiseModel::Diagonal::Sigmas(Vector3(0.2, 0.2, 0.1));
graph.add(BetweenFactor&lt;Pose2&gt;(1, 2, odometry, odometryNoise));
graph.add(BetweenFactor&lt;Pose2&gt;(2, 3, odometry, odometryNoise));
</pre></div>

<div class="standard" id='magicparlabel-65431'> Above, line 2 creates an empty factor graph. We then add the factor <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>f</mi>
    </mrow>
    <mrow><mn>0</mn>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <msub>
    <mrow><mi>x</mi>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
   </msub>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math> on lines 5-8 as an instance of <em><b>PriorFactor&lt;T&gt;</b></em>, a templated class provided in the slam subfolder, with <em><b>T=Pose2</b></em>. Its constructor takes a variable <em><b>Key</b></em> (in this case 1), a mean of type <em><b>Pose2,</b></em> created on Line 5, and a noise model for the prior density. We provide a diagonal Gaussian of type <em><b>noiseModel::Diagonal</b></em> by specifying three standard deviations in line 7, respectively 30 cm.&nbsp;on the robot's position, and 0.1 radians on the robot's orientation. Note that the <em><b>Sigmas</b></em> constructor returns a shared pointer, anticipating that typically the same noise models are used for many different factors.</div>

<div class="standard" id='magicparlabel-65436'>Similarly, odometry measurements are specified as <em><b>Pose2</b></em> on line 11, with a slightly different noise model defined on line 12-13. We then add the two factors <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>f</mi>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow>
    <msub>
     <mrow><mi>x</mi>
     </mrow>
     <mrow><mn>1</mn>
     </mrow>
    </msub><mo>,</mo>
    <msub>
     <mrow><mi>x</mi>
     </mrow>
     <mrow><mn>2</mn>
     </mrow>
    </msub><mo>;</mo>
    <msub>
     <mrow><mi>o</mi>
     </mrow>
     <mrow><mn>1</mn>
     </mrow>
    </msub>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>f</mi>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow>
    <msub>
     <mrow><mi>x</mi>
     </mrow>
     <mrow><mn>2</mn>
     </mrow>
    </msub><mo>,</mo>
    <msub>
     <mrow><mi>x</mi>
     </mrow>
     <mrow><mn>3</mn>
     </mrow>
    </msub><mo>;</mo>
    <msub>
     <mrow><mi>o</mi>
     </mrow>
     <mrow><mn>2</mn>
     </mrow>
    </msub>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math> on lines 14-15, as instances of yet another templated class, <em><b>BetweenFactor&lt;T&gt;</b></em>, again with <em><b>T=Pose2</b></em>.</div>

<div class="standard" id='magicparlabel-65437'>When running the example (<em>make OdometryExample.run</em> on the command prompt), it will print out the factor graph as follows:<span style='font-family:monospace;'><span style='font-size:small;'>Factor Graph:
size: 3
factor 0: PriorFactor on 1
  prior mean: (0, 0, 0)
  noise model: diagonal sigmas [0.3; 0.3; 0.1];
factor 1: BetweenFactor(1,2)
  measured: (2, 0, 0)
  noise model: diagonal sigmas [0.2; 0.2; 0.1];
factor 2: BetweenFactor(2,3)
  measured: (2, 0, 0)
  noise model: diagonal sigmas [0.2; 0.2; 0.1];
</span></span></div>
<h3 class="subsection" id='magicparlabel-65438'><span class="subsection_label">2.3</span> Factor Graphs versus Values</h3>
<div class="standard" id='magicparlabel-65439'>At this point it is instructive to emphasize two important design ideas underlying GTSAM:</div>

<ol class="enumerate" id='magicparlabel-65440'><li class="enumerate_item">The factor graph and its embodiment in code specify the joint probability distribution <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>P</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow><mi>X</mi><mo>|</mo><mi>Z</mi>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math> over the <em>entire</em> trajectory <span class='math'>X\define\{x_{1},x_{2},x_{3}\}</span>
 of the robot, rather than just the last pose. This <em>smoothing</em> view of the world gives GTSAM its name: &ldquo;smoothing and mapping&rdquo;. Later in this document we will talk about how we can also use GTSAM to do filtering (which you often do <em>not</em> want to do) or incremental inference (which we do all the time).</li>
<li class="enumerate_item">A factor graph in GTSAM is just the specification of the probability density <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>P</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow><mi>X</mi><mo>|</mo><mi>Z</mi>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math>, and the corresponding <em><b>FactorGraph</b></em> class and its derived classes do not ever contain a &ldquo;solution&rdquo;. Rather, there is a separate type <em><b>Values</b></em> that is used to specify specific values for (in this case) <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>x</mi>
   </mrow>
   <mrow><mn>1</mn>
   </mrow>
  </msub>
 </mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>x</mi>
   </mrow>
   <mrow><mn>2</mn>
   </mrow>
  </msub>
 </mrow></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>x</mi>
   </mrow>
   <mrow><mn>3</mn>
   </mrow>
  </msub>
 </mrow></math>, which can then be used to evaluate the probability (or, more commonly, the error) associated with particular values.</li>
</ol>
<div class="standard" id='magicparlabel-65442'>The latter point is often a point of confusion with beginning users of GTSAM. It helps to remember that when designing GTSAM we took a functional approach of classes corresponding to mathematical objects, which are usually immutable. You should think of a factor graph as a <em>function</em> to be applied to values -as the notation <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>f</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
<mi>X</mi>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
<mo> &vprop; </mo><mi>P</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow><mi>X</mi><mo>|</mo><mi>Z</mi>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math> implies- rather than as an object to be modified.</div>
<h3 class="subsection" id='magicparlabel-65443'><span class="subsection_label">2.4</span> Non-linear Optimization in GTSAM</h3>
<div class="standard" id='magicparlabel-65444'>The listing below creates a <em><b>Values</b></em> instance, and uses it as the initial estimate to find the maximum a-posteriori (MAP) assignment for the trajectory <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>X</mi>
 </mrow></math>:</div>

<div class="standard" id='magicparlabel-65445'><pre>// create (deliberatly inaccurate) initial estimate
Values initial;
initial.insert(1, Pose2(0.5, 0.0, 0.2));
initial.insert(2, Pose2(2.3, 0.1, -0.2));
initial.insert(3, Pose2(4.1, 0.1, 0.1));

// optimize using Levenberg-Marquardt optimization
Values result = LevenbergMarquardtOptimizer(graph, initial).optimize();

</pre></div>

<div class="standard" id='magicparlabel-65446'> Lines 2-5 in Listing <a href="#listing_OdometryOptimize">2.4</a> create the initial estimate, and on line 8 we create a non-linear Levenberg-Marquardt style optimizer, and call <em><b>optimize</b></em> using default parameter settings. The reason why GTSAM needs to perform non-linear optimization is because the odometry factors <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>f</mi>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow>
    <msub>
     <mrow><mi>x</mi>
     </mrow>
     <mrow><mn>1</mn>
     </mrow>
    </msub><mo>,</mo>
    <msub>
     <mrow><mi>x</mi>
     </mrow>
     <mrow><mn>2</mn>
     </mrow>
    </msub><mo>;</mo>
    <msub>
     <mrow><mi>o</mi>
     </mrow>
     <mrow><mn>1</mn>
     </mrow>
    </msub>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>f</mi>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow>
    <msub>
     <mrow><mi>x</mi>
     </mrow>
     <mrow><mn>2</mn>
     </mrow>
    </msub><mo>,</mo>
    <msub>
     <mrow><mi>x</mi>
     </mrow>
     <mrow><mn>3</mn>
     </mrow>
    </msub><mo>;</mo>
    <msub>
     <mrow><mi>o</mi>
     </mrow>
     <mrow><mn>2</mn>
     </mrow>
    </msub>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math> are non-linear, as they involve the orientation of the robot. This also explains why the factor graph we created in Listing <a href="#listing_OdometryExample">2.2</a> is of type <em><b>NonlinearFactorGraph</b></em>. The optimization class linearizes this graph, possibly multiple times, to minimize the non-linear squared error specified by the factors.</div>

<div class="standard" id='magicparlabel-65451'>The relevant output from running the example is as follows:<span style='font-family:monospace;'><span style='font-size:small;'>Initial Estimate:
Values with 3 values:
Value 1: (0.5, 0, 0.2)
Value 2: (2.3, 0.1, -0.2)
Value 3: (4.1, 0.1, 0.1)

Final Result:
Values with 3 values:
Value 1: (-1.8e-16, 8.7e-18, -9.1e-19)
Value 2: (2, 7.4e-18, -2.5e-18)
Value 3: (4, -1.8e-18, -3.1e-18)
</span></span></div>

<div class="standard" id='magicparlabel-65452'> It can be seen that, subject to very small tolerance, the ground truth solution <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>x</mi>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
   </msub><mo>=</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>0</mn>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>x</mi>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msub><mo>=</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow><mn>2</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>0</mn>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>x</mi>
    </mrow>
    <mrow><mn>3</mn>
    </mrow>
   </msub><mo>=</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow><mn>4</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>0</mn>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math> is recovered.</div>
<h3 class="subsection" id='magicparlabel-65457'><span class="subsection_label">2.5</span> <a id="subsec_Full_Posterior_Inference" />
Full Posterior Inference</h3>
<div class="standard" id='magicparlabel-65458'>GTSAM can also be used to calculate the covariance matrix for each pose after incorporating the information from all measurements <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>Z</mi>
 </mrow></math>. Recognizing that the factor graph encodes the <b>posterior density</b> <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>P</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow><mi>X</mi><mo>|</mo><mi>Z</mi>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math>, the mean <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi> &mu; </mi>
 </mrow></math> together with the covariance <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mo> &Sigma; </mo>
 </mrow></math> for each pose <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>x</mi>
 </mrow></math> approximate the <b>marginal posterior density</b> <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>P</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow><mi>x</mi><mo>|</mo><mi>Z</mi>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math>. Note that this is just an approximation, as even in this simple case the odometry factors are actually non-linear in their arguments, and GTSAM only computes a Gaussian approximation to the true underlying posterior.</div>

<div class="standard" id='magicparlabel-65459'>The following C++ code will recover the posterior marginals:</div>

<div class="standard" id='magicparlabel-65460'><pre>// Query the marginals
cout.precision(2);
Marginals marginals(graph, result);
cout &lt;&lt; "x1 covariance:\n" &lt;&lt; marginals.marginalCovariance(1) &lt;&lt; endl;
cout &lt;&lt; "x2 covariance:\n" &lt;&lt; marginals.marginalCovariance(2) &lt;&lt; endl;
cout &lt;&lt; "x3 covariance:\n" &lt;&lt; marginals.marginalCovariance(3) &lt;&lt; endl;
</pre>The relevant output from running the example is as follows:<span style='font-size:x-small;'>x1 covariance:
       0.09     1.1e-47     5.7e-33
    1.1e-47        0.09     1.9e-17
    5.7e-33     1.9e-17        0.01
x2 covariance:
       0.13     4.7e-18     2.4e-18
    4.7e-18        0.17        0.02
    2.4e-18        0.02        0.02
x3 covariance:
       0.17     2.7e-17     8.4e-18
    2.7e-17        0.37        0.06
    8.4e-18        0.06        0.03
</span></div>

<div class="standard" id='magicparlabel-65461'> What we see is that the marginal covariance <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>P</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow>
    <msub>
     <mrow><mi>x</mi>
     </mrow>
     <mrow><mn>1</mn>
     </mrow>
    </msub><mo>|</mo><mi>Z</mi>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math> on <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>x</mi>
   </mrow>
   <mrow><mn>1</mn>
   </mrow>
  </msub>
 </mrow></math> is simply the prior knowledge on <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>x</mi>
   </mrow>
   <mrow><mn>1</mn>
   </mrow>
  </msub>
 </mrow></math>, but as the robot moves the uncertainty in all dimensions grows without bound, and the <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>y</mi>
 </mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi> &theta; </mi>
 </mrow></math> components of the pose become (positively) correlated.</div>

<div class="standard" id='magicparlabel-65466'>An important fact to note when interpreting these numbers is that covariance matrices are given in <em>relative</em> coordinates, not absolute coordinates. This is because internally GTSAM optimizes for a change with respect to a linearization point, as do all nonlinear optimization libraries.</div>
<h2 class="section" id='magicparlabel-65467'><span class="section_label">3</span> Robot Localization</h2>
<h3 class="subsection" id='magicparlabel-65468'><span class="subsection_label">3.1</span> Unary Measurement Factors</h3>
<div class="standard" id='magicparlabel-65469'>In this section we add measurements to the factor graph that will help us actually <em>localize</em> the robot over time. The example also serves as a tutorial on creating new factor types.</div>


<div class='float-figure'><div class="plain_layout" style='text-align: center;' id='magicparlabel-65474'><img style='width:80%;' src='intro-images/5_Users_dellaert_git_github_doc_images_FactorGraph2.png' alt='image: 5_Users_dellaert_git_github_doc_images_FactorGraph2.png' />
<span class='float-caption-Standard float-caption float-caption-standard'>Figure 4:  <a id="fig_LocalizationFG" />
Robot localization factor graph with unary measurement factors at each time step.</span></div>
</div>


<div class="standard" id='magicparlabel-65479'> In particular, we use <b>unary measurement factors</b> to handle external measurements. The example from Section <a href="#sec_Robot_Localization">2</a> is not very useful on a real robot, because it only contains factors corresponding to odometry measurements. These are imperfect and will lead to quickly accumulating uncertainty on the last robot pose, at least in the absence of any external measurements (see Section <a href="#subsec_Full_Posterior_Inference">2.5</a>). Figure <a href="#fig_LocalizationFG">4</a> shows a new factor graph where the prior <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>f</mi>
    </mrow>
    <mrow><mn>0</mn>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <msub>
    <mrow><mi>x</mi>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
   </msub>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math> is omitted and instead we added three unary factors <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>f</mi>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow>
    <msub>
     <mrow><mi>x</mi>
     </mrow>
     <mrow><mn>1</mn>
     </mrow>
    </msub><mo>;</mo>
    <msub>
     <mrow><mi>z</mi>
     </mrow>
     <mrow><mn>1</mn>
     </mrow>
    </msub>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>f</mi>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow>
    <msub>
     <mrow><mi>x</mi>
     </mrow>
     <mrow><mn>2</mn>
     </mrow>
    </msub><mo>;</mo>
    <msub>
     <mrow><mi>z</mi>
     </mrow>
     <mrow><mn>2</mn>
     </mrow>
    </msub>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>f</mi>
    </mrow>
    <mrow><mn>3</mn>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow>
    <msub>
     <mrow><mi>x</mi>
     </mrow>
     <mrow><mn>3</mn>
     </mrow>
    </msub><mo>;</mo>
    <msub>
     <mrow><mi>z</mi>
     </mrow>
     <mrow><mn>3</mn>
     </mrow>
    </msub>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math>, one for each localization measurement <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>z</mi>
   </mrow>
   <mrow><mi>t</mi>
   </mrow>
  </msub>
 </mrow></math>, respectively. Such unary factors are applicable for measurements <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>z</mi>
   </mrow>
   <mrow><mi>t</mi>
   </mrow>
  </msub>
 </mrow></math> that depend <em>only</em> on the current robot pose, e.g., GPS readings, correlation of a laser range-finder in a pre-existing map, or indeed the presence of absence of ceiling lights (see <a href='#LyXCite-Dellaert99b'><span class="bib-abbrvciteauthor">Dellaert et al.</span></a> (<span class="bib-year">1999</span>) for that amusing example).</div>
<h3 class="subsection" id='magicparlabel-65484'><span class="subsection_label">3.2</span> Defining Custom Factors</h3>
<div class="standard" id='magicparlabel-65485'>In GTSAM, you can create custom unary factors by deriving a new class from the built-in class <em><b>NoiseModelFactor1&lt;T&gt;</b></em>, which implements a unary factor corresponding to a measurement likelihood with a Gaussian noise model,<div class='math'>L(q;m)=exp\left\{ -\frac{1}{2}\SqrMah{h(q)}{m}{\Sigma}\right\} \define f(q)</div>
where <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>m</mi>
 </mrow></math> is the measurement, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>q</mi>
 </mrow></math> is the unknown variable, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
<mi>q</mi>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math> is a (possibly nonlinear) measurement function, and <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mo> &Sigma; </mo>
 </mrow></math> is the noise covariance. Note that <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>m</mi>
 </mrow></math> is considered <em>known</em> above, and the likelihood <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>L</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow><mi>q</mi><mo>;</mo><mi>m</mi>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math> will only ever be evaluated as a function of <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>q</mi>
 </mrow></math>, which explains why it is a unary factor <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>f</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
<mi>q</mi>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math>. It is always the unknown variable <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>q</mi>
 </mrow></math> that is either likely or unlikely, given the measurement. </div>

<div class="standard" id='magicparlabel-65490'><b>Note: </b>many people get this backwards, often misled by the conditional density notation <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>P</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow><mi>m</mi><mo>|</mo><mi>q</mi>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math>. In fact, the likelihood <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>L</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow><mi>q</mi><mo>;</mo><mi>m</mi>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math> is <em>defined</em> as any function of <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>q</mi>
 </mrow></math> proportional to <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>P</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow><mi>m</mi><mo>|</mo><mi>q</mi>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math>.</div>

<div class="standard" id='magicparlabel-65491'>Listing <a href="#listing_LocalizationFactor">3.2</a> shows an example on how to define the custom factor class <em><b>UnaryFactor</b></em> which implements a &ldquo;GPS-like&rdquo; measurement likelihood:</div>

<div class="standard" id='magicparlabel-65492'><pre>class UnaryFactor: public NoiseModelFactor1&lt;Pose2&gt; {
  double mx_, my_; ///&lt; X and Y measurements

public:
  UnaryFactor(Key j, double x, double y, const SharedNoiseModel&amp; model):
    NoiseModelFactor1&lt;Pose2&gt;(model, j), mx_(x), my_(y) {}

  Vector evaluateError(const Pose2&amp; q,
                       boost::optional&lt;Matrix&amp;&gt; H = boost::none) const
  {
    if (H) (*H) = (Matrix(2,3)&lt;&lt; 1.0,0.0,0.0, 0.0,1.0,0.0).finished();
    return (Vector(2) &lt;&lt; q.x() - mx_, q.y() - my_).finished();
  }
};
</pre></div>

<div class="standard" id='magicparlabel-65493'> In defining the derived class on line 1, we provide the template argument <em><b>Pose2</b></em> to indicate the type of the variable <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>q</mi>
 </mrow></math>, whereas the measurement is stored as the instance variables <em><b>mx_</b></em> and <em><b>my_</b></em>, defined on line 2. The constructor on lines 5-6 simply passes on the variable key <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>j</mi>
 </mrow></math> and the noise model to the superclass, and stores the measurement values provided. The most important function to has be implemented by every factor class is <em><b>evaluateError</b></em>, which should return <div class='math'>E(q)\define h(q)-m</div>
which is done on line 12. Importantly, because we want to use this factor for nonlinear optimization (see e.g., <a href='#LyXCite-Dellaert06ijrr'><span class="bib-abbrvciteauthor">Dellaert and Kaess</span> <span class="bib-year">2006</span></a> for details), whenever the optional argument <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>H</mi>
 </mrow></math> is provided, a <em><b>Matrix</b></em> reference, the function should assign the <b>Jacobian</b> of <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
<mi>q</mi>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math> to it, evaluated at the provided value for <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>q</mi>
 </mrow></math>. This is done for this example on line 11. In this case, the Jacobian of the 2-dimensional function <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>h</mi>
 </mrow></math>, which just returns the position of the robot, <math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
<mi>q</mi>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
<mo>=</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true' lspace='thinmathspace'>[</mo>
   <mtable>
    <mtr>
     <mtd>
      <msub>
       <mrow><mi>q</mi>
       </mrow>
       <mrow><mi>x</mi>
       </mrow>
      </msub>
     </mtd>
    </mtr>
    <mtr>
     <mtd>
      <msub>
       <mrow><mi>q</mi>
       </mrow>
       <mrow><mi>y</mi>
       </mrow>
      </msub>
     </mtd>
    </mtr>
   </mtable><mo form='postfix' fence='true' stretchy='true' symmetric='true' lspace='thinmathspace'>]</mo>
  </mrow>
 </mrow></math> with respect the 3-dimensional pose <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>q</mi><mo>=</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow>
    <msub>
     <mrow><mi>q</mi>
     </mrow>
     <mrow><mi>x</mi>
     </mrow>
    </msub><mo>,</mo>
    <msub>
     <mrow><mi>q</mi>
     </mrow>
     <mrow><mi>y</mi>
     </mrow>
    </msub><mo>,</mo>
    <msub>
     <mrow><mi>q</mi>
     </mrow>
     <mrow><mi> &theta; </mi>
     </mrow>
    </msub>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math>, yields the following simple <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mn>2</mn><mo> &times; </mo><mn>3</mn>
  </mrow>
 </mrow></math> matrix:</div>

<div class="standard" id='magicparlabel-65498'><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>H</mi><mo>=</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true' lspace='thinmathspace'>[</mo>
   <mtable>
    <mtr>
     <mtd><mn>1</mn>
     </mtd>
     <mtd><mn>0</mn>
     </mtd>
     <mtd><mn>0</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd><mn>0</mn>
     </mtd>
     <mtd><mn>1</mn>
     </mtd>
     <mtd><mn>0</mn>
     </mtd>
    </mtr>
   </mtable><mo form='postfix' fence='true' stretchy='true' symmetric='true' lspace='thinmathspace'>]</mo>
  </mrow>
 </mrow></math></div>
<h3 class="subsection" id='magicparlabel-65499'><span class="subsection_label">3.3</span> Using Custom Factors</h3>
<div class="standard" id='magicparlabel-65500'>The following C++ code fragment illustrates how to create and add custom factors to a factor graph:</div>

<div class="standard" id='magicparlabel-65501'><pre>// add unary measurement factors, like GPS, on all three poses
noiseModel::Diagonal::shared_ptr unaryNoise =
 noiseModel::Diagonal::Sigmas(Vector2(0.1, 0.1)); // 10cm std on x,y
graph.add(boost::make_shared&lt;UnaryFactor&gt;(1, 0.0, 0.0, unaryNoise));
graph.add(boost::make_shared&lt;UnaryFactor&gt;(2, 2.0, 0.0, unaryNoise));
graph.add(boost::make_shared&lt;UnaryFactor&gt;(3, 4.0, 0.0, unaryNoise));

</pre> In Listing <a href="#listing_LocalizationExample2">3.3</a>, we create the noise model on line 2-3, which now specifies two standard deviations on the measurements <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>m</mi>
   </mrow>
   <mrow><mi>x</mi>
   </mrow>
  </msub>
 </mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>m</mi>
   </mrow>
   <mrow><mi>y</mi>
   </mrow>
  </msub>
 </mrow></math>. On lines 4-6 we create <em><b>shared_ptr</b></em> versions of three newly created <em><b>UnaryFactor</b></em> instances, and add them to graph. GTSAM uses shared pointers to refer to factors in factor graphs, and <em><b>boost::make_shared</b></em> is a convenience function to simultaneously construct a class and create a <em><b>shared_ptr</b></em> to it.  We obtain the factor graph from Figure <a href="#fig_LocalizationFG">4</a>. <!-- Output Error: Closing tag `div' when other tags are pending. Discarded pending tags:
&lt;span style='font-family:monospace;'&gt;
&lt;span style='font-size:small;'&gt;
 -->
</div>
<h3 class="subsection" id='magicparlabel-65514'><span class="subsection_label">3.4</span> Full Posterior Inference</h3>
<div class="standard" id='magicparlabel-65515'>The three GPS factors are enough to fully constrain all unknown poses and tie them to a &ldquo;global&rdquo; reference frame, including the three unknown orientations. If not, GTSAM would have exited with a singular matrix exception. The marginals can be recovered exactly as in Section <a href="#subsec_Full_Posterior_Inference">2.5</a>, and the solution and marginal covariances are now given by the following:<span style='font-size:x-small;'>Final Result:
Values with 3 values:
Value 1: (-1.5e-14, 1.3e-15, -1.4e-16)
Value 2: (2, 3.1e-16, -8.5e-17)
Value 3: (4, -6e-16, -8.2e-17)

x1 covariance:
      0.0083      4.3e-19     -1.1e-18
     4.3e-19       0.0094      -0.0031
    -1.1e-18      -0.0031       0.0082
x2 covariance:
      0.0071      2.5e-19     -3.4e-19
     2.5e-19       0.0078      -0.0011
    -3.4e-19      -0.0011       0.0082
x3 covariance:
     0.0083     4.4e-19     1.2e-18
    4.4e-19      0.0094      0.0031
    1.2e-18      0.0031       0.018
</span></div>

<div class="standard" id='magicparlabel-65516'>Comparing this with the covariance matrices in Section <a href="#subsec_Full_Posterior_Inference">2.5</a>, we can see that the uncertainty no longer grows without bounds as measurement uncertainty accumulates. Instead, the &ldquo;GPS&rdquo; measurements more or less constrain the poses evenly, as expected.</div>



<div class='float-figure'><div class='float-figure'><div class="plain_layout" style='text-align: center;' id='magicparlabel-65525'><img style='width:80%;' src='intro-images/6_Users_dellaert_git_github_doc_images_Odometry.png' alt='image: 6_Users_dellaert_git_github_doc_images_Odometry.png' />
</div>

<div class="plain_layout" id='magicparlabel-65526'><span class='float-caption-Standard float-caption float-caption-standard'>Sub-Figure a:  Odometry marginals</span></div>
</div>


<div class="plain_layout" style='text-align: center;' id='magicparlabel-65531'>&nbsp;</div>

<div class="plain_layout" style='text-align: center;' id='magicparlabel-65532'><span class='float-caption-Standard float-caption float-caption-standard'>Figure 5:  <a id="fig_CompareMarginals" />
Comparing the marginals resulting from the &ldquo;odometry&rdquo; factor graph in Figure <a href="#fig_OdometryFG">3</a> and the &ldquo;localization&rdquo; factor graph in Figure <a href="#fig_LocalizationFG">4</a>.</span></div>
<div class='float-figure'><div class="plain_layout" style='text-align: center;' id='magicparlabel-65536'><img style='width:80%;' src='intro-images/7_Users_dellaert_git_github_doc_images_Localization.png' alt='image: 7_Users_dellaert_git_github_doc_images_Localization.png' />
</div>

<div class="plain_layout" id='magicparlabel-65537'><span class='float-caption-Standard float-caption float-caption-standard'>Sub-Figure b:  Localization Marginals</span></div>
</div>

</div>


<div class="standard" id='magicparlabel-65546'>It helps a lot when we view this graphically, as in Figure <a href="#fig_CompareMarginals">5</a>, where I show the marginals on position as covariance ellipses that contain 68.26% of all probability mass. For the odometry marginals, it is immediately apparent from the figure that (1) the uncertainty on pose keeps growing, and (2) the uncertainty on angular odometry translates into increasing uncertainty on y. The localization marginals, in contrast, are constrained by the unary factors and are all much smaller. In addition, while less apparent, the uncertainty on the middle pose is actually smaller as it is constrained by odometry from two sides.</div>

<div class="standard" id='magicparlabel-65547'>You might now be wondering how we produced these figures. The answer is via the MATLAB interface of GTSAM, which we will demonstrate in the next section.</div>

<div class="standard" id='magicparlabel-65548'><br />
</div>
<h2 class="section" id='magicparlabel-65549'><span class="section_label">4</span> <a id="sec_Pose2SLAM" />
<a id="sec_WithMarginals" />
PoseSLAM</h2>
<h3 class="subsection" id='magicparlabel-65550'><span class="subsection_label">4.1</span> Loop Closure Constraints</h3>
<div class="standard" id='magicparlabel-65551'>The simplest instantiation of a SLAM problem is <b>PoseSLAM</b>, which avoids building an explicit map of the environment. The goal of SLAM is to simultaneously localize a robot and map the environment given incoming sensor measurements (<a href='#LyXCite-DurrantWhyte06ram'><span class="bib-abbrvciteauthor">Durrant-Whyte and Bailey</span>, <span class="bib-year">2006</span></a>). Besides wheel odometry, one of the most popular sensors for robots moving on a plane is a 2D laser-range finder, which provides both odometry constraints between successive poses, and loop-closure constraints when the robot re-visits a previously explored part of the environment.</div>


<div class='float-figure'><div class="plain_layout" style='text-align: center;' id='magicparlabel-65556'><img style='width:80%;' src='intro-images/8_Users_dellaert_git_github_doc_images_FactorGraph3.png' alt='image: 8_Users_dellaert_git_github_doc_images_FactorGraph3.png' />
<span class='float-caption-Standard float-caption float-caption-standard'>Figure 6:  <a id="fig_Pose2SLAM" />
Factor graph for PoseSLAM.</span></div>
</div>


<div class="standard" id='magicparlabel-65561'> A factor graph example for PoseSLAM is shown in Figure <a href="#fig_Pose2SLAM">6</a>. The following C++ code, included in GTSAM as an example, creates this factor graph in code: </div>

<div class="standard" id='magicparlabel-65566'><pre>NonlinearFactorGraph graph;
noiseModel::Diagonal::shared_ptr priorNoise =
  noiseModel::Diagonal::Sigmas(Vector3(0.3, 0.3, 0.1));
graph.add(PriorFactor&lt;Pose2&gt;(1, Pose2(0, 0, 0), priorNoise));

// Add odometry factors
noiseModel::Diagonal::shared_ptr model =
  noiseModel::Diagonal::Sigmas(Vector3(0.2, 0.2, 0.1));
graph.add(BetweenFactor&lt;Pose2&gt;(1, 2, Pose2(2, 0, 0     ), model));
graph.add(BetweenFactor&lt;Pose2&gt;(2, 3, Pose2(2, 0, M_PI_2), model));
graph.add(BetweenFactor&lt;Pose2&gt;(3, 4, Pose2(2, 0, M_PI_2), model));
graph.add(BetweenFactor&lt;Pose2&gt;(4, 5, Pose2(2, 0, M_PI_2), model));

// Add the loop closure constraint
graph.add(BetweenFactor&lt;Pose2&gt;(5, 2, Pose2(2, 0, M_PI_2), model));

</pre></div>

<div class="standard" id='magicparlabel-65567'> As before, lines 1-4 create a nonlinear factor graph and add the unary factor <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>f</mi>
    </mrow>
    <mrow><mn>0</mn>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <msub>
    <mrow><mi>x</mi>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
   </msub>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math>. As the robot travels through the world, it creates binary factors <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>f</mi>
    </mrow>
    <mrow><mi>t</mi>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow>
    <msub>
     <mrow><mi>x</mi>
     </mrow>
     <mrow><mi>t</mi>
     </mrow>
    </msub><mo>,</mo>
    <msub>
     <mrow><mi>x</mi>
     </mrow>
     <mrow>
      <mrow><mi>t</mi><mo>+</mo><mn>1</mn>
      </mrow>
     </mrow>
    </msub>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math> corresponding to odometry, added to the graph in lines 6-12 (Note that M_PI_2 refers to pi/2). But line 15 models a different event: a <b>loop closure</b>. For example, the robot might recognize the same location using vision or a laser range finder, and calculate the geometric pose constraint to when it first visited this location. This is illustrated for poses <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>x</mi>
   </mrow>
   <mrow><mn>5</mn>
   </mrow>
  </msub>
 </mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>x</mi>
   </mrow>
   <mrow><mn>2</mn>
   </mrow>
  </msub>
 </mrow></math>, and generates the (red) loop closing factor <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>f</mi>
    </mrow>
    <mrow><mn>5</mn>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow>
    <msub>
     <mrow><mi>x</mi>
     </mrow>
     <mrow><mn>5</mn>
     </mrow>
    </msub><mo>,</mo>
    <msub>
     <mrow><mi>x</mi>
     </mrow>
     <mrow><mn>2</mn>
     </mrow>
    </msub>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math>.</div>


<div class='float-figure'><div class="plain_layout" style='text-align: center;' id='magicparlabel-65576'><img style='width:80%;' src='intro-images/9_Users_dellaert_git_github_doc_images_example1.png' alt='image: 9_Users_dellaert_git_github_doc_images_example1.png' />
<span class='float-caption-Standard float-caption float-caption-standard'>Figure 7:  <a id="fig_example" />
The result of running optimize on the factor graph in Figure <a href="#fig_Pose2SLAM">6</a>.</span></div>
</div>


<div class="standard" id='magicparlabel-65581'>We can optimize this factor graph as before, by creating an initial estimate of type <em><b>Values</b></em>, and creating and running an optimizer. The result is shown graphically in Figure <a href="#fig_example">7</a>, along with covariance ellipses shown in green. These covariance ellipses in 2D indicate the marginal over position, over all possible orientations, and show the area which contain 68.26% of the probability mass (in 1D this would correspond to one standard deviation). The graph shows in a clear manner that the uncertainty on pose <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>x</mi>
   </mrow>
   <mrow><mn>5</mn>
   </mrow>
  </msub>
 </mrow></math> is now much less than if there would be only odometry measurements. The pose with the highest uncertainty, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>x</mi>
   </mrow>
   <mrow><mn>4</mn>
   </mrow>
  </msub>
 </mrow></math>, is the one furthest away from the unary constraint <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>f</mi>
    </mrow>
    <mrow><mn>0</mn>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <msub>
    <mrow><mi>x</mi>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
   </msub>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math>, which is the only factor tying the graph to a global coordinate frame.</div>

<div class="standard" id='magicparlabel-65582'>The figure above was created using an interface that allows you to use GTSAM from within MATLAB, which provides for visualization and rapid development. We discuss this next.</div>
<h3 class="subsection" id='magicparlabel-65583'><span class="subsection_label">4.2</span> Using the MATLAB Interface</h3>
<div class="standard" id='magicparlabel-65584'>A large subset of the GTSAM functionality can be accessed through wrapped classes from within MATLAB <div class="foot"><span class="foot_label">1</span><div class="foot_inner"><div class="plain_layout" id='magicparlabel-65588'>GTSAM also allows you to wrap your own custom-made classes, although this is outside the scope of this manual</div>
</div></div>. The following code excerpt is the MATLAB equivalent of the C++ code in Listing <a href="#listing_Pose2SLAMExample">4.1</a>:<pre>graph = NonlinearFactorGraph;
priorNoise = noiseModel.Diagonal.Sigmas([0.3; 0.3; 0.1]);
graph.add(PriorFactorPose2(1, Pose2(0, 0, 0), priorNoise));

%% Add odometry factors
model = noiseModel.Diagonal.Sigmas([0.2; 0.2; 0.1]);
graph.add(BetweenFactorPose2(1, 2, Pose2(2, 0, 0   ), model));
graph.add(BetweenFactorPose2(2, 3, Pose2(2, 0, pi/2), model));
graph.add(BetweenFactorPose2(3, 4, Pose2(2, 0, pi/2), model));
graph.add(BetweenFactorPose2(4, 5, Pose2(2, 0, pi/2), model));

%% Add pose constraint
graph.add(BetweenFactorPose2(5, 2, Pose2(2, 0, pi/2), model));

</pre></div>

<div class="standard" id='magicparlabel-65589'> Note that the code is almost identical, although there are a few syntax and naming differences:</div>

<ul class="itemize" id='magicparlabel-65594'><li class="itemize_item">Objects are created by calling a constructor instead of allocating them on the heap.</li>
<li class="itemize_item">Namespaces are done using dot notation, i.e., <em><b>noiseModel::Diagonal::SigmasClasses</b></em> becomes <em><b>noiseModel.Diagonal.Sigmas</b></em>.</li>
<li class="itemize_item"><em><b>Vector</b></em> and <em><b>Matrix</b></em> classes in C++ are just vectors/matrices in MATLAB.</li>
<li class="itemize_item">As templated classes do not exist in MATLAB, these have been hardcoded in the GTSAM interface, e.g., <em><b>PriorFactorPose2</b></em> corresponds to the C++ class <em><b>PriorFactor&lt;Pose2&gt;</b></em>, etc.</li>
</ul>
<div class="standard" id='magicparlabel-65598'>After executing the code, you can call <em>whos </em>on the MATLAB command prompt to see the objects created. Note that the indicated <em>Class</em> corresponds to the wrapped C++ classes:<span style='font-size:small;'>&gt;&gt; whos
  Name                 Size            Bytes  Class
  graph                1x1               112  gtsam.NonlinearFactorGraph
  priorNoise           1x1               112  gtsam.noiseModel.Diagonal
  model                1x1               112  gtsam.noiseModel.Diagonal
  initialEstimate      1x1               112  gtsam.Values                                   
  optimizer            1x1               112  gtsam.LevenbergMarquardtOptimizer              
</span> In addition, any GTSAM object can be examined in detail, yielding identical output to C++:<span style='font-size:small;'> &gt;&gt; priorNoise
diagonal sigmas [0.3; 0.3; 0.1];

&gt;&gt; graph
size: 6
factor 0: PriorFactor on 1
  prior mean: (0, 0, 0)
  noise model: diagonal sigmas [0.3; 0.3; 0.1];
factor 1: BetweenFactor(1,2)
  measured: (2, 0, 0)
  noise model: diagonal sigmas [0.2; 0.2; 0.1];
factor 2: BetweenFactor(2,3)
  measured: (2, 0, 1.6)
  noise model: diagonal sigmas [0.2; 0.2; 0.1];
factor 3: BetweenFactor(3,4)
  measured: (2, 0, 1.6)
  noise model: diagonal sigmas [0.2; 0.2; 0.1];
factor 4: BetweenFactor(4,5)
  measured: (2, 0, 1.6)
  noise model: diagonal sigmas [0.2; 0.2; 0.1];
factor 5: BetweenFactor(5,2)
  measured: (2, 0, 1.6)
  noise model: diagonal sigmas [0.2; 0.2; 0.1];
</span> And it does not stop there: we can also call some of the functions defined for factor graphs. E.g.,</div>

<div class="standard" id='magicparlabel-65607'><span style='font-size:small;'>&gt;&gt; graph.error(initialEstimate)
ans =
   20.1086

&gt;&gt; graph.error(result)
ans =
   8.2631e-18
</span> computes the sum-squared error <span class='math'>\frac{1}{2}\sum_{i}\SqrMah{h_{i}(X_{i})}{z_{i}}{\Sigma}</span>
 before and after optimization.</div>
<h3 class="subsection" id='magicparlabel-65612'><span class="subsection_label">4.3</span> Reading and Optimizing Pose Graphs </h3>

<div class='float-figure'><div class="plain_layout" style='text-align: center;' id='magicparlabel-65617'><img style='width:80%;' src='intro-images/10_Users_dellaert_git_github_doc_images_w100-result.png' alt='image: 10_Users_dellaert_git_github_doc_images_w100-result.png' />
<span class='float-caption-Standard float-caption float-caption-standard'>Figure 8:  <a id="fig_w100" />
MATLAB plot of small Manhattan world example with 100 poses (due to Ed Olson). The initial estimate is shown in green. The optimized trajectory, with covariance ellipses, in blue.</span></div>
</div>


<div class="standard" id='magicparlabel-65622'>The ability to work in MATLAB adds a much quicker development cycle, and effortless graphical output. The optimized trajectory in Figure <a href="#fig_w100">8</a> was produced by the code below, in which <em>load2D</em> reads TORO files. To see how plotting is done, refer to the full source code.<pre>%% Initialize graph, initial estimate, and odometry noise
datafile = findExampleDataFile('w100.graph');
model = noiseModel.Diagonal.Sigmas([0.05; 0.05; 5*pi/180]);
[graph,initial] = load2D(datafile, model);

%% Add a Gaussian prior on pose x_0
priorMean = Pose2(0, 0, 0);
priorNoise = noiseModel.Diagonal.Sigmas([0.01; 0.01; 0.01]);
graph.add(PriorFactorPose2(0, priorMean, priorNoise));

%% Optimize using Levenberg-Marquardt optimization and get marginals
optimizer = LevenbergMarquardtOptimizer(graph, initial);
result = optimizer.optimizeSafely;
marginals = Marginals(graph, result);

</pre></div>
<h3 class="subsection" id='magicparlabel-65623'><span class="subsection_label">4.4</span> PoseSLAM in 3D</h3>
<div class="standard" id='magicparlabel-65624'>PoseSLAM can easily be extended to 3D poses, but some care is needed to update 3D rotations. GTSAM supports both <b>quaternions</b> and <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mn>3</mn><mo> &times; </mo><mn>3</mn>
  </mrow>
 </mrow></math> <b>rotation matrices </b>to represent 3D rotations. The selection is made via the compile flag GTSAM_USE_QUATERNIONS.</div>


<div class='float-figure'><div class="plain_layout" style='text-align: center;' id='magicparlabel-65629'><img style='width:70%;' src='intro-images/11_Users_dellaert_git_github_doc_images_sphere2500-result.png' alt='image: 11_Users_dellaert_git_github_doc_images_sphere2500-result.png' />
<span class='float-caption-Standard float-caption float-caption-standard'>Figure 9:  <a id="fig_w100_1" />
3D plot of sphere example (due to Michael Kaess). The very wrong initial estimate, derived from odometry, is shown in green. The optimized trajectory is shown red. Code below:</span></div>
</div>


<div class="standard" id='magicparlabel-65634'><pre>%% Initialize graph, initial estimate, and odometry noise
datafile = findExampleDataFile('sphere2500.txt');
model = noiseModel.Diagonal.Sigmas([5*pi/180; 5*pi/180; 5*pi/180; 0.05; 0.05; 0.05]);
[graph,initial] = load3D(datafile, model, true, 2500);
plot3DTrajectory(initial, 'g-', false); % Plot Initial Estimate

%% Read again, now with all constraints, and optimize
graph = load3D(datafile, model, false, 2500);
graph.add(NonlinearEqualityPose3(0, initial.atPose3(0)));
optimizer = LevenbergMarquardtOptimizer(graph, initial);
result = optimizer.optimizeSafely();
plot3DTrajectory(result, 'r-', false); axis equal;
</pre></div>
<h2 class="section" id='magicparlabel-65635'><span class="section_label">5</span> <a id="sec_Landmark_based_SLAM" />
Landmark-based SLAM</h2>
<h3 class="subsection" id='magicparlabel-65636'><span class="subsection_label">5.1</span> Basics</h3>

<div class='float-figure'><div class="plain_layout" style='text-align: center;' id='magicparlabel-65641'><img style='width:80%;' src='intro-images/12_Users_dellaert_git_github_doc_images_FactorGraph4.png' alt='image: 12_Users_dellaert_git_github_doc_images_FactorGraph4.png' />
<span class='float-caption-Standard float-caption float-caption-standard'>Figure 10:  <a id="fig_SLAM" />
Factor graph for landmark-based SLAM</span></div>
</div>


<div class="standard" id='magicparlabel-65646'> In <b>landmark-based SLAM</b>, we explicitly build a map with the location of observed landmarks, which introduces a second type of variable in the factor graph besides robot poses. An example factor graph for a landmark-based SLAM example is shown in Figure <a href="#fig_SLAM">10</a>, which shows the typical connectivity: poses are connected in an odometry Markov chain, and landmarks are observed from multiple poses, inducing binary factors. In addition, the pose <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>x</mi>
   </mrow>
   <mrow><mn>1</mn>
   </mrow>
  </msub>
 </mrow></math> has the usual prior on it.</div>


<div class='float-figure'><div class="plain_layout" style='text-align: center;' id='magicparlabel-65655'><img style='width:47%;' src='intro-images/13_Users_dellaert_git_github_doc_images_example2.png' alt='image: 13_Users_dellaert_git_github_doc_images_example2.png' />
<span class='float-caption-Standard float-caption float-caption-standard'>Figure 11:  <a id="fig_PlanarSLAMExample" />
The optimized result along with covariance ellipses for both poses (in green) and landmarks (in blue). Also shown are the trajectory (red) and landmark sightings (cyan).</span></div>
</div>


<div class="standard" id='magicparlabel-65660'>The factor graph from Figure <a href="#fig_SLAM">10</a> can be created using the MATLAB code in Listing <a href="#listing_PlanarSLAMExample">5.1</a>. As before, on line 2 we create the factor graph, and Lines 8-18 create the prior/odometry chain we are now familiar with. However, the code on lines 20-25 is new: it creates three <b>measurement factors</b>, in this case &ldquo;bearing/range&rdquo; measurements from the pose to the landmark.</div>

<div class="standard" id='magicparlabel-65661'><br />
</div>

<div class="standard" id='magicparlabel-65662'><pre>% Create graph container and add factors to it
graph = NonlinearFactorGraph;

% Create keys for variables
i1 = symbol('x',1); i2 = symbol('x',2); i3 = symbol('x',3);
j1 = symbol('l',1); j2 = symbol('l',2);

% Add prior
priorMean = Pose2(0.0, 0.0, 0.0); % prior at origin
priorNoise = noiseModel.Diagonal.Sigmas([0.3; 0.3; 0.1]);
% add directly to graph
graph.add(PriorFactorPose2(i1, priorMean, priorNoise));

% Add odometry
odometry = Pose2(2.0, 0.0, 0.0);
odometryNoise = noiseModel.Diagonal.Sigmas([0.2; 0.2; 0.1]);
graph.add(BetweenFactorPose2(i1, i2, odometry, odometryNoise));
graph.add(BetweenFactorPose2(i2, i3, odometry, odometryNoise));

% Add bearing/range measurement factors
degrees = pi/180;
brNoise = noiseModel.Diagonal.Sigmas([0.1; 0.2]);
graph.add(BearingRangeFactor2D(i1, j1, Rot2(45*degrees), sqrt(8), brNoise));
graph.add(BearingRangeFactor2D(i2, j1, Rot2(90*degrees), 2, brNoise));
graph.add(BearingRangeFactor2D(i3, j2, Rot2(90*degrees), 2, brNoise));
</pre></div>
<h3 class="subsection" id='magicparlabel-65663'><span class="subsection_label">5.2</span> Of Keys and Symbols</h3>
<div class="standard" id='magicparlabel-65664'> The only unexplained code is on lines 4-6: here we create integer keys for the poses and landmarks using the <em><b>symbol</b></em> function. In GTSAM, we address all variables using the <em><b>Ke</b></em><b>y</b> type, which is just a typedef to <em><b>size_t</b></em><div class="foot"><span class="foot_label">2</span><div class="foot_inner"><div class="plain_layout" id='magicparlabel-65672'>a 32 or 64 bit integer, depending on your platform</div>
</div></div>. The keys do not have to be numbered continuously, but they do have to be unique within a given factor graph. For factor graphs with different types of variables, we provide the <em><b>symbol</b></em> function in MATLAB, and the <em><b>Symbol</b></em> type in C++, to help you create (large) integer keys that are far apart in the space of possible keys, so you don't have to think about starting the point numbering at some arbitrary offset. To create a a <em>symbol key</em> you simply provide a character and an integer index. You can use base 0 or 1, or use arbitrary indices: it does not matter. In the code above, we we use 'x' for poses, and 'l' for landmarks.</div>

<div class="standard" id='magicparlabel-65677'>The optimized result for the factor graph created by Listing <a href="#listing_PlanarSLAMExample">5.1</a> is shown in Figure <a href="#fig_PlanarSLAMExample">11</a>, and it is readily apparent that the landmark <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>l</mi>
   </mrow>
   <mrow><mn>1</mn>
   </mrow>
  </msub>
 </mrow></math> with two measurements is better localized. In MATLAB we can also examine the actual numerical values, and doing so reveals some more GTSAM magic:</div>

<div class="standard" id='magicparlabel-65678'><span style='font-size:small;'>&gt;&gt; result
Values with 5 values:
  l1: (2, 2)
  l2: (4, 2)
  x1: (-1.8e-16, 5.1e-17, -1.5e-17)
  x2: (2, -5.8e-16, -4.6e-16)
  x3: (4, -3.1e-15, -4.6e-16)
</span></div>

<div class="standard" id='magicparlabel-65679'> Indeed, the keys generated by symbol are automatically detected by the <em><b>print</b></em> method in the <em><b>Values</b></em> class, and rendered in human-readable form &ldquo;x1&rdquo;, &ldquo;l2&rdquo;, etc, rather than as large, unwieldy integers. This magic extends to most factors and other classes where the <b>Key</b> type is used.</div>
<h3 class="subsection" id='magicparlabel-65684'><span class="subsection_label">5.3</span> A Larger Example</h3>

<div class='float-figure'><div class="plain_layout" style='text-align: center;' id='magicparlabel-65689'><img style='width:90%;' src='intro-images/14_Users_dellaert_git_github_doc_images_littleRobot.png' alt='image: 14_Users_dellaert_git_github_doc_images_littleRobot.png' />
<span class='float-caption-Standard float-caption float-caption-standard'>Figure 12:  <a id="fig_littleRobot" />
A larger example with about 100 poses and 30 or so landmarks, as produced by gtsam_examples/PlanarSLAMExample_graph.m</span></div>
</div>


<div class="standard" id='magicparlabel-65694'>GTSAM comes with a slightly larger example that is read from a .graph file by PlanarSLAMExample_graph.m, shown in Figure <a href="#fig_littleRobot">12</a>. To not clutter the figure only the marginals are shown, not the lines of sight. This example, with 119 (multivariate) variables and 517 factors optimizes in less than 10 ms.</div>
<h3 class="subsection" id='magicparlabel-65695'><span class="subsection_label">5.4</span> A Real-World Example</h3>

<div class='float-figure'><div class="plain_layout" style='text-align: center;' id='magicparlabel-65700'><img style='width:90%;' src='intro-images/15_Users_dellaert_git_github_doc_images_Victoria.png' alt='image: 15_Users_dellaert_git_github_doc_images_Victoria.png' />
<span class='float-caption-Standard float-caption float-caption-standard'>Figure 13:  <a id="fig_Victoria_1" />
Small section of optimized trajectory and landmarks (trees detected in a laser range finder scan) from data recorded in Sydney's Victoria Park (dataset due to Jose Guivant, U. Sydney).</span></div>
</div>


<div class="standard" id='magicparlabel-65705'>A real-world example is shown in Figure <a href="#fig_Victoria_1">13</a>, using data from a well known dataset collected in Sydney's Victoria Park, using a truck equipped with a laser range-finder. The covariance matrices in this figure were computed very efficiently, as explained in detail in (<a href='#LyXCite-Kaess09ras'><span class="bib-abbrvciteauthor">Kaess and Dellaert</span>, <span class="bib-year">2009</span></a>). The exact covariances (blue, smaller ellipses) obtained by our fast algorithm coincide with the exact covariances based on full inversion (orange, mostly hidden by blue). The much larger conservative covariance estimates (green, large ellipses) were based on our earlier work in (<a href='#LyXCite-Kaess08tro'><span class="bib-abbrvciteauthor">Kaess et al.</span>, <span class="bib-year">2008</span></a>).</div>

<div class="standard" id='magicparlabel-65706'><br />
</div>
<h2 class="section" id='magicparlabel-65707'><span class="section_label">6</span> Structure from Motion</h2>

<div class='float-figure'><div class="plain_layout" style='text-align: center;' id='magicparlabel-65712'><img style='width:80%;' src='intro-images/16_Users_dellaert_git_github_doc_images_cube.png' alt='image: 16_Users_dellaert_git_github_doc_images_cube.png' />
<span class='float-caption-Standard float-caption float-caption-standard'>Figure 14:  <a id="fig_SFMExample" />
An optimized &ldquo;Structure from Motion&rdquo; with 10 cameras arranged in a circle, observing the 8 vertices of a <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mn>20</mn><mo> &times; </mo><mn>20</mn><mo> &times; </mo><mn>20</mn>
  </mrow>
 </mrow></math> cube centered around the origin. The camera is rendered with color-coded axes, (RGB for XYZ) and the viewing direction is is along the positive Z-axis. Also shown are the 3D error covariance ellipses for both cameras and points.</span></div>
</div>


<div class="standard" id='magicparlabel-65717'><b> Structure from Motion</b> (SFM) is a technique to recover a 3D reconstruction of the environment from corresponding visual features in a collection of <em>unordered</em> images, see Figure <a href="#fig_SFMExample">14</a>. In GTSAM this is done using exactly the same factor graph framework, simply using SFM-specific measurement factors. In particular, there is a <b>projection factor</b> that calculates the reprojection error <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>f</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

   <mrow>
    <msub>
     <mrow><mi>x</mi>
     </mrow>
     <mrow><mi>i</mi>
     </mrow>
    </msub><mo>,</mo>
    <msub>
     <mrow><mi>p</mi>
     </mrow>
     <mrow><mi>j</mi>
     </mrow>
    </msub><mo>;</mo>
    <msub>
     <mrow><mi>z</mi>
     </mrow>
     <mrow>
      <mrow><mi>i</mi><mi>j</mi>
      </mrow>
     </mrow>
    </msub><mo>,</mo><mi>K</mi>
   </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

  </mrow>
 </mrow></math> for a given camera pose <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>x</mi>
   </mrow>
   <mrow><mi>i</mi>
   </mrow>
  </msub>
 </mrow></math> (a <em><b>Pose3</b></em>) and point <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>p</mi>
   </mrow>
   <mrow><mi>j</mi>
   </mrow>
  </msub>
 </mrow></math> (a <em><b>Point3</b></em>). The factor is parameterized by the 2D measurement <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>z</mi>
   </mrow>
   <mrow>
    <mrow><mi>i</mi><mi>j</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math> (a <em><b>Point2</b></em>), and known calibration parameters <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>K</mi>
 </mrow></math> (of type <em><b>Cal3_S2</b></em>). The following listing shows how to create the factor graph: <pre>%% Add factors for all measurements
noise = noiseModel.Isotropic.Sigma(2, measurementNoiseSigma);
for i = 1:length(Z), 
    for k = 1:length(Z{i})
        j = J{i}{k};
        G.add(GenericProjectionFactorCal3_S2(
              Z{i}{k}, noise, symbol('x', i), symbol('p', j), K));
    end
end
</pre></div>

<div class="standard" id='magicparlabel-65722'> In Listing <a href="#listing_SFMExample">6</a>, assuming that the factor graph was already created, we add measurement factors in the double loop. We loop over images with index <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>i</mi>
 </mrow></math>, and in this example the data is given as two cell arrays: Z{i} specifies a set of measurements <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>z</mi>
   </mrow>
   <mrow><mi>k</mi>
   </mrow>
  </msub>
 </mrow></math> in image <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>i</mi>
 </mrow></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>J</mi>{<mi>i</mi>}
  </mrow>
 </mrow></math> specifies the corresponding point index. The specific factor type we use is a <em><b>GenericProjectionFactorCal3_S2</b></em>, which is the MATLAB equivalent of the C++ class <em><b>GenericProjectionFactor&lt;Cal3_S2&gt;</b></em>, where <em><b>Cal3_S2</b></em> is the camera calibration type we choose to use (the standard, no-radial distortion, 5 parameter calibration matrix). As before landmark-based SLAM (Section <a href="#sec_Landmark_based_SLAM">5</a>), here we use symbol keys except we now use the character 'p' to denote points, rather than 'l' for landmark.</div>

<div class="standard" id='magicparlabel-65727'>Important note: a very tricky and difficult part of making SFM work is (a) data association, and (b) initialization. GTSAM does neither of these things for you: it simply provides the &ldquo;bundle adjustment&rdquo; optimization. In the example, we simply assume the data association is known (it is encoded in the J sets), and we initialize with the ground truth, as the intent of the example is simply to show you how to set up the optimization problem.</div>
<h2 class="section" id='magicparlabel-65728'><span class="section_label">7</span> iSAM: Incremental Smoothing and Mapping</h2>
<div class="standard" id='magicparlabel-65729'>GTSAM provides an incremental inference algorithm based on a more advanced graphical model, the Bayes tree, which is kept up to date by the <b>iSAM</b> algorithm (incremental Smoothing and Mapping, see <a href='#LyXCite-Kaess08tro'><span class="bib-abbrvciteauthor">Kaess et al.</span></a> (<span class="bib-year">2008</span>); <a href='#LyXCite-Kaess12ijrr'><span class="bib-abbrvciteauthor">Kaess et al.</span></a> (<span class="bib-year">2012</span>) for an in-depth treatment). For mobile robots operating in real-time it is important to have access to an updated map as soon as new sensor measurements come in. iSAM keeps the map up-to-date in an efficient manner. </div>

<div class="standard" id='magicparlabel-65730'>Listing <a href="#listing_iSAMExample">7</a> shows how to use iSAM in a simple visual SLAM example. In line 1-2 we create a <em><b>NonlinearISAM</b></em> object which will relinearize and reorder the variables every 3 steps. The corect value for this parameter depends on how non-linear your problem is and how close you want to be to gold-standard solution at every step. In iSAM 2.0, this parameter is not needed, as iSAM2 automatically determines when linearization is needed and for which variables.</div>

<div class="standard" id='magicparlabel-65731'>The example involves eight 3D points that are seen from eight successive camera poses. Hence in the first step -which is omitted here- all eight landmarks and the first pose are properly initialized. In the code this is done by perturbing the known ground truth, but in a real application great care is needed to properly initialize poses and landmarks, especially in a monocular sequence.</div>

<div class="standard" id='magicparlabel-65732'><br />
<pre>int relinearizeInterval = 3;
NonlinearISAM isam(relinearizeInterval);

// ... first frame initialization omitted ...

// Loop over the different poses, adding the observations to iSAM
for (size_t i = 1; i &lt; poses.size(); ++i) {

  // Add factors for each landmark observation
  NonlinearFactorGraph graph;
  for (size_t j = 0; j &lt; points.size(); ++j) {
    graph.add(
      GenericProjectionFactor&lt;Pose3, Point3, Cal3_S2&gt;
        (z[i][j], noise,Symbol('x', i), Symbol('l', j), K)
    );
  }

  // Add an initial guess for the current pose
  Values initialEstimate;
  initialEstimate.insert(Symbol('x', i), initial_x[i]);

  // Update iSAM with the new factors
  isam.update(graph, initialEstimate);
 }
</pre></div>

<div class="standard" id='magicparlabel-65733'>The remainder of the code illustrates a typical iSAM loop:</div>

<ol class="enumerate" id='magicparlabel-65734'><li class="enumerate_item">Create factors for new measurements. Here, in lines 9-18, a small <em><b>NonlinearFactorGraph</b></em> is created to hold the new factors of type <em><b>GenericProjectionFactor&lt;Pose3, Point3, Cal3_S2&gt;</b></em>.</li>
<li class="enumerate_item">Create an initial estimate for all newly introduced variables. In this small example, all landmarks have been observed in frame 1 and hence the only new variable that needs to be initialized at each time step is the new pose. This is done in lines 20-22. Note we assume a good initial estimate is available as <em>initial_x[i]</em>.</li>
<li class="enumerate_item">Finally, we call <em>isam.update()</em>, which takes the factors and initial estimates, and incrementally updates the solution, which is available through the method <em>isam.estimate()</em>, if desired.</li>
</ol>
<div class="standard" id='magicparlabel-65737'><br />
</div>
<h2 class="section" id='magicparlabel-65738'><span class="section_label">8</span> More Applications</h2>
<div class="standard" id='magicparlabel-65739'>While a detailed discussion of all the things you can do with GTSAM will take us too far, below is a small survey of what you can expect to do, and which we did using GTSAM.</div>


<h3 class="subsection" id='magicparlabel-65754'><span class="subsection_label">8.1</span> Conjugate Gradient Optimization</h3>

<div class='float-figure'><div class="plain_layout" style='text-align: center;' id='magicparlabel-65759'><img style='width:70%;' src='intro-images/17_Users_dellaert_git_github_doc_images_Beijing.png' alt='image: 17_Users_dellaert_git_github_doc_images_Beijing.png' />
<span class='float-caption-Standard float-caption float-caption-standard'>Figure 15:  <a id="fig_Beijing" />
 A map of Beijing, with a spanning tree shown in black, and the remaining <em>loop-closing</em> constraints shown in red. A spanning tree can be used as a <em>preconditioner</em> by GTSAM.</span></div>
</div>


<div class="standard" id='magicparlabel-65764'>GTSAM also includes efficient preconditioned conjugate gradients (PCG) methods for solving large-scale SLAM problems. While direct methods, popular in the literature, exhibit quadratic convergence and can be quite efficient for sparse problems, they typically require a lot of storage and efficient elimination orderings to be found. In contrast, iterative optimization methods only require access to the gradient and have a small memory footprint, but can suffer from poor convergence. Our method, <em>subgraph preconditioning</em>, explained in detail in <a href='#LyXCite-Dellaert10iros'><span class="bib-abbrvciteauthor">Dellaert et al.</span></a> (<span class="bib-year">2010</span>); <a href='#LyXCite-Jian11iccv'><span class="bib-abbrvciteauthor">Jian et al.</span></a> (<span class="bib-year">2011</span>), combines the advantages of direct and iterative methods, by identifying a sub-problem that can be easily solved using direct methods, and solving for the remaining part using PCG. The easy sub-problems correspond to a spanning tree, a planar subgraph, or any other substructure that can be efficiently solved. An example of such a subgraph is shown in Figure <a href="#fig_Beijing">15</a>.</div>
<h3 class="subsection" id='magicparlabel-65765'><span class="subsection_label">8.2</span> Visual Odometry</h3>
<div class="standard" id='magicparlabel-65766'>A gentle introduction to vision-based sensing is <b>Visual Odometry</b> (abbreviated VO, see e.g. <a href='#LyXCite-Nister04cvpr2'><span class="bib-abbrvciteauthor">Nistr et al.</span></a> (<span class="bib-year">2004</span>)), which provides pose constraints between successive robot poses by tracking or associating visual features in successive images taken by a camera mounted rigidly on the robot. GTSAM includes both C++ and MATLAB example code, as well as VO-specific factors to help you on the way.</div>
<h3 class="subsection" id='magicparlabel-65767'><span class="subsection_label">8.3</span> Visual SLAM</h3>
<div class="standard" id='magicparlabel-65768'><b>Visual SLAM</b> (see e.g., <a href='#LyXCite-Davison03iccv'><span class="bib-abbrvciteauthor">Davison</span></a> (<span class="bib-year">2003</span>)) is a SLAM variant where 3D points are observed by a camera as the camera moves through space, either mounted on a robot or moved around by hand. GTSAM, and particularly iSAM (see below), can easily be adapted to be used as the back-end optimizer in such a scenario.</div>
<h3 class="subsection" id='magicparlabel-65769'><span class="subsection_label">8.4</span> Fixed-lag Smoothing and Filtering </h3>
<div class="standard" id='magicparlabel-65770'>GTSAM can easily perform recursive estimation, where only a subset of the poses are kept in the factor graph, while the remaining poses are marginalized out. In all examples above we explicitly optimize for all variables using all available measurements, which is called <b>Smoothing</b> because the trajectory is &ldquo;smoothed&rdquo; out, and this is where GTSAM got its name (GT <em>Smoothing</em> and Mapping). When instead only the last few poses are kept in the graph, one speaks of <b>Fixed-lag Smoothing</b>. Finally, when only the single most recent poses is kept, one speaks of <b>Filtering</b>, and indeed the original formulation of SLAM was filter-based (<a href='#LyXCite-Smith87b'><span class="bib-abbrvciteauthor">Smith et al.</span>, <span class="bib-year">1988</span></a>).</div>
<h3 class="subsection" id='magicparlabel-65771'><span class="subsection_label">8.5</span> Discrete Variables and HMMs</h3>
<div class="standard" id='magicparlabel-65772'>Finally, factor graphs are not limited to continuous variables: GTSAM can also be used to model and solve discrete optimization problems. For example, a Hidden Markov Model (HMM) has the same graphical model structure as the Robot Localization problem from Section <a href="#sec_Robot_Localization">2</a>, except that in an HMM the variables are discrete. GTSAM can optimize and perform inference for discrete models.</div>
<h2 class="section_" id='magicparlabel-65773'>Acknowledgements</h2>
<div class="standard" id='magicparlabel-65774'>GTSAM was made possible by the efforts of many collaborators at Georgia Tech and elsewhere, including but not limited to Doru Balcan, Chris Beall, Alex Cunningham, Alireza Fathi, Eohan George, Viorela Ila, Yong-Dian Jian, Michael Kaess, Kai Ni, Carlos Nieto, Duy-Nguyen Ta, Manohar Paluri, Christian Potthast, Richard Roberts, Grant Schindler, and Stephen Williams. In addition, Paritosh Mohan helped me with the manual. Many thanks all for your hard work!</div>

<div class="standard" id='magicparlabel-65775'><br />
<h2 class='bibtex'>References</h2><div class='bibtex'><div class='bibtexentry' id='LyXCite-Davison03iccv'><span class='bibtexlabel'>Davison 2003</span><span class='bibtexinfo'><span class="bib-fullnames:author">Davison, A.J.</span>, "<span class="bib-title">Real-Time Simultaneous Localisation and Mapping with a Single Camera</span>", in <i><span class="bib-booktitle">Intl. Conf. on Computer Vision (ICCV)</span></i> (<span class="bib-year">2003</span>), pp. <span class="bib-pages">1403-1410</span>.</span></div>
<div class='bibtexentry' id='LyXCite-Dellaert06ijrr'><span class='bibtexlabel'>Dellaert and Kaess 2006</span><span class='bibtexinfo'><span class="bib-fullnames:author">Dellaert, F. and Kaess, M.</span>, "<span class="bib-title">Square Root SAM: Simultaneous Localization and Mapping via Square Root Information Smoothing</span>", <i><span class="bib-journal">Intl. J. of Robotics Research</span></i>  <span class="bib-volume">25</span>, <span class="bib-number">12</span> (<span class="bib-year">2006</span>), pp. <span class="bib-pages">1181--1203</span>.</span></div>
<div class='bibtexentry' id='LyXCite-Dellaert99b'><span class='bibtexlabel'>Dellaert et al. 1999</span><span class='bibtexinfo'><span class="bib-fullnames:author">Dellaert, F., Fox, D., Burgard, W., and Thrun, S.</span>, "<span class="bib-title">Using the Condensation Algorithm for Robust, Vision-based Mobile Robot Localization</span>", in <i><span class="bib-booktitle">IEEE Conf. on Computer Vision and Pattern Recognition (CVPR)</span></i> (<span class="bib-year">1999</span>).</span></div>
<div class='bibtexentry' id='LyXCite-Dellaert10iros'><span class='bibtexlabel'>Dellaert et al. 2010</span><span class='bibtexinfo'><span class="bib-fullnames:author">Dellaert, F., Carlson, J., Ila, V., Ni, K., and Thorpe, C.E.</span>, "<span class="bib-title">Subgraph-preconditioned Conjugate Gradient for Large Scale SLAM</span>", in <i><span class="bib-booktitle">IEEE/RSJ Intl. Conf. on Intelligent Robots and Systems (IROS)</span></i> (<span class="bib-year">2010</span>).</span></div>
<div class='bibtexentry' id='LyXCite-DurrantWhyte06ram'><span class='bibtexlabel'>Durrant-Whyte and Bailey 2006</span><span class='bibtexinfo'><span class="bib-fullnames:author">Durrant-Whyte, H.F. and Bailey, T.</span>, "<span class="bib-title">Simultaneous Localisation and Mapping (SLAM): Part I The Essential Algorithms</span>", <i><span class="bib-journal">Robotics &amp; Automation Magazine</span></i>  (<span class="bib-year">2006</span>).</span></div>
<div class='bibtexentry' id='LyXCite-Jian11iccv'><span class='bibtexlabel'>Jian et al. 2011</span><span class='bibtexinfo'><span class="bib-fullnames:author">Jian, Y.-D., Balcan, D., and Dellaert, F.</span>, "<span class="bib-title">Generalized Subgraph Preconditioners for Large-Scale Bundle Adjustment</span>", in <i><span class="bib-booktitle">Intl. Conf. on Computer Vision (ICCV)</span></i> (<span class="bib-year">2011</span>).</span></div>
<div class='bibtexentry' id='LyXCite-Kaess09ras'><span class='bibtexlabel'>Kaess and Dellaert 2009</span><span class='bibtexinfo'><span class="bib-fullnames:author">Kaess, M. and Dellaert, F.</span>, "<span class="bib-title">Covariance Recovery from a Square Root Information Matrix for Data Association</span>", <i><span class="bib-journal">Robotics and Autonomous Systems</span></i>  (<span class="bib-year">2009</span>).</span></div>
<div class='bibtexentry' id='LyXCite-Kaess08tro'><span class='bibtexlabel'>Kaess et al. 2008</span><span class='bibtexinfo'><span class="bib-fullnames:author">Kaess, M., Ranganathan, A., and Dellaert, F.</span>, "<span class="bib-title">iSAM: Incremental Smoothing and Mapping</span>", <i><span class="bib-journal">IEEE Trans. Robotics</span></i>  <span class="bib-volume">24</span>, <span class="bib-number">6</span> (<span class="bib-year">2008</span>), pp. <span class="bib-pages">1365-1378</span>.</span></div>
<div class='bibtexentry' id='LyXCite-Kaess12ijrr'><span class='bibtexlabel'>Kaess et al. 2012</span><span class='bibtexinfo'><span class="bib-fullnames:author">Kaess, M., Johannsson, H., Roberts, R., Ila, V., Leonard, J., and Dellaert, F.</span>, "<span class="bib-title">iSAM2: Incremental Smoothing and Mapping Using the Bayes Tree</span>", <i><span class="bib-journal">Intl. J. of Robotics Research</span></i>  <span class="bib-volume">31</span> (<span class="bib-year">2012</span>), pp. <span class="bib-pages">217--236</span>.</span></div>
<div class='bibtexentry' id='LyXCite-Koller09book'><span class='bibtexlabel'>Koller and Friedman 2009</span><span class='bibtexinfo'><span class="bib-fullnames:author">Koller, D. and Friedman, N.</span>, <i><span class="bib-title">Probabilistic Graphical Models: Principles and Techniques</span></i> (<span class="bib-publisher">The MIT Press</span>, <span class="bib-year">2009</span>).</span></div>
<div class='bibtexentry' id='LyXCite-Kschischang01it'><span class='bibtexlabel'>Kschischang et al. 2001</span><span class='bibtexinfo'><span class="bib-fullnames:author">Kschischang, F.R., Frey, B.J., and Loeliger, H-A.</span>, "<span class="bib-title">Factor Graphs and the Sum-Product Algorithm</span>", <i><span class="bib-journal">IEEE Trans. Inform. Theory</span></i>  <span class="bib-volume">47</span>, <span class="bib-number">2</span> (<span class="bib-year">2001</span>).</span></div>
<div class='bibtexentry' id='LyXCite-Loeliger04spm'><span class='bibtexlabel'>Loeliger 2004</span><span class='bibtexinfo'><span class="bib-fullnames:author">Loeliger, H.-A.</span>, "<span class="bib-title">An Introduction to Factor Graphs</span>", <i><span class="bib-journal">IEEE Signal Processing Magazine</span></i>  (<span class="bib-year">2004</span>), pp. <span class="bib-pages">28--41</span>.</span></div>
<div class='bibtexentry' id='LyXCite-Nister04cvpr2'><span class='bibtexlabel'>Nistr et al. 2004</span><span class='bibtexinfo'><span class="bib-fullnames:author">Nistr, D., Naroditsky, O., and Bergen, J.</span>, "<span class="bib-title">Visual Odometry</span>", in <i><span class="bib-booktitle">IEEE Conf. on Computer Vision and Pattern Recognition (CVPR)</span></i> vol. <span class="bib-volume">1</span>,  (<span class="bib-year">2004</span>), pp. <span class="bib-pages">652-659</span>.</span></div>
<div class='bibtexentry' id='LyXCite-Smith87b'><span class='bibtexlabel'>Smith et al. 1988</span><span class='bibtexinfo'><span class="bib-fullnames:author">Smith, R., Self, M., and Cheeseman, P.</span>, "<span class="bib-title">A stochastic map for uncertain spatial relationships</span>", in <i><span class="bib-booktitle">Proc. of the Intl. Symp. of Robotics Research (ISRR)</span></i> (<span class="bib-year">1988</span>), pp. <span class="bib-pages">467-474</span>.</span></div>
</div></div>
</body>
</html>
