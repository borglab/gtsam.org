---
layout: page
date: 2019-05-22 07:30:00 -0400
title: "Factor Graphs and GTSAM"
categories: factor-graphs
---

<!-- <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd"> -->
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
  <meta name="GENERATOR" content="LyX 2.3.2">
  </meta>
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
  </meta>
  <title>Factor Graphs and GTSAM:A Hands-on Introduction</title>
  <style type='text/css'>
    /* LyX Provided Styles */
    div.bibtexentry {
      margin-left: 2em;
      text-indent: -2em;
    }

    span.bibtexlabel:before {
      content: "[";
    }

    span.bibtexlabel:after {
      content: "] ";
    }

    /* Layout-provided Styles */
    h1.title {
      font-size: x-large;
      margin-bottom: 1ex;
      text-align: center;

    }

    div.author {
      font-size: large;
      margin-top: 1.3ex;
      margin-bottom: 0.7ex;
      text-align: center;

    }

    div.date {
      font-size: large;
      margin-top: 0.9ex;
      margin-bottom: 0.5ex;
      text-align: center;

    }

    div.standard {
      margin-bottom: 2ex;
    }

    h2.section_ {
      font-weight: bold;
      font-size: x-large;
      margin-top: 1.3ex;
      margin-bottom: 0.7ex;
      text-align: left;

    }

    div.plain_layout {
      text-align: left;

    }

    h2.section {
      font-weight: bold;
      font-size: x-large;
      margin-top: 1.3ex;
      margin-bottom: 0.7ex;
      text-align: left;

    }

    h3.subsection {
      font-weight: bold;
      font-size: large;
      margin-top: 0.9ex;
      margin-bottom: 0.5ex;
      text-align: left;

    }

    ol.enumerate {
      margin-top: 0.7ex;
      margin-bottom: 0.7ex;
      margin-left: 3ex;
      text-align: left;

    }

    ul.itemize {
      margin-top: 0.7ex;
      margin-bottom: 0.7ex;
      margin-left: 3ex;
      text-align: left;

    }

    span.flex_url {
      font-family: monospace;
    }

    div.toc {
      margin: 2em 0em;
      border-style: solid;
      border-width: 2px 0px;
      padding: 1em 0em;
    }

    h2.tochead {
      font-size: x-large;
      font-weight: bold;
    }

    div.lyxtoc-0 {
      margin: 2em 0em 0em 0em;
      font-size: xx-large;
      font-weight: bold;
    }

    div.lyxtoc-1 {
      margin: 1em 0em 0em 0em;
      font-size: x-large;
      font-weight: bold;
    }

    div.lyxtoc-2 {
      margin: 0em 0.1em 0em 1em;
      font-size: large;
      font-weight: normal;
    }

    div.lyxtoc-3 {
      margin: 0em 0.1em 0em 0.5em;
      font-size: medium;
    }

    div.lyxtoc-4 {
      margin: 0em 0.1em 0em 0.5em;
    }

    div.lyxtoc-5 {
      margin: 0em 0.1em 0em 0.5em;
    }

    div.lyxtoc-6 {
      margin: 0em 0.1em 0em 0.5em;
    }

    a.tocentry {
      text-decoration: none;
      color: black;
    }

    a.tocentry:visited {
      color: black;
    }

    div.float {
      border: 2px solid black;
      text-align: center;
    }

    div.float-caption {
      text-align: center;
      border: 2px solid black;
      padding: 1ex;
      /* padding-bottom: 15px; */
      margin: 1ex;
      display: block;
    }

    span.foot_label {
      vertical-align: super;
      font-size: smaller;
      font-weight: bold;
      text-decoration: underline;
    }

    div.foot {
      display: inline;
      font-size: small;
      font-weight: medium;
      font-family: serif;
      font-variant: normal;
      font-style: normal;
    }

    div.foot_inner {
      display: none;
    }

    div.foot:hover div.foot_inner {
      display: block;
      border: 1px double black;
      margin: 0em 1em;
      padding: 1em;
    }

    /* Frank overrides */
    .float-caption {
      display: block;
    }

    .float-caption::before {
      content: '\A\A';
    }
  </style>
</head>

<body dir="auto">
  <!-- <h1 class="title" id='magicparlabel-65361'>Factor Graphs and GTSAM:
<br>

A Hands-on Introduction</h1>
<div class="author" id='magicparlabel-65362'>Frank Dellaert
<br>

Technical Report number GT-RIM-CP&amp;R-2014-XXX</div>
<div class="date" id='magicparlabel-65363'>September 2014</div> -->

  <p>This is an updated version of the 2012 tech-report <a
      href="http://borg.cc.gatech.edu/sites/edu.borg/files/downloads/gtsam.pdf">Factor Graphs
      and GTSAM: A Hands-on Introduction</a> by <a href="http://frank.dellaert.com">Frank Dellaert</a>. A more thorough
    introduction to the use of factor graphs in robotics is the 2017 article <a
      href="https://www.cc.gatech.edu/~dellaert/pubs/Dellaert17fnt.pdf">Factor graphs for robot perception</a> by Frank
    Dellaert and Michael Kaess.</p>

  <h2 class="section_" id='magicparlabel-65365'>Overview</h2>

  <div class="standard" id='magicparlabel-65367'><b>Factor graphs</b> are graphical models (<a
      href='#LyXCite-Koller09book'><span class="bib-abbrvciteauthor">Koller and Friedman</span>, <span
        class="bib-year">2009</span></a>) that are well suited to modeling complex estimation problems, such as
    Simultaneous Localization and Mapping (SLAM) or Structure from Motion (SFM). You might be familiar with another
    often used graphical model, Bayes networks, which are directed acyclic graphs. A <b>factor graph, </b>however, is a
    <em>bipartite</em> graph consisting of factors connected to variables. The <b>variables</b> represent the unknown
    random variables in the estimation problem, whereas the <b>factors</b> represent probabilistic constraints on those
    variables, derived from measurements or prior knowledge. In the following sections I will illustrate this with
    examples from both robotics and vision.
  </div>

  <div class="standard" id='magicparlabel-65368'>The GTSAM toolbox (GTSAM stands for &ldquo;Georgia Tech Smoothing and
    Mapping&rdquo;) toolbox is a BSD-licensed C++ library based on factor graphs, developed at the Georgia Institute of
    Technology by myself, many of my students, and collaborators. It provides state of the art solutions to the SLAM and
    SFM problems, but can also be used to model and solve both simpler and more complex estimation problems. It also
    provides a MATLAB interface which allows for rapid prototype development, visualization, and user interaction.</div>

  <div class="standard" id='magicparlabel-65369'>GTSAM exploits sparsity to be computationally efficient. Typically
    measurements only provide information on the relationship between a handful of variables, and hence the resulting
    factor graph will be sparsely connected. This is exploited by the algorithms implemented in GTSAM to reduce
    computational complexity. Even when graphs are too dense to be handled efficiently by direct methods, GTSAM provides
    iterative methods that are quite efficient regardless.</div>

  <div class="standard" id='magicparlabel-65370'>You can download the latest version of GTSAM from our <a
      href="https://github.com/borglab/gtsam">Github repo</a>.</div>


  <div class='toc'>
    <h2 class='tochead section'>Table of Contents</h2>


    <div class='lyxtoc-1'>
      <div class='lyxtoc-2'><a href='#magicparlabel-65365' class='tocentry'>Overview</a>
      </div>

      <div class='lyxtoc-2'><a href='#magicparlabel-65377' class='tocentry'>1 Factor Graphs</a>
      </div>

      <div class='lyxtoc-2'><a href='#magicparlabel-65411' class='tocentry'>2 Modeling Robot Motion</a>


        <div class='lyxtoc-3'><a href='#magicparlabel-65412' class='tocentry'>2.1 Modeling with Factor Graphs</a>
        </div>

        <div class='lyxtoc-3'><a href='#magicparlabel-65428' class='tocentry'>2.2 Creating a Factor Graph</a>
        </div>

        <div class='lyxtoc-3'><a href='#magicparlabel-65438' class='tocentry'>2.3 Factor Graphs versus Values</a>
        </div>

        <div class='lyxtoc-3'><a href='#magicparlabel-65443' class='tocentry'>2.4 Non-linear Optimization in GTSAM</a>
        </div>

        <div class='lyxtoc-3'><a href='#magicparlabel-65457' class='tocentry'>2.5 Full Posterior Inference</a>
        </div>
      </div>

      <div class='lyxtoc-2'><a href='#magicparlabel-65467' class='tocentry'>3 Robot Localization</a>


        <div class='lyxtoc-3'><a href='#magicparlabel-65468' class='tocentry'>3.1 Unary Measurement Factors</a>
        </div>

        <div class='lyxtoc-3'><a href='#magicparlabel-65484' class='tocentry'>3.2 Defining Custom Factors</a>
        </div>

        <div class='lyxtoc-3'><a href='#magicparlabel-65499' class='tocentry'>3.3 Using Custom Factors</a>
        </div>

        <div class='lyxtoc-3'><a href='#magicparlabel-65514' class='tocentry'>3.4 Full Posterior Inference</a>
        </div>
      </div>

      <div class='lyxtoc-2'><a href='#magicparlabel-65549' class='tocentry'>4 PoseSLAM</a>


        <div class='lyxtoc-3'><a href='#magicparlabel-65550' class='tocentry'>4.1 Loop Closure Constraints</a>
        </div>

        <div class='lyxtoc-3'><a href='#magicparlabel-65583' class='tocentry'>4.2 Using the MATLAB Interface</a>
        </div>

        <div class='lyxtoc-3'><a href='#magicparlabel-65612' class='tocentry'>4.3 Reading and Optimizing Pose Graphs
          </a>
        </div>

        <div class='lyxtoc-3'><a href='#magicparlabel-65623' class='tocentry'>4.4 PoseSLAM in 3D</a>
        </div>
      </div>

      <div class='lyxtoc-2'><a href='#magicparlabel-65635' class='tocentry'>5 Landmark-based SLAM</a>


        <div class='lyxtoc-3'><a href='#magicparlabel-65636' class='tocentry'>5.1 Basics</a>
        </div>

        <div class='lyxtoc-3'><a href='#magicparlabel-65663' class='tocentry'>5.2 Of Keys and Symbols</a>
        </div>

        <div class='lyxtoc-3'><a href='#magicparlabel-65684' class='tocentry'>5.3 A Larger Example</a>
        </div>

        <div class='lyxtoc-3'><a href='#magicparlabel-65695' class='tocentry'>5.4 A Real-World Example</a>
        </div>
      </div>

      <div class='lyxtoc-2'><a href='#magicparlabel-65707' class='tocentry'>6 Structure from Motion</a>
      </div>

      <div class='lyxtoc-2'><a href='#magicparlabel-65728' class='tocentry'>7 iSAM: Incremental Smoothing and
          Mapping</a>
      </div>

      <div class='lyxtoc-2'><a href='#magicparlabel-65738' class='tocentry'>8 More Applications</a>


        <div class='lyxtoc-3'><a href='#magicparlabel-65754' class='tocentry'>8.1 Conjugate Gradient Optimization</a>
        </div>

        <div class='lyxtoc-3'><a href='#magicparlabel-65765' class='tocentry'>8.2 Visual Odometry</a>
        </div>

        <div class='lyxtoc-3'><a href='#magicparlabel-65767' class='tocentry'>8.3 Visual SLAM</a>
        </div>

        <div class='lyxtoc-3'><a href='#magicparlabel-65769' class='tocentry'>8.4 Fixed-lag Smoothing and Filtering </a>
        </div>

        <div class='lyxtoc-3'><a href='#magicparlabel-65771' class='tocentry'>8.5 Discrete Variables and HMMs</a>
        </div>
      </div>

      <div class='lyxtoc-2'><a href='#magicparlabel-65773' class='tocentry'>Acknowledgements</a>
      </div>
    </div>
  </div>


  <div class="standard" id='magicparlabel-65376'><br>
  </div>
  <h2 class="section" id='magicparlabel-65377'><span class="section_label">1</span> Factor Graphs</h2>
  <div class="standard" id='magicparlabel-65378'>Let us start with a one-page primer on factor graphs, which in no way
    replaces the excellent and detailed reviews by <a href='#LyXCite-Kschischang01it'><span
        class="bib-abbrvciteauthor">Kschischang et al.</span></a> (<span class="bib-year">2001</span>) and <a
      href='#LyXCite-Loeliger04spm'><span class="bib-abbrvciteauthor">Loeliger</span></a> (<span
      class="bib-year">2004</span>). </div>


  <div class='float-figure'>
    <div class="plain_layout" style='text-align: center;' id='magicparlabel-65383'><img style='width:60%;'
        src='intro-images/2_Users_dellaert_git_github_doc_images_hmm.png'
        alt='image: 2_Users_dellaert_git_github_doc_images_hmm.png'></img>
      <span class='float-caption-Standard float-caption float-caption-standard'>Figure 1: <a id="fig_unrolledHMM"></a>
        An HMM, unrolled over three time-steps, represented by a Bayes net. </span>
    </div>
  </div>


  <div class="standard" id='magicparlabel-65388'> Figure <a href="#fig_unrolledHMM">1</a> shows the <b>Bayes network</b>
    for a hidden Markov model (HMM) over three time steps. In a Bayes net, each node is associated with a conditional
    density: the top Markov chain encodes the prior <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mi>P</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <msub>
            <mrow>
              <mi>X</mi>
            </mrow>
            <mrow>
              <mn>1</mn>
            </mrow>
          </msub>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math> and transition probabilities <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mi>P</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <msub>
              <mrow>
                <mi>X</mi>
              </mrow>
              <mrow>
                <mn>2</mn>
              </mrow>
            </msub>
            <mo>|</mo>
            <msub>
              <mrow>
                <mi>X</mi>
              </mrow>
              <mrow>
                <mn>1</mn>
              </mrow>
            </msub>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mi>P</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <msub>
              <mrow>
                <mi>X</mi>
              </mrow>
              <mrow>
                <mn>3</mn>
              </mrow>
            </msub>
            <mo>|</mo>
            <msub>
              <mrow>
                <mi>X</mi>
              </mrow>
              <mrow>
                <mn>2</mn>
              </mrow>
            </msub>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math>, whereas measurements <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>Z</mi>
          </mrow>
          <mrow>
            <mi>t</mi>
          </mrow>
        </msub>
      </mrow>
    </math> depend only on the state <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>X</mi>
          </mrow>
          <mrow>
            <mi>t</mi>
          </mrow>
        </msub>
      </mrow>
    </math>, modeled by conditional densities <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mi>P</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <msub>
              <mrow>
                <mi>Z</mi>
              </mrow>
              <mrow>
                <mi>t</mi>
              </mrow>
            </msub>
            <mo>|</mo>
            <msub>
              <mrow>
                <mi>X</mi>
              </mrow>
              <mrow>
                <mi>t</mi>
              </mrow>
            </msub>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math>. Given known measurements <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>z</mi>
          </mrow>
          <mrow>
            <mn>1</mn>
          </mrow>
        </msub>
      </mrow>
    </math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>z</mi>
          </mrow>
          <mrow>
            <mn>2</mn>
          </mrow>
        </msub>
      </mrow>
    </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>z</mi>
          </mrow>
          <mrow>
            <mn>3</mn>
          </mrow>
        </msub>
      </mrow>
    </math> we are interested in the hidden state sequence <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

        <mrow>
          <msub>
            <mrow>
              <mi>X</mi>
            </mrow>
            <mrow>
              <mn>1</mn>
            </mrow>
          </msub>
          <mo>,</mo>
          <msub>
            <mrow>
              <mi>X</mi>
            </mrow>
            <mrow>
              <mn>2</mn>
            </mrow>
          </msub>
          <mo>,</mo>
          <msub>
            <mrow>
              <mi>X</mi>
            </mrow>
            <mrow>
              <mn>3</mn>
            </mrow>
          </msub>
        </mrow>
        <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

      </mrow>
    </math> that maximizes the posterior probability <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mi>P</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <msub>
              <mrow>
                <mi>X</mi>
              </mrow>
              <mrow>
                <mn>1</mn>
              </mrow>
            </msub>
            <mo>,</mo>
            <msub>
              <mrow>
                <mi>X</mi>
              </mrow>
              <mrow>
                <mn>2</mn>
              </mrow>
            </msub>
            <mo>,</mo>
            <msub>
              <mrow>
                <mi>X</mi>
              </mrow>
              <mrow>
                <mn>3</mn>
              </mrow>
            </msub>
            <mo>|</mo>
            <msub>
              <mrow>
                <mi>Z</mi>
              </mrow>
              <mrow>
                <mn>1</mn>
              </mrow>
            </msub>
            <mo>=</mo>
            <msub>
              <mrow>
                <mi>z</mi>
              </mrow>
              <mrow>
                <mn>1</mn>
              </mrow>
            </msub>
            <mo>,</mo>
            <msub>
              <mrow>
                <mi>Z</mi>
              </mrow>
              <mrow>
                <mn>2</mn>
              </mrow>
            </msub>
            <mo>=</mo>
            <msub>
              <mrow>
                <mi>z</mi>
              </mrow>
              <mrow>
                <mn>2</mn>
              </mrow>
            </msub>
            <mo>,</mo>
            <msub>
              <mrow>
                <mi>Z</mi>
              </mrow>
              <mrow>
                <mn>3</mn>
              </mrow>
            </msub>
            <mo>=</mo>
            <msub>
              <mrow>
                <mi>z</mi>
              </mrow>
              <mrow>
                <mn>3</mn>
              </mrow>
            </msub>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math>. Since the measurements <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>Z</mi>
          </mrow>
          <mrow>
            <mn>1</mn>
          </mrow>
        </msub>
      </mrow>
    </math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>Z</mi>
          </mrow>
          <mrow>
            <mn>2</mn>
          </mrow>
        </msub>
      </mrow>
    </math>, and <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>Z</mi>
          </mrow>
          <mrow>
            <mn>3</mn>
          </mrow>
        </msub>
      </mrow>
    </math> are <em>known</em>, the posterior is proportional to the product of six <b>factors</b>, three of which
    derive from the the Markov chain, and three likelihood factors defined as <math
      xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mi>L</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <msub>
              <mrow>
                <mi>X</mi>
              </mrow>
              <mrow>
                <mi>t</mi>
              </mrow>
            </msub>
            <mo>;</mo>
            <mi>z</mi>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
          <mo> &vprop; </mo>
          <mi>P</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <msub>
              <mrow>
                <mi>Z</mi>
              </mrow>
              <mrow>
                <mi>t</mi>
              </mrow>
            </msub>
            <mo>=</mo>
            <mi>z</mi>
            <mo>|</mo>
            <msub>
              <mrow>
                <mi>X</mi>
              </mrow>
              <mrow>
                <mi>t</mi>
              </mrow>
            </msub>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math>:<math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mi>P</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <msub>
              <mrow>
                <mi>X</mi>
              </mrow>
              <mrow>
                <mn>1</mn>
              </mrow>
            </msub>
            <mo>,</mo>
            <msub>
              <mrow>
                <mi>X</mi>
              </mrow>
              <mrow>
                <mn>2</mn>
              </mrow>
            </msub>
            <mo>,</mo>
            <msub>
              <mrow>
                <mi>X</mi>
              </mrow>
              <mrow>
                <mn>3</mn>
              </mrow>
            </msub>
            <mo>|</mo>
            <msub>
              <mrow>
                <mi>Z</mi>
              </mrow>
              <mrow>
                <mn>1</mn>
              </mrow>
            </msub>
            <mo>,</mo>
            <msub>
              <mrow>
                <mi>Z</mi>
              </mrow>
              <mrow>
                <mn>2</mn>
              </mrow>
            </msub>
            <mo>,</mo>
            <msub>
              <mrow>
                <mi>Z</mi>
              </mrow>
              <mrow>
                <mn>3</mn>
              </mrow>
            </msub>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
          <mo> &vprop; </mo>
          <mi>P</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <msub>
            <mrow>
              <mi>X</mi>
            </mrow>
            <mrow>
              <mn>1</mn>
            </mrow>
          </msub>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
          <mi>P</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <msub>
              <mrow>
                <mi>X</mi>
              </mrow>
              <mrow>
                <mn>2</mn>
              </mrow>
            </msub>
            <mo>|</mo>
            <msub>
              <mrow>
                <mi>X</mi>
              </mrow>
              <mrow>
                <mn>1</mn>
              </mrow>
            </msub>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
          <mi>P</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <msub>
              <mrow>
                <mi>X</mi>
              </mrow>
              <mrow>
                <mn>3</mn>
              </mrow>
            </msub>
            <mo>|</mo>
            <msub>
              <mrow>
                <mi>X</mi>
              </mrow>
              <mrow>
                <mn>2</mn>
              </mrow>
            </msub>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
          <mi>L</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <msub>
              <mrow>
                <mi>X</mi>
              </mrow>
              <mrow>
                <mn>1</mn>
              </mrow>
            </msub>
            <mo>;</mo>
            <msub>
              <mrow>
                <mi>z</mi>
              </mrow>
              <mrow>
                <mn>1</mn>
              </mrow>
            </msub>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
          <mi>L</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <msub>
              <mrow>
                <mi>X</mi>
              </mrow>
              <mrow>
                <mn>2</mn>
              </mrow>
            </msub>
            <mo>;</mo>
            <msub>
              <mrow>
                <mi>z</mi>
              </mrow>
              <mrow>
                <mn>2</mn>
              </mrow>
            </msub>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
          <mi>L</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <msub>
              <mrow>
                <mi>X</mi>
              </mrow>
              <mrow>
                <mn>3</mn>
              </mrow>
            </msub>
            <mo>;</mo>
            <msub>
              <mrow>
                <mi>z</mi>
              </mrow>
              <mrow>
                <mn>3</mn>
              </mrow>
            </msub>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math></div>


  <div class='float-figure'>
    <div class="plain_layout" style='text-align: center;' id='magicparlabel-65401'><img style='width:60%;'
        src='intro-images/3_Users_dellaert_git_github_doc_images_hmm-FG.png'
        alt='image: 3_Users_dellaert_git_github_doc_images_hmm-FG.png'></img>
      <span class='float-caption-Standard float-caption float-caption-standard'>Figure 2: <a id="fig_HMM_FG"></a>
        An HMM with observed measurements, unrolled over time, represented as a factor graph.</span>
    </div>
  </div>


  <div class="standard" id='magicparlabel-65406'> This motivates a different graphical model, a <b>factor graph</b>, in
    which we only represent the unknown variables <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>X</mi>
          </mrow>
          <mrow>
            <mn>1</mn>
          </mrow>
        </msub>
      </mrow>
    </math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>X</mi>
          </mrow>
          <mrow>
            <mn>2</mn>
          </mrow>
        </msub>
      </mrow>
    </math>, and <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>X</mi>
          </mrow>
          <mrow>
            <mn>3</mn>
          </mrow>
        </msub>
      </mrow>
    </math>, connected to factors that encode probabilistic information on them, as in Figure <a
      href="#fig_HMM_FG">2</a>. To do maximum a-posteriori (MAP) inference, we then maximize the product <math
      display="block" xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mi>f</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <msub>
              <mrow>
                <mi>X</mi>
              </mrow>
              <mrow>
                <mn>1</mn>
              </mrow>
            </msub>
            <mo>,</mo>
            <msub>
              <mrow>
                <mi>X</mi>
              </mrow>
              <mrow>
                <mn>2</mn>
              </mrow>
            </msub>
            <mo>,</mo>
            <msub>
              <mrow>
                <mi>X</mi>
              </mrow>
              <mrow>
                <mn>3</mn>
              </mrow>
            </msub>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
          <mo>=</mo>
          <mo> &prod; </mo>
          <msub>
            <mrow>
              <mi>f</mi>
            </mrow>
            <mrow>
              <mi>i</mi>
            </mrow>
          </msub>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <msub>
            <mrow>
              <mstyle mathvariant='script'>
                <mi>X</mi>
              </mstyle>
            </mrow>
            <mrow>
              <mi>i</mi>
            </mrow>
          </msub>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math>i.e., the value of the factor graph. It should be clear from the figure that the connectivity of a factor
    graph encodes, for each factor <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>f</mi>
          </mrow>
          <mrow>
            <mi>i</mi>
          </mrow>
        </msub>
      </mrow>
    </math>, which subset of variables <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mstyle mathvariant='script'>
              <mi>X</mi>
            </mstyle>
          </mrow>
          <mrow>
            <mi>i</mi>
          </mrow>
        </msub>
      </mrow>
    </math> it depends on. In the examples below, we use factor graphs to model more complex MAP inference problems in
    robotics.</div>
  <h2 class="section" id='magicparlabel-65411'><span class="section_label">2</span> <a id="sec_Robot_Localization"></a>
    Modeling Robot Motion</h2>
  <h3 class="subsection" id='magicparlabel-65412'><span class="subsection_label">2.1</span> Modeling with Factor Graphs
  </h3>
  <div class="standard" id='magicparlabel-65413'>Before diving into a SLAM example, let us consider the simpler problem
    of modeling robot motion. This can be done with a <em>continuous</em> Markov chain, and provides a gentle
    introduction to GTSAM.</div>


  <div class='float-figure'>
    <div class="plain_layout" style='text-align: center;' id='magicparlabel-65418'><img style='width:80%;'
        src='intro-images/4_Users_dellaert_git_github_doc_images_FactorGraph.png'
        alt='image: 4_Users_dellaert_git_github_doc_images_FactorGraph.png'></img>
      <span class='float-caption-Standard float-caption float-caption-standard'>Figure 3: <a id="fig_OdometryFG"></a>
        Factor graph for robot localization.</span>
    </div>
  </div>


  <div class="standard" id='magicparlabel-65423'> The factor graph for a simple example is shown in Figure <a
      href="#fig_OdometryFG">3</a>. There are three variables <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>x</mi>
          </mrow>
          <mrow>
            <mn>1</mn>
          </mrow>
        </msub>
      </mrow>
    </math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>x</mi>
          </mrow>
          <mrow>
            <mn>2</mn>
          </mrow>
        </msub>
      </mrow>
    </math>, and <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>x</mi>
          </mrow>
          <mrow>
            <mn>3</mn>
          </mrow>
        </msub>
      </mrow>
    </math> which represent the poses of the robot over time, rendered in the figure by the open-circle variable nodes.
    In this example, we have one <b>unary factor</b> <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <msub>
            <mrow>
              <mi>f</mi>
            </mrow>
            <mrow>
              <mn>0</mn>
            </mrow>
          </msub>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <msub>
            <mrow>
              <mi>x</mi>
            </mrow>
            <mrow>
              <mn>1</mn>
            </mrow>
          </msub>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math> on the first pose <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>x</mi>
          </mrow>
          <mrow>
            <mn>1</mn>
          </mrow>
        </msub>
      </mrow>
    </math> that encodes our prior knowledge about <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>x</mi>
          </mrow>
          <mrow>
            <mn>1</mn>
          </mrow>
        </msub>
      </mrow>
    </math>, and two <b>binary factors</b> that relate successive poses, respectively <math
      xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <msub>
            <mrow>
              <mi>f</mi>
            </mrow>
            <mrow>
              <mn>1</mn>
            </mrow>
          </msub>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <msub>
              <mrow>
                <mi>x</mi>
              </mrow>
              <mrow>
                <mn>1</mn>
              </mrow>
            </msub>
            <mo>,</mo>
            <msub>
              <mrow>
                <mi>x</mi>
              </mrow>
              <mrow>
                <mn>2</mn>
              </mrow>
            </msub>
            <mo>;</mo>
            <msub>
              <mrow>
                <mi>o</mi>
              </mrow>
              <mrow>
                <mn>1</mn>
              </mrow>
            </msub>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <msub>
            <mrow>
              <mi>f</mi>
            </mrow>
            <mrow>
              <mn>2</mn>
            </mrow>
          </msub>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <msub>
              <mrow>
                <mi>x</mi>
              </mrow>
              <mrow>
                <mn>2</mn>
              </mrow>
            </msub>
            <mo>,</mo>
            <msub>
              <mrow>
                <mi>x</mi>
              </mrow>
              <mrow>
                <mn>3</mn>
              </mrow>
            </msub>
            <mo>;</mo>
            <msub>
              <mrow>
                <mi>o</mi>
              </mrow>
              <mrow>
                <mn>2</mn>
              </mrow>
            </msub>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math>, where <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>o</mi>
          </mrow>
          <mrow>
            <mn>1</mn>
          </mrow>
        </msub>
      </mrow>
    </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>o</mi>
          </mrow>
          <mrow>
            <mn>2</mn>
          </mrow>
        </msub>
      </mrow>
    </math> represent odometry measurements.</div>
  <h3 class="subsection" id='magicparlabel-65428'><span class="subsection_label">2.2</span> Creating a Factor Graph</h3>
  <div class="standard" id='magicparlabel-65429'>The following C++ code, included in GTSAM as an example, creates the
    factor graph in Figure <a href="#fig_OdometryFG">3</a>:</div>

  <div class="standard" id='magicparlabel-65430'>
    <pre>// Create an empty nonlinear factor graph
NonlinearFactorGraph graph;

// Add a Gaussian prior on pose x_1
Pose2 priorMean(0.0, 0.0, 0.0);
noiseModel::Diagonal::shared_ptr priorNoise =
  noiseModel::Diagonal::Sigmas(Vector3(0.3, 0.3, 0.1));
graph.add(PriorFactor&lt;Pose2&gt;(1, priorMean, priorNoise));

// Add two odometry factors
Pose2 odometry(2.0, 0.0, 0.0);
noiseModel::Diagonal::shared_ptr odometryNoise =
  noiseModel::Diagonal::Sigmas(Vector3(0.2, 0.2, 0.1));
graph.add(BetweenFactor&lt;Pose2&gt;(1, 2, odometry, odometryNoise));
graph.add(BetweenFactor&lt;Pose2&gt;(2, 3, odometry, odometryNoise));
</pre>
  </div>

  <div class="standard" id='magicparlabel-65431'> Above, line 2 creates an empty factor graph. We then add the factor
    <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <msub>
            <mrow>
              <mi>f</mi>
            </mrow>
            <mrow>
              <mn>0</mn>
            </mrow>
          </msub>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <msub>
            <mrow>
              <mi>x</mi>
            </mrow>
            <mrow>
              <mn>1</mn>
            </mrow>
          </msub>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math> on lines 5-8 as an instance of <em><b>PriorFactor&lt;T&gt;</b></em>, a templated class provided in the slam
    subfolder, with <em><b>T=Pose2</b></em>. Its constructor takes a variable <em><b>Key</b></em> (in this case 1), a
    mean of type <em><b>Pose2,</b></em> created on Line 5, and a noise model for the prior density. We provide a
    diagonal Gaussian of type <em><b>noiseModel::Diagonal</b></em> by specifying three standard deviations in line 7,
    respectively 30 cm.&nbsp;on the robot's position, and 0.1 radians on the robot's orientation. Note that the
    <em><b>Sigmas</b></em> constructor returns a shared pointer, anticipating that typically the same noise models are
    used for many different factors.
  </div>

  <div class="standard" id='magicparlabel-65436'>Similarly, odometry measurements are specified as <em><b>Pose2</b></em>
    on line 11, with a slightly different noise model defined on line 12-13. We then add the two factors <math
      xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <msub>
            <mrow>
              <mi>f</mi>
            </mrow>
            <mrow>
              <mn>1</mn>
            </mrow>
          </msub>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <msub>
              <mrow>
                <mi>x</mi>
              </mrow>
              <mrow>
                <mn>1</mn>
              </mrow>
            </msub>
            <mo>,</mo>
            <msub>
              <mrow>
                <mi>x</mi>
              </mrow>
              <mrow>
                <mn>2</mn>
              </mrow>
            </msub>
            <mo>;</mo>
            <msub>
              <mrow>
                <mi>o</mi>
              </mrow>
              <mrow>
                <mn>1</mn>
              </mrow>
            </msub>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <msub>
            <mrow>
              <mi>f</mi>
            </mrow>
            <mrow>
              <mn>2</mn>
            </mrow>
          </msub>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <msub>
              <mrow>
                <mi>x</mi>
              </mrow>
              <mrow>
                <mn>2</mn>
              </mrow>
            </msub>
            <mo>,</mo>
            <msub>
              <mrow>
                <mi>x</mi>
              </mrow>
              <mrow>
                <mn>3</mn>
              </mrow>
            </msub>
            <mo>;</mo>
            <msub>
              <mrow>
                <mi>o</mi>
              </mrow>
              <mrow>
                <mn>2</mn>
              </mrow>
            </msub>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math> on lines 14-15, as instances of yet another templated class, <em><b>BetweenFactor&lt;T&gt;</b></em>, again
    with <em><b>T=Pose2</b></em>.</div>

  <div class="standard" id='magicparlabel-65437'>When running the example (<em>make OdometryExample.run</em> on the
    command prompt), it will print out the factor graph as follows:</div>
  <div class="standard">
    <pre>Factor Graph:
size: 3
Factor 0: PriorFactor on 1
  prior mean: (0, 0, 0)
  noise model: diagonal sigmas [0.3; 0.3; 0.1];
Factor 1: BetweenFactor(1,2)
  measured: (2, 0, 0)
  noise model: diagonal sigmas [0.2; 0.2; 0.1];
Factor 2: BetweenFactor(2,3)
  measured: (2, 0, 0)
  noise model: diagonal sigmas [0.2; 0.2; 0.1];
</pre>
  </div>
  <h3 class="subsection" id='magicparlabel-65438'><span class="subsection_label">2.3</span> Factor Graphs versus Values
  </h3>
  <div class="standard" id='magicparlabel-65439'>At this point it is instructive to emphasize two important design ideas
    underlying GTSAM:</div>

  <ol class="enumerate" id='magicparlabel-65440'>
    <li class="enumerate_item">The factor graph and its embodiment in code specify the joint probability distribution
      <math xmlns="http://www.w3.org/1998/Math/MathML">
        <mrow>
          <mrow>
            <mi>P</mi>
            <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

            <mrow>
              <mi>X</mi>
              <mo>|</mo>
              <mi>Z</mi>
            </mrow>
            <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

          </mrow>
        </mrow>
      </math> over the <em>entire</em> trajectory <math xmlns="http://www.w3.org/1998/Math/MathML">
        <mrow>
          <mrow>
            <mi>X</mi>
          </mrow>
          <mo>=</mo>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>{</mo>

          <mrow>
            <msub>
              <mrow>
                <mi>x</mi>
              </mrow>
              <mrow>
                <mn>1</mn>
              </mrow>
            </msub>
            <mo>,</mo>
            <msub>
              <mrow>
                <mi>x</mi>
              </mrow>
              <mrow>
                <mn>2</mn>
              </mrow>
            </msub>
            <mo>,</mo>
            <msub>
              <mrow>
                <mi>x</mi>
              </mrow>
              <mrow>
                <mn>3</mn>
              </mrow>
            </msub>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>}</mo>

        </mrow>
        </mrow>
      </math> of the robot, rather than just the last pose. This <em>smoothing</em> view of the world gives GTSAM its
      name: &ldquo;smoothing and mapping&rdquo;. Later in this document we will talk about how we can also use GTSAM to
      do filtering (which you often do <em>not</em> want to do) or incremental inference (which we do all the time).
    </li>
    <li class="enumerate_item">A factor graph in GTSAM is just the specification of the probability density <math
        xmlns="http://www.w3.org/1998/Math/MathML">
        <mrow>
          <mrow>
            <mi>P</mi>
            <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

            <mrow>
              <mi>X</mi>
              <mo>|</mo>
              <mi>Z</mi>
            </mrow>
            <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

          </mrow>
        </mrow>
      </math>, and the corresponding <em><b>FactorGraph</b></em> class and its derived classes do not ever contain a
      &ldquo;solution&rdquo;. Rather, there is a separate type <em><b>Values</b></em> that is used to specify specific
      values for (in this case) <math xmlns="http://www.w3.org/1998/Math/MathML">
        <mrow>
          <msub>
            <mrow>
              <mi>x</mi>
            </mrow>
            <mrow>
              <mn>1</mn>
            </mrow>
          </msub>
        </mrow>
      </math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
        <mrow>
          <msub>
            <mrow>
              <mi>x</mi>
            </mrow>
            <mrow>
              <mn>2</mn>
            </mrow>
          </msub>
        </mrow>
      </math>, and <math xmlns="http://www.w3.org/1998/Math/MathML">
        <mrow>
          <msub>
            <mrow>
              <mi>x</mi>
            </mrow>
            <mrow>
              <mn>3</mn>
            </mrow>
          </msub>
        </mrow>
      </math>, which can then be used to evaluate the probability (or, more commonly, the error) associated with
      particular values.</li>
  </ol>
  <div class="standard" id='magicparlabel-65442'>The latter point is often a point of confusion with beginning users of
    GTSAM. It helps to remember that when designing GTSAM we took a functional approach of classes corresponding to
    mathematical objects, which are usually immutable. You should think of a factor graph as a <em>function</em> to be
    applied to values -as the notation <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mi>f</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
          <mi>X</mi>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
          <mo> &vprop; </mo>
          <mi>P</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <mi>X</mi>
            <mo>|</mo>
            <mi>Z</mi>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math> implies- rather than as an object to be modified.</div>
  <h3 class="subsection" id='magicparlabel-65443'><span class="subsection_label">2.4</span> Non-linear Optimization in
    GTSAM</h3>
  <div class="standard" id='magicparlabel-65444'>The listing below creates a <em><b>Values</b></em> instance, and uses
    it as the initial estimate to find the maximum a-posteriori (MAP) assignment for the trajectory <math
      xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mi>X</mi>
      </mrow>
    </math>:</div>

  <div class="standard" id='magicparlabel-65445'>
    <pre>// create (deliberately inaccurate) initial estimate
Values initial;
initial.insert(1, Pose2(0.5, 0.0, 0.2));
initial.insert(2, Pose2(2.3, 0.1, -0.2));
initial.insert(3, Pose2(4.1, 0.1, 0.1));

// optimize using Levenberg-Marquardt optimization
Values result = LevenbergMarquardtOptimizer(graph, initial).optimize();
</pre>
  </div>

  <div class="standard" id='magicparlabel-65446'> Lines 2-5 in Listing <a href="#listing_OdometryOptimize">2.4</a>
    create the initial estimate, and on line 8 we create a non-linear Levenberg-Marquardt style optimizer, and call
    <em><b>optimize</b></em> using default parameter settings. The reason why GTSAM needs to perform non-linear
    optimization is because the odometry factors <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <msub>
            <mrow>
              <mi>f</mi>
            </mrow>
            <mrow>
              <mn>1</mn>
            </mrow>
          </msub>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <msub>
              <mrow>
                <mi>x</mi>
              </mrow>
              <mrow>
                <mn>1</mn>
              </mrow>
            </msub>
            <mo>,</mo>
            <msub>
              <mrow>
                <mi>x</mi>
              </mrow>
              <mrow>
                <mn>2</mn>
              </mrow>
            </msub>
            <mo>;</mo>
            <msub>
              <mrow>
                <mi>o</mi>
              </mrow>
              <mrow>
                <mn>1</mn>
              </mrow>
            </msub>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <msub>
            <mrow>
              <mi>f</mi>
            </mrow>
            <mrow>
              <mn>2</mn>
            </mrow>
          </msub>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <msub>
              <mrow>
                <mi>x</mi>
              </mrow>
              <mrow>
                <mn>2</mn>
              </mrow>
            </msub>
            <mo>,</mo>
            <msub>
              <mrow>
                <mi>x</mi>
              </mrow>
              <mrow>
                <mn>3</mn>
              </mrow>
            </msub>
            <mo>;</mo>
            <msub>
              <mrow>
                <mi>o</mi>
              </mrow>
              <mrow>
                <mn>2</mn>
              </mrow>
            </msub>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math> are non-linear, as they involve the orientation of the robot. This also explains why the factor graph we
    created in Listing <a href="#listing_OdometryExample">2.2</a> is of type <em><b>NonlinearFactorGraph</b></em>. The
    optimization class linearizes this graph, possibly multiple times, to minimize the non-linear squared error
    specified by the factors.
  </div>

  <div class="standard" id='magicparlabel-65451'>The relevant output from running the example is as follows:</div>
  <div class="standard">
    <pre>Initial Estimate:
Values with 3 values:
Value 1: (0.5, 0, 0.2)
Value 2: (2.3, 0.1, -0.2)
Value 3: (4.1, 0.1, 0.1)

Final Result:
Values with 3 values:
Value 1: (-1.8e-16, 8.7e-18, -9.1e-19)
Value 2: (2, 7.4e-18, -2.5e-18)
Value 3: (4, -1.8e-18, -3.1e-18)
</pre>
  </div>

  <div class="standard" id='magicparlabel-65452'> It can be seen that, subject to very small tolerance, the ground truth
    solution <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <msub>
            <mrow>
              <mi>x</mi>
            </mrow>
            <mrow>
              <mn>1</mn>
            </mrow>
          </msub>
          <mo>=</mo>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <mn>0</mn>
            <mo>,</mo>
            <mn>0</mn>
            <mo>,</mo>
            <mn>0</mn>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <msub>
            <mrow>
              <mi>x</mi>
            </mrow>
            <mrow>
              <mn>2</mn>
            </mrow>
          </msub>
          <mo>=</mo>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <mn>2</mn>
            <mo>,</mo>
            <mn>0</mn>
            <mo>,</mo>
            <mn>0</mn>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math>, and <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <msub>
            <mrow>
              <mi>x</mi>
            </mrow>
            <mrow>
              <mn>3</mn>
            </mrow>
          </msub>
          <mo>=</mo>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <mn>4</mn>
            <mo>,</mo>
            <mn>0</mn>
            <mo>,</mo>
            <mn>0</mn>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math> is recovered.</div>
  <h3 class="subsection" id='magicparlabel-65457'><span class="subsection_label">2.5</span> <a
      id="subsec_Full_Posterior_Inference"></a>
    Full Posterior Inference</h3>
  <div class="standard" id='magicparlabel-65458'>GTSAM can also be used to calculate the covariance matrix for each pose
    after incorporating the information from all measurements <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mi>Z</mi>
      </mrow>
    </math>. Recognizing that the factor graph encodes the <b>posterior density</b> <math
      xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mi>P</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <mi>X</mi>
            <mo>|</mo>
            <mi>Z</mi>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math>, the mean <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mi> &mu; </mi>
      </mrow>
    </math> together with the covariance <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mo> &Sigma; </mo>
      </mrow>
    </math> for each pose <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mi>x</mi>
      </mrow>
    </math> approximate the <b>marginal posterior density</b> <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mi>P</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <mi>x</mi>
            <mo>|</mo>
            <mi>Z</mi>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math>. Note that this is just an approximation, as even in this simple case the odometry factors are actually
    non-linear in their arguments, and GTSAM only computes a Gaussian approximation to the true underlying posterior.
  </div>

  <div class="standard" id='magicparlabel-65459'>The following C++ code will recover the posterior marginals:</div>

  <div class="standard" id='magicparlabel-65460'>
    <pre>// Query the marginals
cout.precision(2);
Marginals marginals(graph, result);
cout &lt;&lt; "x1 covariance:\n" &lt;&lt; marginals.marginalCovariance(1) &lt;&lt; endl;
cout &lt;&lt; "x2 covariance:\n" &lt;&lt; marginals.marginalCovariance(2) &lt;&lt; endl;
cout &lt;&lt; "x3 covariance:\n" &lt;&lt; marginals.marginalCovariance(3) &lt;&lt; endl;
</pre>The relevant output from running the example is as follows:
  </div>
  <div class="standard">
    <pre>x1 covariance:
       0.09     1.1e-47     5.7e-33
    1.1e-47        0.09     1.9e-17
    5.7e-33     1.9e-17        0.01
x2 covariance:
       0.13     4.7e-18     2.4e-18
    4.7e-18        0.17        0.02
    2.4e-18        0.02        0.02
x3 covariance:
       0.17     2.7e-17     8.4e-18
    2.7e-17        0.37        0.06
    8.4e-18        0.06        0.03
</pre>
  </div>

  <div class="standard" id='magicparlabel-65461'> What we see is that the marginal covariance <math
      xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mi>P</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <msub>
              <mrow>
                <mi>x</mi>
              </mrow>
              <mrow>
                <mn>1</mn>
              </mrow>
            </msub>
            <mo>|</mo>
            <mi>Z</mi>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math> on <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>x</mi>
          </mrow>
          <mrow>
            <mn>1</mn>
          </mrow>
        </msub>
      </mrow>
    </math> is simply the prior knowledge on <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>x</mi>
          </mrow>
          <mrow>
            <mn>1</mn>
          </mrow>
        </msub>
      </mrow>
    </math>, but as the robot moves the uncertainty in all dimensions grows without bound, and the <math
      xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mi>y</mi>
      </mrow>
    </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mi> &theta; </mi>
      </mrow>
    </math> components of the pose become (positively) correlated.</div>

  <div class="standard" id='magicparlabel-65466'>An important fact to note when interpreting these numbers is that
    covariance matrices are given in <em>relative</em> coordinates, not absolute coordinates. This is because internally
    GTSAM optimizes for a change with respect to a linearization point, as do all nonlinear optimization libraries.
  </div>
  <h2 class="section" id='magicparlabel-65467'><span class="section_label">3</span> Robot Localization</h2>
  <h3 class="subsection" id='magicparlabel-65468'><span class="subsection_label">3.1</span> Unary Measurement Factors
  </h3>
  <div class="standard" id='magicparlabel-65469'>In this section we add measurements to the factor graph that will help
    us actually <em>localize</em> the robot over time. The example also serves as a tutorial on creating new factor
    types.</div>


  <div class='float-figure'>
    <div class="plain_layout" style='text-align: center;' id='magicparlabel-65474'><img style='width:80%;'
        src='intro-images/5_Users_dellaert_git_github_doc_images_FactorGraph2.png'
        alt='image: 5_Users_dellaert_git_github_doc_images_FactorGraph2.png'></img>
      <span class='float-caption-Standard float-caption float-caption-standard'>Figure 4: <a
          id="fig_LocalizationFG"></a>
        Robot localization factor graph with unary measurement factors at each time step.</span>
    </div>
  </div>


  <div class="standard" id='magicparlabel-65479'> In particular, we use <b>unary measurement factors</b> to handle
    external measurements. The example from Section <a href="#sec_Robot_Localization">2</a> is not very useful on a real
    robot, because it only contains factors corresponding to odometry measurements. These are imperfect and will lead to
    quickly accumulating uncertainty on the last robot pose, at least in the absence of any external measurements (see
    Section <a href="#subsec_Full_Posterior_Inference">2.5</a>). Figure <a href="#fig_LocalizationFG">4</a> shows a new
    factor graph where the prior <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <msub>
            <mrow>
              <mi>f</mi>
            </mrow>
            <mrow>
              <mn>0</mn>
            </mrow>
          </msub>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <msub>
            <mrow>
              <mi>x</mi>
            </mrow>
            <mrow>
              <mn>1</mn>
            </mrow>
          </msub>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math> is omitted and instead we added three unary factors <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <msub>
            <mrow>
              <mi>f</mi>
            </mrow>
            <mrow>
              <mn>1</mn>
            </mrow>
          </msub>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <msub>
              <mrow>
                <mi>x</mi>
              </mrow>
              <mrow>
                <mn>1</mn>
              </mrow>
            </msub>
            <mo>;</mo>
            <msub>
              <mrow>
                <mi>z</mi>
              </mrow>
              <mrow>
                <mn>1</mn>
              </mrow>
            </msub>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <msub>
            <mrow>
              <mi>f</mi>
            </mrow>
            <mrow>
              <mn>2</mn>
            </mrow>
          </msub>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <msub>
              <mrow>
                <mi>x</mi>
              </mrow>
              <mrow>
                <mn>2</mn>
              </mrow>
            </msub>
            <mo>;</mo>
            <msub>
              <mrow>
                <mi>z</mi>
              </mrow>
              <mrow>
                <mn>2</mn>
              </mrow>
            </msub>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math>, and <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <msub>
            <mrow>
              <mi>f</mi>
            </mrow>
            <mrow>
              <mn>3</mn>
            </mrow>
          </msub>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <msub>
              <mrow>
                <mi>x</mi>
              </mrow>
              <mrow>
                <mn>3</mn>
              </mrow>
            </msub>
            <mo>;</mo>
            <msub>
              <mrow>
                <mi>z</mi>
              </mrow>
              <mrow>
                <mn>3</mn>
              </mrow>
            </msub>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math>, one for each localization measurement <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>z</mi>
          </mrow>
          <mrow>
            <mi>t</mi>
          </mrow>
        </msub>
      </mrow>
    </math>, respectively. Such unary factors are applicable for measurements <math
      xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>z</mi>
          </mrow>
          <mrow>
            <mi>t</mi>
          </mrow>
        </msub>
      </mrow>
    </math> that depend <em>only</em> on the current robot pose, e.g., GPS readings, correlation of a laser range-finder
    in a pre-existing map, or indeed the presence of absence of ceiling lights (see <a href='#LyXCite-Dellaert99b'><span
        class="bib-abbrvciteauthor">Dellaert et al.</span></a> (<span class="bib-year">1999</span>) for that amusing
    example).</div>
  <h3 class="subsection" id='magicparlabel-65484'><span class="subsection_label">3.2</span> Defining Custom Factors</h3>
  <div class="standard" id='magicparlabel-65485'>In GTSAM, you can create custom unary factors by deriving a new class
    from the built-in class <em><b>NoiseModelFactor1&lt;T&gt;</b></em>, which implements a unary factor corresponding to
    a measurement likelihood with a Gaussian noise model, <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mi>
            L
          </mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>
            (
          </mo>
          <mi>
            q
          </mi>
          <mo>
            ;
          </mo>
          <mi>
            m
          </mi>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>
            )
          </mo>
          <mo>
            = exp
          </mo>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>
            {
          </mo>
          <mo>
            -
          </mo>
          <mfrac>
            <mn>
              1
            </mn>
            <mn>
              2
            </mn>
          </mfrac>
          <msubsup>
            <mrow>
              <mi>
                |
              </mi>
              <mi>
                |
              </mi>
              <mi>
                h
              </mi>
              <mo form='postfix' fence='true' stretchy='true' symmetric='true'>
                (
              </mo>
              <mi>
                q
              </mi>
              <mo form='postfix' fence='true' stretchy='true' symmetric='true'>
                )
              </mo>
              </mi>
              <mo>
                -
              </mo>
              <mi>
                m
              </mi>
              <mi>
                |
              </mi>
              <mi>
                |
              </mi>
            </mrow>
            <mo>
              &Sigma;
            </mo>
            <mn>
              2
            </mn>
          </msubsup>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>
            }
          </mo>
          <mo>
            =
          </mo>
          <mi>
            f
          </mi>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>
            (
          </mo>
          <mi>
            q
          </mi>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>
            )
          </mo>
        </mrow>

      </mrow>
    </math> where <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mi>m</mi>
      </mrow>
    </math> is the measurement, <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mi>q</mi>
      </mrow>
    </math> is the unknown variable, <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mi>h</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
          <mi>q</mi>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math> is a (possibly nonlinear) measurement function, and <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mo> &Sigma; </mo>
      </mrow>
    </math> is the noise covariance. Note that <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mi>m</mi>
      </mrow>
    </math> is considered <em>known</em> above, and the likelihood <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mi>L</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <mi>q</mi>
            <mo>;</mo>
            <mi>m</mi>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math> will only ever be evaluated as a function of <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mi>q</mi>
      </mrow>
    </math>, which explains why it is a unary factor <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mi>f</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
          <mi>q</mi>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math>. It is always the unknown variable <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mi>q</mi>
      </mrow>
    </math> that is either likely or unlikely, given the measurement. </div>

  <div class="standard" id='magicparlabel-65490'><b>Note: </b>many people get this backwards, often misled by the
    conditional density notation <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mi>P</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <mi>m</mi>
            <mo>|</mo>
            <mi>q</mi>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math>. In fact, the likelihood <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mi>L</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <mi>q</mi>
            <mo>;</mo>
            <mi>m</mi>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math> is <em>defined</em> as any function of <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mi>q</mi>
      </mrow>
    </math> proportional to <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mi>P</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <mi>m</mi>
            <mo>|</mo>
            <mi>q</mi>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math>.</div>

  <div class="standard" id='magicparlabel-65491'>Listing <a href="#listing_LocalizationFactor">3.2</a> shows an example
    on how to define the custom factor class <em><b>UnaryFactor</b></em> which implements a &ldquo;GPS-like&rdquo;
    measurement likelihood:</div>

  <div class="standard" id='magicparlabel-65492'>
    <pre>class UnaryFactor: public NoiseModelFactor1&lt;Pose2&gt; {
  double mx_, my_; ///&lt; X and Y measurements

public:
  UnaryFactor(Key j, double x, double y, const SharedNoiseModel&amp; model):
    NoiseModelFactor1&lt;Pose2&gt;(model, j), mx_(x), my_(y) {}

  Vector evaluateError(const Pose2&amp; q,
                       boost::optional&lt;Matrix&amp;&gt; H = boost::none) const
  {
    const Rot2&amp; R = q.rotation();
    if (H) (*H) = (gtsam::Matrix(2, 3) &lt;&lt;
            R.c(), -R.s(), 0.0,
            R.s(), R.c(), 0.0).finished();
    return (Vector(2) &lt;&lt; q.x() - mx_, q.y() - my_).finished();
  }
};
</pre>
  </div>

  <div class="standard" id='magicparlabel-65493'> In defining the derived class on line 1, we provide the template
    argument <em><b>Pose2</b></em> to indicate the type of the variable <math
      xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mi>q</mi>
      </mrow>
    </math>, whereas the measurement is stored as the instance variables <em><b>mx_</b></em> and <em><b>my_</b></em>,
    defined on line 2. The constructor on lines 5-6 simply passes on the variable key <math
      xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mi>j</mi>
      </mrow>
    </math> and the noise model to the superclass, and stores the measurement values provided. The most important
    function to has be implemented by every factor class is <em><b>evaluateError</b></em>, which should return <math
      xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mi>E</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
          <mi>q</mi>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
          <mrow>
            <mo>=</mo>
          </mrow>
          <mrow>
            <mi>h</mi>
            <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
            <mi>q</mi>
            <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
            <mrow>
              <mo>-</mo>
            </mrow>
            <mrow>
              <mi>m</mi>
            </mrow>
          </mrow>
    </math>
    which is done on line 12. Importantly, because we want to use this factor for nonlinear optimization (see e.g., <a
      href='#LyXCite-Dellaert06ijrr'><span class="bib-abbrvciteauthor">Dellaert and Kaess</span> <span
        class="bib-year">2006</span></a> for details), whenever the optional argument <math
      xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mi>H</mi>
      </mrow>
    </math> is provided, a <em><b>Matrix</b></em> reference, the function should assign the <b>Jacobian</b> of <math
      xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mi>h</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
          <mi>q</mi>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math> to it, evaluated at the provided value for <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mi>q</mi>
      </mrow>
    </math>. This is done for this example on line 11. In this case, the Jacobian of the 2-dimensional function <math
      xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mi>h</mi>
      </mrow>
    </math>, which just returns the position of the robot, <math display="block"
      xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mi>h</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
          <mi>q</mi>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
          <mo>=</mo>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true' lspace='thinmathspace'>[</mo>
          <mtable>
            <mtr>
              <mtd>
                <msub>
                  <mrow>
                    <mi>q</mi>
                  </mrow>
                  <mrow>
                    <mi>x</mi>
                  </mrow>
                </msub>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mrow>
                    <mi>q</mi>
                  </mrow>
                  <mrow>
                    <mi>y</mi>
                  </mrow>
                </msub>
              </mtd>
            </mtr>
          </mtable>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true' lspace='thinmathspace'>]</mo>
        </mrow>
      </mrow>
    </math> with respect the 3-dimensional pose <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mi>q</mi>
          <mo>=</mo>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <msub>
              <mrow>
                <mi>q</mi>
              </mrow>
              <mrow>
                <mi>x</mi>
              </mrow>
            </msub>
            <mo>,</mo>
            <msub>
              <mrow>
                <mi>q</mi>
              </mrow>
              <mrow>
                <mi>y</mi>
              </mrow>
            </msub>
            <mo>,</mo>
            <msub>
              <mrow>
                <mi>q</mi>
              </mrow>
              <mrow>
                <mi> &theta; </mi>
              </mrow>
            </msub>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math>, yields the following <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mn>2</mn>
          <mo> &times; </mo>
          <mn>3</mn>
        </mrow>
      </mrow>
    </math> matrix:</div>

  <div class="standard" id='magicparlabel-138'><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mi>H</mi>
          <mo>=</mo>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true' lspace='thinmathspace'>[</mo>
          <mtable>
            <mtr>
              <mtd>
                <mrow>
                  <mo> cos </mo>
                  <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

                  <msub>
                    <mrow>
                      <mi>q</mi>
                    </mrow>
                    <mrow>
                      <mi> &theta; </mi>
                    </mrow>
                  </msub>
                  <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

                </mrow>
              </mtd>
              <mtd>
                <mrow>
                  <mo>-</mo>
                  <mo> sin </mo>
                  <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

                  <msub>
                    <mrow>
                      <mi>q</mi>
                    </mrow>
                    <mrow>
                      <mi> &theta; </mi>
                    </mrow>
                  </msub>
                  <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

                </mrow>
              </mtd>
              <mtd>
                <mn>0</mn>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mrow>
                  <mo> sin </mo>
                  <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

                  <msub>
                    <mrow>
                      <mi>q</mi>
                    </mrow>
                    <mrow>
                      <mi> &theta; </mi>
                    </mrow>
                  </msub>
                  <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

                </mrow>
              </mtd>
              <mtd>
                <mrow>
                  <mo> cos </mo>
                  <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

                  <msub>
                    <mrow>
                      <mi>q</mi>
                    </mrow>
                    <mrow>
                      <mi> &theta; </mi>
                    </mrow>
                  </msub>
                  <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

                </mrow>
              </mtd>
              <mtd>
                <mn>0</mn>
              </mtd>
            </mtr>
          </mtable>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true' lspace='thinmathspace'>]</mo>
        </mrow>
      </mrow>
    </math></div>
  <h5 class="paragraph_" id='magicparlabel-5568'>Important Note</h5>
  <div class="standard" id='magicparlabel-5574'>Many of our users, when attempting to create a custom factor, are
    initially surprised at the Jacobian matrix not agreeing with their intuition. For example, above you might simply
    expect a <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mn>2</mn>
          <mo> &times; </mo>
          <mn>3</mn>
        </mrow>
      </mrow>
    </math> diagonal matrix. This <em>would</em> be true for variables belonging to a vector space. However, in GTSAM we
    define the Jacobian more generally to be the matrix <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mi>H</mi>
      </mrow>
    </math> such that<math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mi>h</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <mi>q</mi>
            <msup>
              <mrow>
                <mi>e</mi>
              </mrow>
              <mrow>
                <mover>
                  <mrow>
                    <mi> &xi; </mi>
                  </mrow>
                  <mo stretchy="true">&circ;</mo>
                </mover>
              </mrow>
            </msup>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
          <mo> &ap; </mo>
          <mi>h</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
          <mi>q</mi>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
          <mo>+</mo>
          <mi>H</mi>
          <mi> &xi; </mi>
        </mrow>
      </mrow>
    </math>where <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mi> &xi; </mi>
          <mo>=</mo>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <mi> &delta; </mi>
            <mi>x</mi>
            <mo>,</mo>
            <mi> &delta; </mi>
            <mi>y</mi>
            <mo>,</mo>
            <mi> &delta; </mi>
            <mi> &theta; </mi>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math> is an incremental update and <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mo> exp </mo>
          <mover>
            <mrow>
              <mi> &xi; </mi>
            </mrow>
            <mo stretchy="true">&circ;</mo>
          </mover>
        </mrow>
      </mrow>
    </math> is the <b>exponential map</b> for the variable we want to update, In this case <math
      xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mi>q</mi>
          <mo> &isin; </mo>
          <mi>S</mi>
          <mi>E</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
          <mn>2</mn>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math>, where <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mi>S</mi>
          <mi>E</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
          <mn>2</mn>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math> is the group of 2D rigid transforms, implemented by <em><b>Pose2</b></em><b>. </b>The exponential map for
    <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mi>S</mi>
          <mi>E</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
          <mn>2</mn>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math> can be approximated to first order as<math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mo> exp </mo>
          <mover>
            <mrow>
              <mi> &xi; </mi>
            </mrow>
            <mo stretchy="true">&circ;</mo>
          </mover>
          <mo> &ap; </mo>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true' lspace='thinmathspace'>[</mo>
          <mtable>
            <mtr>
              <mtd>
                <mn>1</mn>
              </mtd>
              <mtd>
                <mrow>
                  <mo>-</mo>
                  <mi> &delta; </mi>
                  <mi> &theta; </mi>
                </mrow>
              </mtd>
              <mtd>
                <mrow>
                  <mi> &delta; </mi>
                  <mi>x</mi>
                </mrow>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mrow>
                  <mi> &delta; </mi>
                  <mi> &theta; </mi>
                </mrow>
              </mtd>
              <mtd>
                <mn>1</mn>
              </mtd>
              <mtd>
                <mrow>
                  <mi> &delta; </mi>
                  <mi>y</mi>
                </mrow>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>1</mn>
              </mtd>
            </mtr>
          </mtable>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true' lspace='thinmathspace'>]</mo>
        </mrow>
      </mrow>
    </math>when using the <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mn>3</mn>
          <mo> &times; </mo>
          <mn>3</mn>
        </mrow>
      </mrow>
    </math> matrix representation for 2D poses, and hence <math display="block"
      xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mi>h</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <mi>q</mi>
            <msup>
              <mrow>
                <mi>e</mi>
              </mrow>
              <mrow>
                <mover>
                  <mrow>
                    <mi> &xi; </mi>
                  </mrow>
                  <mo stretchy="true">&circ;</mo>
                </mover>
              </mrow>
            </msup>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
          <mo> &ap; </mo>
          <mi>h</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <mo form='prefix' fence='true' stretchy='true' symmetric='true' lspace='thinmathspace'>[</mo>
            <mtable>
              <mtr>
                <mtd>
                  <mrow>
                    <mo> cos </mo>
                    <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

                    <msub>
                      <mrow>
                        <mi>q</mi>
                      </mrow>
                      <mrow>
                        <mi> &theta; </mi>
                      </mrow>
                    </msub>
                    <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

                  </mrow>
                </mtd>
                <mtd>
                  <mrow>
                    <mo>-</mo>
                    <mo> sin </mo>
                    <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

                    <msub>
                      <mrow>
                        <mi>q</mi>
                      </mrow>
                      <mrow>
                        <mi> &theta; </mi>
                      </mrow>
                    </msub>
                    <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

                  </mrow>
                </mtd>
                <mtd>
                  <msub>
                    <mrow>
                      <mi>q</mi>
                    </mrow>
                    <mrow>
                      <mi>x</mi>
                    </mrow>
                  </msub>
                </mtd>
              </mtr>
              <mtr>
                <mtd>
                  <mrow>
                    <mo> sin </mo>
                    <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

                    <msub>
                      <mrow>
                        <mi>q</mi>
                      </mrow>
                      <mrow>
                        <mi> &theta; </mi>
                      </mrow>
                    </msub>
                    <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

                  </mrow>
                </mtd>
                <mtd>
                  <mrow>
                    <mo> cos </mo>
                    <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

                    <msub>
                      <mrow>
                        <mi>q</mi>
                      </mrow>
                      <mrow>
                        <mi> &theta; </mi>
                      </mrow>
                    </msub>
                    <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

                  </mrow>
                </mtd>
                <mtd>
                  <msub>
                    <mrow>
                      <mi>q</mi>
                    </mrow>
                    <mrow>
                      <mi>y</mi>
                    </mrow>
                  </msub>
                </mtd>
              </mtr>
              <mtr>
                <mtd>
                  <mn>0</mn>
                </mtd>
                <mtd>
                  <mn>0</mn>
                </mtd>
                <mtd>
                  <mn>1</mn>
                </mtd>
              </mtr>
            </mtable>
            <mo form='postfix' fence='true' stretchy='true' symmetric='true' lspace='thinmathspace'>]</mo>
            <mo form='prefix' fence='true' stretchy='true' symmetric='true' lspace='thinmathspace'>[</mo>
            <mtable>
              <mtr>
                <mtd>
                  <mn>1</mn>
                </mtd>
                <mtd>
                  <mrow>
                    <mo>-</mo>
                    <mi> &delta; </mi>
                    <mi> &theta; </mi>
                  </mrow>
                </mtd>
                <mtd>
                  <mrow>
                    <mi> &delta; </mi>
                    <mi>x</mi>
                  </mrow>
                </mtd>
              </mtr>
              <mtr>
                <mtd>
                  <mrow>
                    <mi> &delta; </mi>
                    <mi> &theta; </mi>
                  </mrow>
                </mtd>
                <mtd>
                  <mn>1</mn>
                </mtd>
                <mtd>
                  <mrow>
                    <mi> &delta; </mi>
                    <mi>y</mi>
                  </mrow>
                </mtd>
              </mtr>
              <mtr>
                <mtd>
                  <mn>0</mn>
                </mtd>
                <mtd>
                  <mn>0</mn>
                </mtd>
                <mtd>
                  <mn>1</mn>
                </mtd>
              </mtr>
            </mtable>
            <mo form='postfix' fence='true' stretchy='true' symmetric='true' lspace='thinmathspace'>]</mo>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
          <mo>=</mo>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true' lspace='thinmathspace'>[</mo>
          <mtable>
            <mtr>
              <mtd>
                <mrow>
                  <msub>
                    <mrow>
                      <mi>q</mi>
                    </mrow>
                    <mrow>
                      <mi>x</mi>
                    </mrow>
                  </msub>
                  <mo>+</mo>
                  <mo> cos </mo>
                  <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

                  <msub>
                    <mrow>
                      <mi>q</mi>
                    </mrow>
                    <mrow>
                      <mi> &theta; </mi>
                    </mrow>
                  </msub>
                  <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
                  <mi> &delta; </mi>
                  <mi>x</mi>
                  <mo>-</mo>
                  <mo> sin </mo>
                  <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

                  <msub>
                    <mrow>
                      <mi>q</mi>
                    </mrow>
                    <mrow>
                      <mi> &theta; </mi>
                    </mrow>
                  </msub>
                  <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
                  <mi> &delta; </mi>
                  <mi>y</mi>
                </mrow>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mrow>
                  <msub>
                    <mrow>
                      <mi>q</mi>
                    </mrow>
                    <mrow>
                      <mi>y</mi>
                    </mrow>
                  </msub>
                  <mo>+</mo>
                  <mo> sin </mo>
                  <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

                  <msub>
                    <mrow>
                      <mi>q</mi>
                    </mrow>
                    <mrow>
                      <mi> &theta; </mi>
                    </mrow>
                  </msub>
                  <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
                  <mi> &delta; </mi>
                  <mi>x</mi>
                  <mo>+</mo>
                  <mo> cos </mo>
                  <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

                  <msub>
                    <mrow>
                      <mi>q</mi>
                    </mrow>
                    <mrow>
                      <mi> &theta; </mi>
                    </mrow>
                  </msub>
                  <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
                  <mi> &delta; </mi>
                  <mi>y</mi>
                </mrow>
              </mtd>
            </mtr>
          </mtable>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true' lspace='thinmathspace'>]</mo>
        </mrow>
      </mrow>
    </math>which then explains the Jacobian <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mi>H</mi>
      </mrow>
    </math>.
  </div>

  <h3 class="subsection" id='magicparlabel-65499'><span class="subsection_label">3.3</span> Using Custom Factors</h3>
  <div class="standard" id='magicparlabel-65500'>The following C++ code fragment illustrates how to create and add
    custom factors to a factor graph:</div>

  <div class="standard" id='magicparlabel-65501'>
    <pre>// add unary measurement factors, like GPS, on all three poses
noiseModel::Diagonal::shared_ptr unaryNoise =
 noiseModel::Diagonal::Sigmas(Vector2(0.1, 0.1)); // 10cm std on x,y
graph.add(boost::make_shared&lt;UnaryFactor&gt;(1, 0.0, 0.0, unaryNoise));
graph.add(boost::make_shared&lt;UnaryFactor&gt;(2, 2.0, 0.0, unaryNoise));
graph.add(boost::make_shared&lt;UnaryFactor&gt;(3, 4.0, 0.0, unaryNoise));
</pre>
  </div> In Listing <a href="#listing_LocalizationExample2">3.3</a>, we create the noise model on line 2-3, which now
  specifies two standard deviations on the measurements <math xmlns="http://www.w3.org/1998/Math/MathML">
    <mrow>
      <msub>
        <mrow>
          <mi>m</mi>
        </mrow>
        <mrow>
          <mi>x</mi>
        </mrow>
      </msub>
    </mrow>
  </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
    <mrow>
      <msub>
        <mrow>
          <mi>m</mi>
        </mrow>
        <mrow>
          <mi>y</mi>
        </mrow>
      </msub>
    </mrow>
  </math>. On lines 4-6 we create <em><b>shared_ptr</b></em> versions of three newly created <em><b>UnaryFactor</b></em>
  instances, and add them to graph. GTSAM uses shared pointers to refer to factors in factor graphs, and
  <em><b>boost::make_shared</b></em> is a convenience function to simultaneously construct a class and create a
  <em><b>shared_ptr</b></em> to it. We obtain the factor graph from Figure <a href="#fig_LocalizationFG">4</a>.
  <!-- Output Error: Closing tag `div' when other tags are pending. Discarded pending tags:
&lt;span style='font-family:monospace;'&gt;
&lt;span style='font-size:small;'&gt;
 -->
  </div>
  <h3 class="subsection" id='magicparlabel-65514'><span class="subsection_label">3.4</span> Full Posterior Inference
  </h3>
  <div class="standard" id='magicparlabel-65515'>The three GPS factors are enough to fully constrain all unknown poses
    and tie them to a &ldquo;global&rdquo; reference frame, including the three unknown orientations. If not, GTSAM
    would have exited with a singular matrix exception. The marginals can be recovered exactly as in Section <a
      href="#subsec_Full_Posterior_Inference">2.5</a>, and the solution and marginal covariances are now given by the
    following:</div>
  <div class="standard">
    <pre>Final Result:
Values with 3 values:
Value 1: (-1.5e-14, 1.3e-15, -1.4e-16)
Value 2: (2, 3.1e-16, -8.5e-17)
Value 3: (4, -6e-16, -8.2e-17)

x1 covariance:
      0.0083      4.3e-19     -1.1e-18
     4.3e-19       0.0094      -0.0031
    -1.1e-18      -0.0031       0.0082
x2 covariance:
      0.0071      2.5e-19     -3.4e-19
     2.5e-19       0.0078      -0.0011
    -3.4e-19      -0.0011       0.0082
x3 covariance:
     0.0083     4.4e-19     1.2e-18
    4.4e-19      0.0094      0.0031
    1.2e-18      0.0031       0.018
</pre>
  </div>

  <div class="standard" id='magicparlabel-65516'>Comparing this with the covariance matrices in Section <a
      href="#subsec_Full_Posterior_Inference">2.5</a>, we can see that the uncertainty no longer grows without bounds as
    measurement uncertainty accumulates. Instead, the &ldquo;GPS&rdquo; measurements more or less constrain the poses
    evenly, as expected.</div>



  <div class='float-figure'>
    <div class='float-figure'>
      <div class="plain_layout" style='text-align: center;' id='magicparlabel-65525'><img style='width:80%;'
          src='intro-images/6_Users_dellaert_git_github_doc_images_Odometry.png'
          alt='image: 6_Users_dellaert_git_github_doc_images_Odometry.png'></img>
      </div>

      <div class="plain_layout" id='magicparlabel-65526'><span
          class='float-caption-Standard float-caption float-caption-standard'>Sub-Figure a: Odometry marginals</span>
      </div>
    </div>


    <div class="plain_layout" style='text-align: center;' id='magicparlabel-65531'>&nbsp;</div>

    <div class="plain_layout" style='text-align: center;' id='magicparlabel-65532'><span
        class='float-caption-Standard float-caption float-caption-standard'>Figure 5: <a id="fig_CompareMarginals"></a>
        Comparing the marginals resulting from the &ldquo;odometry&rdquo; factor graph in Figure <a
          href="#fig_OdometryFG">3</a> and the &ldquo;localization&rdquo; factor graph in Figure <a
          href="#fig_LocalizationFG">4</a>.</span></div>
    <div class='float-figure'>
      <div class="plain_layout" style='text-align: center;' id='magicparlabel-65536'><img style='width:80%;'
          src='intro-images/7_Users_dellaert_git_github_doc_images_Localization.png'
          alt='image: 7_Users_dellaert_git_github_doc_images_Localization.png'></img>
      </div>

      <div class="plain_layout" id='magicparlabel-65537'><span
          class='float-caption-Standard float-caption float-caption-standard'>Sub-Figure b: Localization
          Marginals</span></div>
    </div>

  </div>


  <div class="standard" id='magicparlabel-65546'>It helps a lot when we view this graphically, as in Figure <a
      href="#fig_CompareMarginals">5</a>, where I show the marginals on position as 5-sigma covariance ellipses that
    contain 99.9996% of all probability mass. For the odometry marginals, it is immediately apparent from the figure
    that (1) the uncertainty on pose keeps growing, and (2) the uncertainty on angular odometry translates into
    increasing uncertainty on y. The localization marginals, in contrast, are constrained by the unary factors and are
    all much smaller. In addition, while less apparent, the uncertainty on the middle pose is actually smaller as it is
    constrained by odometry from two sides.</div>

  <div class="standard" id='magicparlabel-65547'>You might now be wondering how we produced these figures. The answer is
    via the MATLAB interface of GTSAM, which we will demonstrate in the next section.</div>

  <div class="standard" id='magicparlabel-65548'><br>
  </div>
  <h2 class="section" id='magicparlabel-65549'><span class="section_label">4</span> <a id="sec_Pose2SLAM"></a>
    <a id="sec_WithMarginals"></a>
    PoseSLAM
  </h2>
  <h3 class="subsection" id='magicparlabel-65550'><span class="subsection_label">4.1</span> Loop Closure Constraints
  </h3>
  <div class="standard" id='magicparlabel-65551'>The simplest instantiation of a SLAM problem is <b>PoseSLAM</b>, which
    avoids building an explicit map of the environment. The goal of SLAM is to simultaneously localize a robot and map
    the environment given incoming sensor measurements (<a href='#LyXCite-DurrantWhyte06ram'><span
        class="bib-abbrvciteauthor">Durrant-Whyte and Bailey</span>, <span class="bib-year">2006</span></a>). Besides
    wheel odometry, one of the most popular sensors for robots moving on a plane is a 2D laser-range finder, which
    provides both odometry constraints between successive poses, and loop-closure constraints when the robot re-visits a
    previously explored part of the environment.</div>


  <div class='float-figure'>
    <div class="plain_layout" style='text-align: center;' id='magicparlabel-65556'><img style='width:80%;'
        src='intro-images/8_Users_dellaert_git_github_doc_images_FactorGraph3.png'
        alt='image: 8_Users_dellaert_git_github_doc_images_FactorGraph3.png'></img>
      <span class='float-caption-Standard float-caption float-caption-standard'>Figure 6: <a id="fig_Pose2SLAM"></a>
        Factor graph for PoseSLAM.</span>
    </div>
  </div>


  <div class="standard" id='magicparlabel-65561'> A factor graph example for PoseSLAM is shown in Figure <a
      href="#fig_Pose2SLAM">6</a>. The following C++ code, included in GTSAM as an example, creates this factor graph in
    code: </div>

  <div class="standard" id='magicparlabel-65566'>
    <pre>NonlinearFactorGraph graph;
noiseModel::Diagonal::shared_ptr priorNoise =
  noiseModel::Diagonal::Sigmas(Vector3(0.3, 0.3, 0.1));
graph.add(PriorFactor&lt;Pose2&gt;(1, Pose2(0, 0, 0), priorNoise));

// Add odometry factors
noiseModel::Diagonal::shared_ptr model =
  noiseModel::Diagonal::Sigmas(Vector3(0.2, 0.2, 0.1));
graph.add(BetweenFactor&lt;Pose2&gt;(1, 2, Pose2(2, 0, 0     ), model));
graph.add(BetweenFactor&lt;Pose2&gt;(2, 3, Pose2(2, 0, M_PI_2), model));
graph.add(BetweenFactor&lt;Pose2&gt;(3, 4, Pose2(2, 0, M_PI_2), model));
graph.add(BetweenFactor&lt;Pose2&gt;(4, 5, Pose2(2, 0, M_PI_2), model));

// Add the loop closure constraint
graph.add(BetweenFactor&lt;Pose2&gt;(5, 2, Pose2(2, 0, M_PI_2), model));
</pre>
  </div>

  <div class="standard" id='magicparlabel-65567'> As before, lines 1-4 create a nonlinear factor graph and add the unary
    factor <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <msub>
            <mrow>
              <mi>f</mi>
            </mrow>
            <mrow>
              <mn>0</mn>
            </mrow>
          </msub>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <msub>
            <mrow>
              <mi>x</mi>
            </mrow>
            <mrow>
              <mn>1</mn>
            </mrow>
          </msub>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math>. As the robot travels through the world, it creates binary factors <math
      xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <msub>
            <mrow>
              <mi>f</mi>
            </mrow>
            <mrow>
              <mi>t</mi>
            </mrow>
          </msub>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <msub>
              <mrow>
                <mi>x</mi>
              </mrow>
              <mrow>
                <mi>t</mi>
              </mrow>
            </msub>
            <mo>,</mo>
            <msub>
              <mrow>
                <mi>x</mi>
              </mrow>
              <mrow>
                <mrow>
                  <mi>t</mi>
                  <mo>+</mo>
                  <mn>1</mn>
                </mrow>
              </mrow>
            </msub>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math> corresponding to odometry, added to the graph in lines 6-12 (Note that M_PI_2 refers to pi/2). But line 15
    models a different event: a <b>loop closure</b>. For example, the robot might recognize the same location using
    vision or a laser range finder, and calculate the geometric pose constraint to when it first visited this location.
    This is illustrated for poses <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>x</mi>
          </mrow>
          <mrow>
            <mn>5</mn>
          </mrow>
        </msub>
      </mrow>
    </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>x</mi>
          </mrow>
          <mrow>
            <mn>2</mn>
          </mrow>
        </msub>
      </mrow>
    </math>, and generates the (red) loop closing factor <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <msub>
            <mrow>
              <mi>f</mi>
            </mrow>
            <mrow>
              <mn>5</mn>
            </mrow>
          </msub>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <msub>
              <mrow>
                <mi>x</mi>
              </mrow>
              <mrow>
                <mn>5</mn>
              </mrow>
            </msub>
            <mo>,</mo>
            <msub>
              <mrow>
                <mi>x</mi>
              </mrow>
              <mrow>
                <mn>2</mn>
              </mrow>
            </msub>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math>.</div>


  <div class='float-figure'>
    <div class="plain_layout" style='text-align: center;' id='magicparlabel-65576'><img style='width:80%;'
        src='intro-images/9_Users_dellaert_git_github_doc_images_example1.png'
        alt='image: 9_Users_dellaert_git_github_doc_images_example1.png'></img>
      <span class='float-caption-Standard float-caption float-caption-standard'>Figure 7: <a id="fig_example"></a>
        The result of running optimize on the factor graph in Figure <a href="#fig_Pose2SLAM">6</a>.</span>
    </div>
  </div>


  <div class="standard" id='magicparlabel-65581'>We can optimize this factor graph as before, by creating an initial
    estimate of type <em><b>Values</b></em>, and creating and running an optimizer. The result is shown graphically in
    Figure <a href="#fig_example">7</a>, along with covariance ellipses shown in green. These 5-sigma covariance
    ellipses in 2D indicate the marginal over position, over all possible orientations, and show the area which contain
    99.9996% of the probability mass. The graph shows in a clear manner that the uncertainty on pose <math
      xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>x</mi>
          </mrow>
          <mrow>
            <mn>5</mn>
          </mrow>
        </msub>
      </mrow>
    </math> is now much less than if there would be only odometry measurements. The pose with the highest uncertainty,
    <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>x</mi>
          </mrow>
          <mrow>
            <mn>4</mn>
          </mrow>
        </msub>
      </mrow>
    </math>, is the one furthest away from the unary constraint <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <msub>
            <mrow>
              <mi>f</mi>
            </mrow>
            <mrow>
              <mn>0</mn>
            </mrow>
          </msub>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <msub>
            <mrow>
              <mi>x</mi>
            </mrow>
            <mrow>
              <mn>1</mn>
            </mrow>
          </msub>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math>, which is the only factor tying the graph to a global coordinate frame.
  </div>

  <div class="standard" id='magicparlabel-65582'>The figure above was created using an interface that allows you to use
    GTSAM from within MATLAB, which provides for visualization and rapid development. We discuss this next.</div>
  <h3 class="subsection" id='magicparlabel-65583'><span class="subsection_label">4.2</span> Using the MATLAB Interface
  </h3>
  <div class="standard" id='magicparlabel-65584'>A large subset of the GTSAM functionality can be accessed through
    wrapped classes from within MATLAB <div class="foot"><span class="foot_label">1</span>
      <div class="foot_inner">
        <div class="plain_layout" id='magicparlabel-65588'>GTSAM also allows you to wrap your own custom-made classes,
          although this is outside the scope of this manual.</div>
      </div>
    </div>. The following code excerpt is the MATLAB equivalent of the C++ code in Listing <a
      href="#listing_Pose2SLAMExample">4.1</a>:
    <pre>graph = NonlinearFactorGraph;
priorNoise = noiseModel.Diagonal.Sigmas([0.3; 0.3; 0.1]);
graph.add(PriorFactorPose2(1, Pose2(0, 0, 0), priorNoise));

%% Add odometry factors
model = noiseModel.Diagonal.Sigmas([0.2; 0.2; 0.1]);
graph.add(BetweenFactorPose2(1, 2, Pose2(2, 0, 0   ), model));
graph.add(BetweenFactorPose2(2, 3, Pose2(2, 0, pi/2), model));
graph.add(BetweenFactorPose2(3, 4, Pose2(2, 0, pi/2), model));
graph.add(BetweenFactorPose2(4, 5, Pose2(2, 0, pi/2), model));

%% Add pose constraint
graph.add(BetweenFactorPose2(5, 2, Pose2(2, 0, pi/2), model));
</pre>
  </div>

  <div class="standard" id='magicparlabel-65589'> Note that the code is almost identical, although there are a few
    syntax and naming differences:</div>

  <ul class="itemize" id='magicparlabel-65594'>
    <li class="itemize_item">Objects are created by calling a constructor instead of allocating them on the heap.</li>
    <li class="itemize_item">Namespaces are done using dot notation, i.e.,
      <em><b>noiseModel::Diagonal::SigmasClasses</b></em> becomes <em><b>noiseModel.Diagonal.Sigmas</b></em>.
    </li>
    <li class="itemize_item"><em><b>Vector</b></em> and <em><b>Matrix</b></em> classes in C++ are just vectors/matrices
      in MATLAB.</li>
    <li class="itemize_item">As templated classes do not exist in MATLAB, these have been hardcoded in the GTSAM
      interface, e.g., <em><b>PriorFactorPose2</b></em> corresponds to the C++ class
      <em><b>PriorFactor&lt;Pose2&gt;</b></em>, etc.
    </li>
  </ul>
  <div class="standard" id='magicparlabel-65598'>After executing the code, you can call <em>whos </em>on the MATLAB
    command prompt to see the objects created. Note that the indicated <em>Class</em> corresponds to the wrapped C++
    classes:</div>
  <div class="standard">
    <pre>&gt;&gt; whos
  Name                 Size            Bytes  Class
  graph                1x1               112  gtsam.NonlinearFactorGraph
  priorNoise           1x1               112  gtsam.noiseModel.Diagonal
  model                1x1               112  gtsam.noiseModel.Diagonal
  initialEstimate      1x1               112  gtsam.Values
  optimizer            1x1               112  gtsam.LevenbergMarquardtOptimizer
</pre>
  </div> In addition, any GTSAM object can be examined in detail, yielding identical output to C++:
  <div class="standard">
    <pre>&gt;&gt; priorNoise
diagonal sigmas [0.3; 0.3; 0.1];

&gt;&gt; graph
size: 6
factor 0: PriorFactor on 1
  prior mean: (0, 0, 0)
  noise model: diagonal sigmas [0.3; 0.3; 0.1];
factor 1: BetweenFactor(1,2)
  measured: (2, 0, 0)
  noise model: diagonal sigmas [0.2; 0.2; 0.1];
factor 2: BetweenFactor(2,3)
  measured: (2, 0, 1.6)
  noise model: diagonal sigmas [0.2; 0.2; 0.1];
factor 3: BetweenFactor(3,4)
  measured: (2, 0, 1.6)
  noise model: diagonal sigmas [0.2; 0.2; 0.1];
factor 4: BetweenFactor(4,5)
  measured: (2, 0, 1.6)
  noise model: diagonal sigmas [0.2; 0.2; 0.1];
factor 5: BetweenFactor(5,2)
  measured: (2, 0, 1.6)
  noise model: diagonal sigmas [0.2; 0.2; 0.1];
</pre>
  </div> And it does not stop there: we can also call some of the functions defined for factor graphs. E.g.,

  <div class="standard" id='magicparlabel-65607'>
    <pre>&gt;&gt; graph.error(initialEstimate)
ans =
   20.1086

&gt;&gt; graph.error(result)
ans =
   8.2631e-18
</pre>
  </div> computes the sum-squared error
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <mrow>
      <mfrac>
        <mn>
          1
        </mn>
        <mn>
          2
        </mn>
      </mfrac>
      <munder>
        <mo>
          &sum;
        </mo>
        <mi>
          i
        </mi>
      </munder>
      <msubsup>
        <mrow>
          <mi>
            |
          </mi>
          <mi>
            |
          </mi>
          <mrow>
            <msub>
              <mi>
                h
              </mi>
              <mi>
                i
              </mi>
            </msub>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>
            (
          </mo>
          <mrow>
            <msub>
              <mi>
                X
              </mi>
              <mi>
                i
              </mi>
            </msub>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>
            )
          </mo>
          </mi>
          <mo>
            -
          </mo>
          <mrow>
            <msub>
              <mi>
                z
              </mi>
              <mi>
                i
              </mi>
            </msub>
          </mrow>
          <mi>
            |
          </mi>
          <mi>
            |
          </mi>
        </mrow>
        <mo>
          &Sigma;
        </mo>
        <mn>
          2
        </mn>
      </msubsup>
      <mrow>
  </math>
  before and after optimization.
  <h3 class="subsection" id='magicparlabel-65612'><span class="subsection_label">4.3</span> Reading and Optimizing Pose
    Graphs </h3>

  <div class='float-figure'>
    <div class="plain_layout" style='text-align: center;' id='magicparlabel-65617'><img style='width:80%;'
        src='intro-images/10_Users_dellaert_git_github_doc_images_w100-result.png'
        alt='image: 10_Users_dellaert_git_github_doc_images_w100-result.png'></img>
      <span class='float-caption-Standard float-caption float-caption-standard'>Figure 8: <a id="fig_w100"></a>
        MATLAB plot of small Manhattan world example with 100 poses (due to Ed Olson). The initial estimate is shown in
        green. The optimized trajectory, with covariance ellipses, in blue.</span>
    </div>
  </div>


  <div class="standard" id='magicparlabel-65622'>The ability to work in MATLAB adds a much quicker development cycle,
    and effortless graphical output. The optimized trajectory in Figure <a href="#fig_w100">8</a> was produced by the
    code below, in which <em>load2D</em> reads TORO files. To see how plotting is done, refer to the full source code.
    <pre>%% Initialize graph, initial estimate, and odometry noise
datafile = findExampleDataFile('w100.graph');
model = noiseModel.Diagonal.Sigmas([0.05; 0.05; 5*pi/180]);
[graph,initial] = load2D(datafile, model);

%% Add a Gaussian prior on pose x_0
priorMean = Pose2(0, 0, 0);
priorNoise = noiseModel.Diagonal.Sigmas([0.01; 0.01; 0.01]);
graph.add(PriorFactorPose2(0, priorMean, priorNoise));

%% Optimize using Levenberg-Marquardt optimization and get marginals
optimizer = LevenbergMarquardtOptimizer(graph, initial);
result = optimizer.optimizeSafely;
marginals = Marginals(graph, result);
</pre>
  </div>
  <h3 class="subsection" id='magicparlabel-65623'><span class="subsection_label">4.4</span> PoseSLAM in 3D</h3>
  <div class="standard" id='magicparlabel-65624'>PoseSLAM can easily be extended to 3D poses, but some care is needed to
    update 3D rotations. GTSAM supports both <b>quaternions</b> and <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mn>3</mn>
          <mo> &times; </mo>
          <mn>3</mn>
        </mrow>
      </mrow>
    </math> <b>rotation matrices </b>to represent 3D rotations. The selection is made via the compile flag
    GTSAM_USE_QUATERNIONS.</div>


  <div class='float-figure'>
    <div class="plain_layout" style='text-align: center;' id='magicparlabel-65629'><img style='width:70%;'
        src='intro-images/11_Users_dellaert_git_github_doc_images_sphere2500-result.png'
        alt='image: 11_Users_dellaert_git_github_doc_images_sphere2500-result.png'></img>
      <span class='float-caption-Standard float-caption float-caption-standard'>Figure 9: <a id="fig_w100_1"></a>
        3D plot of sphere example (due to Michael Kaess). The very wrong initial estimate, derived from odometry, is
        shown in green. The optimized trajectory is shown red. Code below:</span>
    </div>
  </div>


  <div class="standard" id='magicparlabel-65634'>
    <pre>%% Initialize graph, initial estimate, and odometry noise
datafile = findExampleDataFile('sphere2500.txt');
model = noiseModel.Diagonal.Sigmas([5*pi/180; 5*pi/180; 5*pi/180; 0.05; 0.05; 0.05]);
[graph,initial] = load3D(datafile, model, true, 2500);
plot3DTrajectory(initial, 'g-', false); % Plot Initial Estimate

%% Read again, now with all constraints, and optimize
graph = load3D(datafile, model, false, 2500);
graph.add(NonlinearEqualityPose3(0, initial.atPose3(0)));
optimizer = LevenbergMarquardtOptimizer(graph, initial);
result = optimizer.optimizeSafely();
plot3DTrajectory(result, 'r-', false); axis equal;
</pre>
  </div>
  <h2 class="section" id='magicparlabel-65635'><span class="section_label">5</span> <a id="sec_Landmark_based_SLAM"></a>
    Landmark-based SLAM</h2>
  <h3 class="subsection" id='magicparlabel-65636'><span class="subsection_label">5.1</span> Basics</h3>

  <div class='float-figure'>
    <div class="plain_layout" style='text-align: center;' id='magicparlabel-65641'><img style='width:80%;'
        src='intro-images/12_Users_dellaert_git_github_doc_images_FactorGraph4.png'
        alt='image: 12_Users_dellaert_git_github_doc_images_FactorGraph4.png'></img>
      <span class='float-caption-Standard float-caption float-caption-standard'>Figure 10: <a id="fig_SLAM"></a>
        Factor graph for landmark-based SLAM</span>
    </div>
  </div>


  <div class="standard" id='magicparlabel-65646'> In <b>landmark-based SLAM</b>, we explicitly build a map with the
    location of observed landmarks, which introduces a second type of variable in the factor graph besides robot poses.
    An example factor graph for a landmark-based SLAM example is shown in Figure <a href="#fig_SLAM">10</a>, which shows
    the typical connectivity: poses are connected in an odometry Markov chain, and landmarks are observed from multiple
    poses, inducing binary factors. In addition, the pose <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>x</mi>
          </mrow>
          <mrow>
            <mn>1</mn>
          </mrow>
        </msub>
      </mrow>
    </math> has the usual prior on it.</div>


  <div class='float-figure'>
    <div class="plain_layout" style='text-align: center;' id='magicparlabel-65655'><img style='width:47%;'
        src='intro-images/13_Users_dellaert_git_github_doc_images_example2.png'
        alt='image: 13_Users_dellaert_git_github_doc_images_example2.png'></img>
      <span class='float-caption-Standard float-caption float-caption-standard'>Figure 11: <a
          id="fig_PlanarSLAMExample"></a>
        The optimized result along with covariance ellipses for both poses (in green) and landmarks (in blue). Also
        shown are the trajectory (red) and landmark sightings (cyan).</span>
    </div>
  </div>


  <div class="standard" id='magicparlabel-65660'>The factor graph from Figure <a href="#fig_SLAM">10</a> can be created
    using the MATLAB code in Listing <a href="#listing_PlanarSLAMExample">5.1</a>. As before, on line 2 we create the
    factor graph, and Lines 8-18 create the prior/odometry chain we are now familiar with. However, the code on lines
    20-25 is new: it creates three <b>measurement factors</b>, in this case &ldquo;bearing/range&rdquo; measurements
    from the pose to the landmark.</div>

  <div class="standard" id='magicparlabel-65661'><br>
  </div>

  <div class="standard" id='magicparlabel-65662'>
    <pre>% Create graph container and add factors to it
graph = NonlinearFactorGraph;

% Create keys for variables
i1 = symbol('x',1); i2 = symbol('x',2); i3 = symbol('x',3);
j1 = symbol('l',1); j2 = symbol('l',2);

% Add prior
priorMean = Pose2(0.0, 0.0, 0.0); % prior at origin
priorNoise = noiseModel.Diagonal.Sigmas([0.3; 0.3; 0.1]);
% add directly to graph
graph.add(PriorFactorPose2(i1, priorMean, priorNoise));

% Add odometry
odometry = Pose2(2.0, 0.0, 0.0);
odometryNoise = noiseModel.Diagonal.Sigmas([0.2; 0.2; 0.1]);
graph.add(BetweenFactorPose2(i1, i2, odometry, odometryNoise));
graph.add(BetweenFactorPose2(i2, i3, odometry, odometryNoise));

% Add bearing/range measurement factors
degrees = pi/180;
brNoise = noiseModel.Diagonal.Sigmas([0.1; 0.2]);
graph.add(BearingRangeFactor2D(i1, j1, Rot2(45*degrees), sqrt(8), brNoise));
graph.add(BearingRangeFactor2D(i2, j1, Rot2(90*degrees), 2, brNoise));
graph.add(BearingRangeFactor2D(i3, j2, Rot2(90*degrees), 2, brNoise));
</pre>
  </div>
  <h3 class="subsection" id='magicparlabel-65663'><span class="subsection_label">5.2</span> Of Keys and Symbols</h3>
  <div class="standard" id='magicparlabel-65664'> The only unexplained code is on lines 4-6: here we create integer keys
    for the poses and landmarks using the <em><b>symbol</b></em> function. In GTSAM, we address all variables using the
    <em><b>Ke</b></em><b>y</b> type, which is just a typedef to <em><b>size_t</b></em>
    <div class="foot"><span class="foot_label">2</span>
      <div class="foot_inner">
        <div class="plain_layout" id='magicparlabel-65672'>a 32 or 64 bit integer, depending on your platform</div>
      </div>
    </div>. The keys do not have to be numbered continuously, but they do have to be unique within a given factor graph.
    For factor graphs with different types of variables, we provide the <em><b>symbol</b></em> function in MATLAB, and
    the <em><b>Symbol</b></em> type in C++, to help you create (large) integer keys that are far apart in the space of
    possible keys, so you don't have to think about starting the point numbering at some arbitrary offset. To create a a
    <em>symbol key</em> you simply provide a character and an integer index. You can use base 0 or 1, or use arbitrary
    indices: it does not matter. In the code above, we we use 'x' for poses, and 'l' for landmarks.
  </div>

  <div class="standard" id='magicparlabel-65677'>The optimized result for the factor graph created by Listing <a
      href="#listing_PlanarSLAMExample">5.1</a> is shown in Figure <a href="#fig_PlanarSLAMExample">11</a>, and it is
    readily apparent that the landmark <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>l</mi>
          </mrow>
          <mrow>
            <mn>1</mn>
          </mrow>
        </msub>
      </mrow>
    </math> with two measurements is better localized. In MATLAB we can also examine the actual numerical values, and
    doing so reveals some more GTSAM magic:</div>

  <div class="standard" id='magicparlabel-65678'><span style='font-size:small;'>&gt;&gt; result
      Values with 5 values:
      l1: (2, 2)
      l2: (4, 2)
      x1: (-1.8e-16, 5.1e-17, -1.5e-17)
      x2: (2, -5.8e-16, -4.6e-16)
      x3: (4, -3.1e-15, -4.6e-16)
    </span></div>

  <div class="standard" id='magicparlabel-65679'> Indeed, the keys generated by symbol are automatically detected by the
    <em><b>print</b></em> method in the <em><b>Values</b></em> class, and rendered in human-readable form
    &ldquo;x1&rdquo;, &ldquo;l2&rdquo;, etc, rather than as large, unwieldy integers. This magic extends to most factors
    and other classes where the <b>Key</b> type is used.
  </div>
  <h3 class="subsection" id='magicparlabel-65684'><span class="subsection_label">5.3</span> A Larger Example</h3>

  <div class='float-figure'>
    <div class="plain_layout" style='text-align: center;' id='magicparlabel-65689'><img style='width:90%;'
        src='intro-images/14_Users_dellaert_git_github_doc_images_littleRobot.png'
        alt='image: 14_Users_dellaert_git_github_doc_images_littleRobot.png'></img>
      <span class='float-caption-Standard float-caption float-caption-standard'>Figure 12: <a id="fig_littleRobot"></a>
        A larger example with about 100 poses and 30 or so landmarks, as produced by
        gtsam_examples/PlanarSLAMExample_graph.m</span>
    </div>
  </div>


  <div class="standard" id='magicparlabel-65694'>GTSAM comes with a slightly larger example that is read from a .graph
    file by PlanarSLAMExample_graph.m, shown in Figure <a href="#fig_littleRobot">12</a>. To not clutter the figure only
    the marginals are shown, not the lines of sight. This example, with 119 (multivariate) variables and 517 factors
    optimizes in less than 10 ms.</div>
  <h3 class="subsection" id='magicparlabel-65695'><span class="subsection_label">5.4</span> A Real-World Example</h3>

  <div class='float-figure'>
    <div class="plain_layout" style='text-align: center;' id='magicparlabel-65700'><img style='width:90%;'
        src='intro-images/15_Users_dellaert_git_github_doc_images_Victoria.png'
        alt='image: 15_Users_dellaert_git_github_doc_images_Victoria.png'></img>
      <span class='float-caption-Standard float-caption float-caption-standard'>Figure 13: <a id="fig_Victoria_1"></a>
        Small section of optimized trajectory and landmarks (trees detected in a laser range finder scan) from data
        recorded in Sydney's Victoria Park (dataset due to Jose Guivant, U. Sydney).</span>
    </div>
  </div>


  <div class="standard" id='magicparlabel-65705'>A real-world example is shown in Figure <a
      href="#fig_Victoria_1">13</a>, using data from a well known dataset collected in Sydney's Victoria Park, using a
    truck equipped with a laser range-finder. The covariance matrices in this figure were computed very efficiently, as
    explained in detail in (<a href='#LyXCite-Kaess09ras'><span class="bib-abbrvciteauthor">Kaess and Dellaert</span>,
      <span class="bib-year">2009</span></a>). The exact covariances (blue, smaller ellipses) obtained by our fast
    algorithm coincide with the exact covariances based on full inversion (orange, mostly hidden by blue). The much
    larger conservative covariance estimates (green, large ellipses) were based on our earlier work in (<a
      href='#LyXCite-Kaess08tro'><span class="bib-abbrvciteauthor">Kaess et al.</span>, <span
        class="bib-year">2008</span></a>).</div>

  <div class="standard" id='magicparlabel-65706'><br>
  </div>
  <h2 class="section" id='magicparlabel-65707'><span class="section_label">6</span> Structure from Motion</h2>

  <div class='float-figure'>
    <div class="plain_layout" style='text-align: center;' id='magicparlabel-65712'><img style='width:80%;'
        src='intro-images/16_Users_dellaert_git_github_doc_images_cube.png'
        alt='image: 16_Users_dellaert_git_github_doc_images_cube.png'></img>
      <span class='float-caption-Standard float-caption float-caption-standard'>Figure 14: <a id="fig_SFMExample"></a>
        An optimized &ldquo;Structure from Motion&rdquo; with 10 cameras arranged in a circle, observing the 8 vertices
        of a <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow>
            <mrow>
              <mn>20</mn>
              <mo> &times; </mo>
              <mn>20</mn>
              <mo> &times; </mo>
              <mn>20</mn>
            </mrow>
          </mrow>
        </math> cube centered around the origin. The camera is rendered with color-coded axes, (RGB for XYZ) and the
        viewing direction is is along the positive Z-axis. Also shown are the 3D error covariance ellipses for both
        cameras and points.</span>
    </div>
  </div>


  <div class="standard" id='magicparlabel-65717'><b> Structure from Motion</b> (SFM) is a technique to recover a 3D
    reconstruction of the environment from corresponding visual features in a collection of <em>unordered</em> images,
    see Figure <a href="#fig_SFMExample">14</a>. In GTSAM this is done using exactly the same factor graph framework,
    simply using SFM-specific measurement factors. In particular, there is a <b>projection factor</b> that calculates
    the reprojection error <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mrow>
          <mi>f</mi>
          <mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>

          <mrow>
            <msub>
              <mrow>
                <mi>x</mi>
              </mrow>
              <mrow>
                <mi>i</mi>
              </mrow>
            </msub>
            <mo>,</mo>
            <msub>
              <mrow>
                <mi>p</mi>
              </mrow>
              <mrow>
                <mi>j</mi>
              </mrow>
            </msub>
            <mo>;</mo>
            <msub>
              <mrow>
                <mi>z</mi>
              </mrow>
              <mrow>
                <mrow>
                  <mi>i</mi>
                  <mi>j</mi>
                </mrow>
              </mrow>
            </msub>
            <mo>,</mo>
            <mi>K</mi>
          </mrow>
          <mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

        </mrow>
      </mrow>
    </math> for a given camera pose <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>x</mi>
          </mrow>
          <mrow>
            <mi>i</mi>
          </mrow>
        </msub>
      </mrow>
    </math> (a <em><b>Pose3</b></em>) and point <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>p</mi>
          </mrow>
          <mrow>
            <mi>j</mi>
          </mrow>
        </msub>
      </mrow>
    </math> (a <em><b>Point3</b></em>). The factor is parameterized by the 2D measurement <math
      xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>z</mi>
          </mrow>
          <mrow>
            <mrow>
              <mi>i</mi>
              <mi>j</mi>
            </mrow>
          </mrow>
        </msub>
      </mrow>
    </math> (a <em><b>Point2</b></em>), and known calibration parameters <math
      xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mi>K</mi>
      </mrow>
    </math> (of type <em><b>Cal3_S2</b></em>). The following listing shows how to create the factor graph:
    <pre>%% Add factors for all measurements
noise = noiseModel.Isotropic.Sigma(2, measurementNoiseSigma);
for i = 1:length(Z),
    for k = 1:length(Z{i})
        j = J{i}{k};
        G.add(GenericProjectionFactorCal3_S2(
              Z{i}{k}, noise, symbol('x', i), symbol('p', j), K));
    end
end
</pre>
  </div>

  <div class="standard" id='magicparlabel-65722'> In Listing <a href="#listing_SFMExample">6</a>, assuming that the
    factor graph was already created, we add measurement factors in the double loop. We loop over images with index
    <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mi>i</mi>
      </mrow>
    </math>, and in this example the data is given as two cell arrays: Z{i} specifies a set of measurements <math
      xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <msub>
          <mrow>
            <mi>z</mi>
          </mrow>
          <mrow>
            <mi>k</mi>
          </mrow>
        </msub>
      </mrow>
    </math> in image <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mrow>
        <mi>i</mi>
      </mrow>
    </math>, and J{i} specifies the corresponding point index. The specific factor type we use is a
    <em><b>GenericProjectionFactorCal3_S2</b></em>, which is the MATLAB equivalent of the C++ class
    <em><b>GenericProjectionFactor&lt;Cal3_S2&gt;</b></em>, where <em><b>Cal3_S2</b></em> is the camera calibration type
    we choose to use (the standard, no-radial distortion, 5 parameter calibration matrix). As before landmark-based SLAM
    (Section <a href="#sec_Landmark_based_SLAM">5</a>), here we use symbol keys except we now use the character 'p' to
    denote points, rather than 'l' for landmark.
  </div>

  <div class="standard" id='magicparlabel-65727'>Important note: a very tricky and difficult part of making SFM work is
    (a) data association, and (b) initialization. GTSAM does neither of these things for you: it simply provides the
    &ldquo;bundle adjustment&rdquo; optimization. In the example, we simply assume the data association is known (it is
    encoded in the J sets), and we initialize with the ground truth, as the intent of the example is simply to show you
    how to set up the optimization problem.</div>
  <h2 class="section" id='magicparlabel-65728'><span class="section_label">7</span> iSAM: Incremental Smoothing and
    Mapping</h2>
  <div class="standard" id='magicparlabel-65729'>GTSAM provides an incremental inference algorithm based on a more
    advanced graphical model, the Bayes tree, which is kept up to date by the <b>iSAM</b> algorithm (incremental
    Smoothing and Mapping, see <a href='#LyXCite-Kaess08tro'><span class="bib-abbrvciteauthor">Kaess et al.</span></a>
    (<span class="bib-year">2008</span>); <a href='#LyXCite-Kaess12ijrr'><span class="bib-abbrvciteauthor">Kaess et
        al.</span></a> (<span class="bib-year">2012</span>) for an in-depth treatment). For mobile robots operating in
    real-time it is important to have access to an updated map as soon as new sensor measurements come in. iSAM keeps
    the map up-to-date in an efficient manner. </div>

  <div class="standard" id='magicparlabel-65730'>Listing <a href="#listing_iSAMExample">7</a> shows how to use iSAM in a
    simple visual SLAM example. In line 1-2 we create a <em><b>NonlinearISAM</b></em> object which will relinearize and
    reorder the variables every 3 steps. The correct value for this parameter depends on how non-linear your problem is
    and how close you want to be to gold-standard solution at every step. In iSAM 2.0, this parameter is not needed, as
    iSAM2 automatically determines when linearization is needed and for which variables.</div>

  <div class="standard" id='magicparlabel-65731'>The example involves eight 3D points that are seen from eight
    successive camera poses. Hence in the first step -which is omitted here- all eight landmarks and the first pose are
    properly initialized. In the code this is done by perturbing the known ground truth, but in a real application great
    care is needed to properly initialize poses and landmarks, especially in a monocular sequence.</div>

  <div class="standard" id='magicparlabel-65732'><br>
    <pre>int relinearizeInterval = 3;
NonlinearISAM isam(relinearizeInterval);

// ... first frame initialization omitted ...

// Loop over the different poses, adding the observations to iSAM
for (size_t i = 1; i &lt; poses.size(); ++i) {

  // Add factors for each landmark observation
  NonlinearFactorGraph graph;
  for (size_t j = 0; j &lt; points.size(); ++j) {
    graph.add(
      GenericProjectionFactor&lt;Pose3, Point3, Cal3_S2&gt;
        (z[i][j], noise,Symbol('x', i), Symbol('l', j), K)
    );
  }

  // Add an initial guess for the current pose
  Values initialEstimate;
  initialEstimate.insert(Symbol('x', i), initial_x[i]);

  // Update iSAM with the new factors
  isam.update(graph, initialEstimate);
 }
</pre>
  </div>

  <div class="standard" id='magicparlabel-65733'>The remainder of the code illustrates a typical iSAM loop:</div>

  <ol class="enumerate" id='magicparlabel-65734'>
    <li class="enumerate_item">Create factors for new measurements. Here, in lines 9-18, a small
      <em><b>NonlinearFactorGraph</b></em> is created to hold the new factors of type
      <em><b>GenericProjectionFactor&lt;Pose3, Point3, Cal3_S2&gt;</b></em>.
    </li>
    <li class="enumerate_item">Create an initial estimate for all newly introduced variables. In this small example, all
      landmarks have been observed in frame 1 and hence the only new variable that needs to be initialized at each time
      step is the new pose. This is done in lines 20-22. Note we assume a good initial estimate is available as
      <em>initial_x[i]</em>.
    </li>
    <li class="enumerate_item">Finally, we call <em>isam.update()</em>, which takes the factors and initial estimates,
      and incrementally updates the solution, which is available through the method <em>isam.estimate()</em>, if
      desired.</li>
  </ol>
  <div class="standard" id='magicparlabel-65737'><br>
  </div>
  <h2 class="section" id='magicparlabel-65738'><span class="section_label">8</span> More Applications</h2>
  <div class="standard" id='magicparlabel-65739'>While a detailed discussion of all the things you can do with GTSAM
    will take us too far, below is a small survey of what you can expect to do, and which we did using GTSAM.</div>


  <h3 class="subsection" id='magicparlabel-65754'><span class="subsection_label">8.1</span> Conjugate Gradient
    Optimization</h3>

  <div class='float-figure'>
    <div class="plain_layout" style='text-align: center;' id='magicparlabel-65759'><img style='width:70%;'
        src='intro-images/17_Users_dellaert_git_github_doc_images_Beijing.png'
        alt='image: 17_Users_dellaert_git_github_doc_images_Beijing.png'></img>
      <span class='float-caption-Standard float-caption float-caption-standard'>Figure 15: <a id="fig_Beijing"></a>
        A map of Beijing, with a spanning tree shown in black, and the remaining <em>loop-closing</em> constraints shown
        in red. A spanning tree can be used as a <em>preconditioner</em> by GTSAM.</span>
    </div>
  </div>


  <div class="standard" id='magicparlabel-65764'>GTSAM also includes efficient preconditioned conjugate gradients (PCG)
    methods for solving large-scale SLAM problems. While direct methods, popular in the literature, exhibit quadratic
    convergence and can be quite efficient for sparse problems, they typically require a lot of storage and efficient
    elimination orderings to be found. In contrast, iterative optimization methods only require access to the gradient
    and have a small memory footprint, but can suffer from poor convergence. Our method, <em>subgraph
      preconditioning</em>, explained in detail in <a href='#LyXCite-Dellaert10iros'><span
        class="bib-abbrvciteauthor">Dellaert et al.</span></a> (<span class="bib-year">2010</span>); <a
      href='#LyXCite-Jian11iccv'><span class="bib-abbrvciteauthor">Jian et al.</span></a> (<span
      class="bib-year">2011</span>), combines the advantages of direct and iterative methods, by identifying a
    sub-problem that can be easily solved using direct methods, and solving for the remaining part using PCG. The easy
    sub-problems correspond to a spanning tree, a planar subgraph, or any other substructure that can be efficiently
    solved. An example of such a subgraph is shown in Figure <a href="#fig_Beijing">15</a>.</div>
  <h3 class="subsection" id='magicparlabel-65765'><span class="subsection_label">8.2</span> Visual Odometry</h3>
  <div class="standard" id='magicparlabel-65766'>A gentle introduction to vision-based sensing is <b>Visual Odometry</b>
    (abbreviated VO, see e.g. <a href='#LyXCite-Nister04cvpr2'><span class="bib-abbrvciteauthor">Nistér et
        al.</span></a> (<span class="bib-year">2004</span>)), which provides pose constraints between successive robot
    poses by tracking or associating visual features in successive images taken by a camera mounted rigidly on the
    robot. GTSAM includes both C++ and MATLAB example code, as well as VO-specific factors to help you on the way.</div>
  <h3 class="subsection" id='magicparlabel-65767'><span class="subsection_label">8.3</span> Visual SLAM</h3>
  <div class="standard" id='magicparlabel-65768'><b>Visual SLAM</b> (see e.g., <a href='#LyXCite-Davison03iccv'><span
        class="bib-abbrvciteauthor">Davison</span></a> (<span class="bib-year">2003</span>)) is a SLAM variant where 3D
    points are observed by a camera as the camera moves through space, either mounted on a robot or moved around by
    hand. GTSAM, and particularly iSAM (see below), can easily be adapted to be used as the back-end optimizer in such a
    scenario.</div>
  <h3 class="subsection" id='magicparlabel-65769'><span class="subsection_label">8.4</span> Fixed-lag Smoothing and
    Filtering </h3>
  <div class="standard" id='magicparlabel-65770'>GTSAM can easily perform recursive estimation, where only a subset of
    the poses are kept in the factor graph, while the remaining poses are marginalized out. In all examples above we
    explicitly optimize for all variables using all available measurements, which is called <b>Smoothing</b> because the
    trajectory is &ldquo;smoothed&rdquo; out, and this is where GTSAM got its name (GT <em>Smoothing</em> and Mapping).
    When instead only the last few poses are kept in the graph, one speaks of <b>Fixed-lag Smoothing</b>. Finally, when
    only the single most recent poses is kept, one speaks of <b>Filtering</b>, and indeed the original formulation of
    SLAM was filter-based (<a href='#LyXCite-Smith87b'><span class="bib-abbrvciteauthor">Smith et al.</span>, <span
        class="bib-year">1988</span></a>).</div>
  <h3 class="subsection" id='magicparlabel-65771'><span class="subsection_label">8.5</span> Discrete Variables and HMMs
  </h3>
  <div class="standard" id='magicparlabel-65772'>Finally, factor graphs are not limited to continuous variables: GTSAM
    can also be used to model and solve discrete optimization problems. For example, a Hidden Markov Model (HMM) has the
    same graphical model structure as the Robot Localization problem from Section <a
      href="#sec_Robot_Localization">2</a>, except that in an HMM the variables are discrete. GTSAM can optimize and
    perform inference for discrete models.</div>
  <h2 class="section_" id='magicparlabel-65773'>Acknowledgements</h2>
  <div class="standard" id='magicparlabel-65774'>GTSAM was made possible by the efforts of many collaborators at Georgia
    Tech and elsewhere, including but not limited to Doru Balcan, Chris Beall, Alex Cunningham, Alireza Fathi, Eohan
    George, Viorela Ila, Yong-Dian Jian, Michael Kaess, Kai Ni, Carlos Nieto, Duy-Nguyen Ta, Manohar Paluri, Christian
    Potthast, Richard Roberts, Grant Schindler, and Stephen Williams. In addition, Paritosh Mohan helped me with the
    manual. Many thanks all for your hard work!</div>

  <div class="standard" id='magicparlabel-65775'><br>
    <h2 class='bibtex'>References</h2>
    <div class='bibtex'>
      <div class='bibtexentry' id='LyXCite-Davison03iccv'><span class='bibtexlabel'>Davison 2003</span><span
          class='bibtexinfo'><span class="bib-fullnames:author">Davison, A.J.</span>, "<span class="bib-title">Real-Time
            Simultaneous Localisation and Mapping with a Single Camera</span>", in <i><span class="bib-booktitle">Intl.
              Conf. on Computer Vision (ICCV)</span></i> (<span class="bib-year">2003</span>), pp. <span
            class="bib-pages">1403-1410</span>.</span></div>
      <div class='bibtexentry' id='LyXCite-Dellaert06ijrr'><span class='bibtexlabel'>Dellaert and Kaess 2006</span><span
          class='bibtexinfo'><span class="bib-fullnames:author">Dellaert, F. and Kaess, M.</span>, "<span
            class="bib-title">Square Root SAM: Simultaneous Localization and Mapping via Square Root Information
            Smoothing</span>", <i><span class="bib-journal">Intl. J. of Robotics Research</span></i> <span
            class="bib-volume">25</span>, <span class="bib-number">12</span> (<span class="bib-year">2006</span>), pp.
          <span class="bib-pages">1181--1203</span>.</span></div>
      <div class='bibtexentry' id='LyXCite-Dellaert99b'><span class='bibtexlabel'>Dellaert et al. 1999</span><span
          class='bibtexinfo'><span class="bib-fullnames:author">Dellaert, F., Fox, D., Burgard, W., and Thrun,
            S.</span>, "<span class="bib-title">Using the Condensation Algorithm for Robust, Vision-based Mobile Robot
            Localization</span>", in <i><span class="bib-booktitle">IEEE Conf. on Computer Vision and Pattern
              Recognition (CVPR)</span></i> (<span class="bib-year">1999</span>).</span></div>
      <div class='bibtexentry' id='LyXCite-Dellaert10iros'><span class='bibtexlabel'>Dellaert et al. 2010</span><span
          class='bibtexinfo'><span class="bib-fullnames:author">Dellaert, F., Carlson, J., Ila, V., Ni, K., and Thorpe,
            C.E.</span>, "<span class="bib-title">Subgraph-preconditioned Conjugate Gradient for Large Scale
            SLAM</span>", in <i><span class="bib-booktitle">IEEE/RSJ Intl. Conf. on Intelligent Robots and Systems
              (IROS)</span></i> (<span class="bib-year">2010</span>).</span></div>
      <div class='bibtexentry' id='LyXCite-DurrantWhyte06ram'><span class='bibtexlabel'>Durrant-Whyte and Bailey
          2006</span><span class='bibtexinfo'><span class="bib-fullnames:author">Durrant-Whyte, H.F. and Bailey,
            T.</span>, "<span class="bib-title">Simultaneous Localisation and Mapping (SLAM): Part I The Essential
            Algorithms</span>", <i><span class="bib-journal">Robotics &amp; Automation Magazine</span></i> (<span
            class="bib-year">2006</span>).</span></div>
      <div class='bibtexentry' id='LyXCite-Jian11iccv'><span class='bibtexlabel'>Jian et al. 2011</span><span
          class='bibtexinfo'><span class="bib-fullnames:author">Jian, Y.-D., Balcan, D., and Dellaert, F.</span>, "<span
            class="bib-title">Generalized Subgraph Preconditioners for Large-Scale Bundle Adjustment</span>", in
          <i><span class="bib-booktitle">Intl. Conf. on Computer Vision (ICCV)</span></i> (<span
            class="bib-year">2011</span>).</span></div>
      <div class='bibtexentry' id='LyXCite-Kaess09ras'><span class='bibtexlabel'>Kaess and Dellaert 2009</span><span
          class='bibtexinfo'><span class="bib-fullnames:author">Kaess, M. and Dellaert, F.</span>, "<span
            class="bib-title">Covariance Recovery from a Square Root Information Matrix for Data Association</span>",
          <i><span class="bib-journal">Robotics and Autonomous Systems</span></i> (<span
            class="bib-year">2009</span>).</span></div>
      <div class='bibtexentry' id='LyXCite-Kaess08tro'><span class='bibtexlabel'>Kaess et al. 2008</span><span
          class='bibtexinfo'><span class="bib-fullnames:author">Kaess, M., Ranganathan, A., and Dellaert, F.</span>,
          "<span class="bib-title">iSAM: Incremental Smoothing and Mapping</span>", <i><span class="bib-journal">IEEE
              Trans. Robotics</span></i> <span class="bib-volume">24</span>, <span class="bib-number">6</span> (<span
            class="bib-year">2008</span>), pp. <span class="bib-pages">1365-1378</span>.</span></div>
      <div class='bibtexentry' id='LyXCite-Kaess12ijrr'><span class='bibtexlabel'>Kaess et al. 2012</span><span
          class='bibtexinfo'><span class="bib-fullnames:author">Kaess, M., Johannsson, H., Roberts, R., Ila, V.,
            Leonard, J., and Dellaert, F.</span>, "<span class="bib-title">iSAM2: Incremental Smoothing and Mapping
            Using the Bayes Tree</span>", <i><span class="bib-journal">Intl. J. of Robotics Research</span></i> <span
            class="bib-volume">31</span> (<span class="bib-year">2012</span>), pp. <span
            class="bib-pages">217--236</span>.</span></div>
      <div class='bibtexentry' id='LyXCite-Koller09book'><span class='bibtexlabel'>Koller and Friedman 2009</span><span
          class='bibtexinfo'><span class="bib-fullnames:author">Koller, D. and Friedman, N.</span>, <i><span
              class="bib-title">Probabilistic Graphical Models: Principles and Techniques</span></i> (<span
            class="bib-publisher">The MIT Press</span>, <span class="bib-year">2009</span>).</span></div>
      <div class='bibtexentry' id='LyXCite-Kschischang01it'><span class='bibtexlabel'>Kschischang et al.
          2001</span><span class='bibtexinfo'><span class="bib-fullnames:author">Kschischang, F.R., Frey, B.J., and
            Loeliger, H-A.</span>, "<span class="bib-title">Factor Graphs and the Sum-Product Algorithm</span>",
          <i><span class="bib-journal">IEEE Trans. Inform. Theory</span></i> <span class="bib-volume">47</span>, <span
            class="bib-number">2</span> (<span class="bib-year">2001</span>).</span></div>
      <div class='bibtexentry' id='LyXCite-Loeliger04spm'><span class='bibtexlabel'>Loeliger 2004</span><span
          class='bibtexinfo'><span class="bib-fullnames:author">Loeliger, H.-A.</span>, "<span class="bib-title">An
            Introduction to Factor Graphs</span>", <i><span class="bib-journal">IEEE Signal Processing
              Magazine</span></i> (<span class="bib-year">2004</span>), pp. <span
            class="bib-pages">28--41</span>.</span></div>
      <div class='bibtexentry' id='LyXCite-Nister04cvpr2'><span class='bibtexlabel'>Nistér et al. 2004</span><span
          class='bibtexinfo'><span class="bib-fullnames:author">Nistér, D., Naroditsky, O., and Bergen, J.</span>,
          "<span class="bib-title">Visual Odometry</span>", in <i><span class="bib-booktitle">IEEE Conf. on Computer
              Vision and Pattern Recognition (CVPR)</span></i> vol. <span class="bib-volume">1</span>, (<span
            class="bib-year">2004</span>), pp. <span class="bib-pages">652-659</span>.</span></div>
      <div class='bibtexentry' id='LyXCite-Smith87b'><span class='bibtexlabel'>Smith et al. 1988</span><span
          class='bibtexinfo'><span class="bib-fullnames:author">Smith, R., Self, M., and Cheeseman, P.</span>, "<span
            class="bib-title">A stochastic map for uncertain spatial relationships</span>", in <i><span
              class="bib-booktitle">Proc. of the Intl. Symp. of Robotics Research (ISRR)</span></i> (<span
            class="bib-year">1988</span>), pp. <span class="bib-pages">467-474</span>.</span></div>
    </div>
  </div>
</body>

</html>
